[
["index.html", "Cookbook for R 中文版 前言 0.1 问题与反馈 0.2 致谢", " Cookbook for R 中文版 Winston Chang（著） 王诗翔 等（译） 2019-06-27 前言 这里是《Cookbook for R》中文版的网站，本站内容的翻译由生物信息学创新协作小组 Openbiox 完成翻译并维护。这里以直观明了的问题/需求和方案为基本内容向读者介绍 R 的基础和如何解决常见的分析问题。从阅读中读者可以学习安装和使用三方包、操作基础的数据类型，学习数据的导入、操作和可视化，学习统计分析和编写脚本等内容。这本书是 R 诸多问题解决方案的参考手册，建议读者配合系统的 R 语言读物使用，如《R for Data Science》。 推荐读者阅读本书的两种方式： 将它看作常见的技术教程书籍，按照章节目录依次阅读 将它看作问答列表，在实际遇到问题时根据书籍目录翻阅查找相关解决方案 这个网站是（永久）免费的，它以原文所遵循的CC BY-SA 3.0 协议发布。目前该站点内容还没有纸质出版，如果读者是出版人员，并有意愿负责出版该书，请通过 committee@openbiox.org 联系我们。 0.1 问题与反馈 网站所有网页的源文件均用 R Markdown 撰写。如果你在网站发现了任何错误，恳请点击菜单栏上的 “编辑” 按钮，并在 Github 上向我们提交合并请求。如果读者有任何的疑问或者遇到以下提到的内容不当之处，请通过创建 GitHub issue 与我们联系。 翻译内容不通顺，影响阅读体验 中英文括号的错误使用，如 () 写成了 （），。写成了 . 包名没有以加粗的方式标识，如 ggplot2 包应当显示成 ggplot2，而不是 ggplot2 或 ggplot2 函数名后没有伴随成对的英文括号，如表明 summary 是函数时应写为 summary()，而 summary 这种写法则应该表示的是对象、数据框的列名或选项等 网页链接点击跳转不正确 标题的层次结构不对，比如本来是 4 级标成了 3 级 或 5 级 排版不好或存在问题 … 另外，有小部分代码注释存在没有翻译的现象，如果不影响读者阅读，请忽略它们。如果你觉得它严重影响了你的理解，请反馈给我们或提交相关内容所有的翻译（而不是一行）。 如果你存在一些分析问题，而且认为它是大多数人可能都会遇到的，想要寻求通用的解决方案，也可以反馈，我们会想办法解决并更新到相应章节下。 0.2 致谢 2017 年我在简书开始发布《Cookbook for R》内容的翻译，近两年后的今天所有的内容终于都以完整的姿态展现在读者的面前。2019 年 3 月以前，这里大部分内容还是散乱存储在 GitHub 中的文档，层次混乱、存在各种问题。本项目最需要感谢的是新生的 Openbiox 小组，我通过 Openbiox 创建翻译项目并招募了一批志趣相投的成员，在 3 个月的业余时间里，一起完成了所有内容的翻译、校对、整理等工作。下表列出了项目所有贡献人员及简要描述（以姓名的首字母排序），如果不是他们，这本中文书再过两年也不会跟大家见面。 贡献者 贡献内容简述 陈颖珊 翻译：第九、十章；校对：第五、十章 梁其云 翻译：第十、十一、十二章; 整合: 第二章; 校对: 第七、八、九章 王慧美 翻译：第九章 王诗翔 项目负责人；主要译者 熊逸 翻译：第六章 杨芮 翻译：第九章；整合：第七章；校对：第一、四章 赵飞 校对：第二、三章 第六章；拟定校对标准 张浩浩 校对&amp;排版：第二、三、六、九章 也要感谢原作者 Winston Chang，如果不是他无私的贡献和卓越的创作才华，我们不可能学习到如此实用且有趣的知识。 最后，感谢我的女朋友周丹，如果不是她时刻的敦促，我无法对这个翻译项目投入持续的热情和精力。 王诗翔 于 上海科技大学 "],
["author.html", "作者简介", " 作者简介 Winston Chang winston@stdout.org Winston 是 RStudio 的软件工程师，他是软件包 Shiny、ggplot2 和 devtools 的开发者。他获得西北大学的心理学专业博士学位，也是 O’Reilly Media 出版的《R Graphics Cookbook》的作者。 "],
["chapter1.html", "第 1 章 基础 1.1 安装和使用 R 包 1.2 数据结构的索引 1.3 获取数据结构的子集 1.4 创建填满值的向量 1.5 变量信息 1.6 NULL、NA、NaN 的处理", " 第 1 章 基础 1.1 安装和使用 R 包 1.1.1 问题 你想安装和使用一个 R 包。 1.1.2 方案 如果你正在使用支持 R 的图形界面软件，应该存在通过菜单栏方式安装 R 包的选项（例如，常用的 Rstudio 中，可以点击菜单栏 Tools 中的 Install Packages… 进行 R 包的安装）。这里主要介绍如何用命令行来安装 R 包，如下所示： install.packages(&quot;reshape2&quot;) # reshap2为包名 在一个新 R 线程中使用该包之前，你必须先导入它。 library(reshape2) 如果你在一个脚本中使用该包，将这一行输入脚本中。 如果想要将所有已安装的软件包更新为可用的最新版本，使用以下命令： update.packages() 如果你在 Linux 系统上使用 R ，管理员可能已经在系统上安装了一些 R 包，由于普通用户没有更改权限，所以你可能不能以上述方式对 R 包更新。 其他 导入包也可以使用require()函数。下表显示了 R 包安装相关的命令及描述。 表 1.1: 常见包安装命令 命令 描述 installed.packages 返回一个矩阵，包含所有已安装的包信息 available.packages 返回一个矩阵，包含资源库上所有可用的R包 old.packages 返回一个矩阵，显示所有已安装的包中具有新版本的包 new.packages 返回一个矩阵，包含所有已安装的包信 download.packages 下载一系列R包到本地目录 install.packages 从资源库下载安装一系列R包 remove.packages 移除一系列已安装的R包 installed.packages 将已经安装的R包更新到最新版本 setRepositories 设定当前的R包的资源库列表 通过命令行安装 R 包 R CMD INSTALL aplpack_1.1.1.tgz # 安装aplpack包 从其他资源库安装 R 包 devtools 包提供了从其他流行的 Git 资源库或其他 URL 上安装 R 包的工具。 例如，我们想安装开发版本的 ggplot2 包，可以使用下面命令： # 如果没有安装devtools，需要先安装 install.packages(&quot;devtools&quot;) library(devtools) install_github(&quot;ggplot2&quot;) 1.2 数据结构的索引 1.2.1 问题 你想获得数据结构的一部分。 1.2.2 方案 可以使用数字索引或通过使用适当长度的布尔向量来提取向量、矩阵或数据框中的元素。 以下例子中使用了多种方式来解决这一问题。 1.2.2.1 使用数字和名称进行索引 对于向量 # 样本向量 v &lt;- c(1, 4, 4, 3, 2, 2, 3) v[c(2, 3, 4)] #&gt; [1] 4 4 3 v[2:4] #&gt; [1] 4 4 3 v[c(2, 4, 3)] #&gt; [1] 4 3 4 对于数据框： # 创建样本数据框 data &lt;- read.table(header = T, text = &quot; subject sex size 1 M 7 2 F 6 3 F 9 4 M 11 &quot;) # 获取位于第一行第三列的元素 data[1, 3] #&gt; [1] 7 data[1, &quot;size&quot;] #&gt; [1] 7 # 获取第1行和第2行所有列上的元素 data[1:2, ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 data[c(1, 2), ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 # 获取一，二两行第二列上的元素 data[1:2, 2] #&gt; [1] M F #&gt; Levels: F M data[c(1, 2), 2] #&gt; [1] M F #&gt; Levels: F M # 获取行1和2，名为“sex”和 &#39;size&#39;的列 data[1:2, c(&quot;sex&quot;, &quot;size&quot;)] #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 data[c(1, 2), c(2, 3)] #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 1.2.2.2 使用布尔向量进行索引 向量 v 同上。 v &gt; 2 #&gt; [1] FALSE TRUE TRUE TRUE FALSE FALSE TRUE v[v &gt; 2] #&gt; [1] 4 4 3 3 v[c(F, T, T, T, F, F, T)] #&gt; [1] 4 4 3 3 数据框同上。 # 一个布尔向量 data$subject &lt; 3 #&gt; [1] TRUE TRUE FALSE FALSE data[data$subject &lt; 3, ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 data[c(TRUE, TRUE, FALSE, FALSE), ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 # 也可以获取TRUE的数字索引 which(data$subject &lt; 3) #&gt; [1] 1 2 1.2.2.3 负索引 与其他某些编程语言不同，当您在 R 中使用负数进行索引时，并不意味着从后向前索引。相反，它意味着按照通常的从前往后顺序删除索引中的元素。 # 还是这个向量 v #&gt; [1] 1 4 4 3 2 2 3 # 删除第一个 v[-1] #&gt; [1] 4 4 3 2 2 3 # 删除前三个 v[-1:-3] #&gt; [1] 3 2 2 3 # 只删除最后一个 v[-length(v)] #&gt; [1] 1 4 4 3 2 2 1.3 获取数据结构的子集 1.3.1 问题 你想得到一个由向量、矩阵或数据框里元素组成的子集。 1.3.2 方案 为了基于一些条件准则获得子集，可以使用 subset() 函数或者是方括号索引。 两种方式均在下方举例说明。 v &lt;- c(1, 4, 4, 3, 2, 2, 3) subset(v, v &lt; 3) #&gt; [1] 1 2 2 v[v &lt; 3] #&gt; [1] 1 2 2 # 另一个向量 t &lt;- c(&quot;small&quot;, &quot;small&quot;, &quot;large&quot;, &quot;medium&quot;) # 删除 &#39;small&#39; 这一项 subset(t, t != &quot;small&quot;) #&gt; [1] &quot;large&quot; &quot;medium&quot; t[t != &quot;small&quot;] #&gt; [1] &quot;large&quot; &quot;medium&quot; 这两种方法之间的一个重要区别在于方括号索引可以为元素赋值，而 subset() 不可以。 v[v &lt; 3] &lt;- 9 subset(v, v &lt; 3) &lt;- 9 #&gt; Error in subset(v, v &lt; 3) &lt;- 9: 没有&quot;subset&lt;-&quot;这个函数 数据框： # 样本数据框 data &lt;- read.table(header = T, text = &quot; subject sex size 1 M 7 2 F 6 3 F 9 4 M 11 &quot;) subset(data, subject &lt; 3) #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 data[data$subject &lt; 3, ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 # 特定行和列的子集 subset(data, subject &lt; 3, select = -subject) #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 subset(data, subject &lt; 3, select = c(sex, size)) #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 subset(data, subject &lt; 3, select = sex:size) #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 data[data$subject &lt; 3, c(&quot;sex&quot;, &quot;size&quot;)] #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 # 逻辑与的两个条件 subset(data, subject &lt; 3 &amp; sex == &quot;M&quot;) #&gt; subject sex size #&gt; 1 1 M 7 data[data$subject &lt; 3 &amp; data$sex == &quot;M&quot;, ] #&gt; subject sex size #&gt; 1 1 M 7 # 逻辑或的两个条件 subset(data, subject &lt; 3 | sex == &quot;M&quot;) #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 #&gt; 4 4 M 11 data[data$subject &lt; 3 | data$sex == &quot;M&quot;, ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 #&gt; 4 4 M 11 # 基于转换数据的条件 subset(data, log2(size) &gt; 3) #&gt; subject sex size #&gt; 3 3 F 9 #&gt; 4 4 M 11 data[log2(data$size) &gt; 3, ] #&gt; subject sex size #&gt; 3 3 F 9 #&gt; 4 4 M 11 # 当元素在另一个向量里时的子集 subset(data, subject %in% c(1, 3)) #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 3 3 F 9 data[data$subject %in% c(1, 3), ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 3 3 F 9 1.4 创建填满值的向量 1.4.1 问题 你想创建一个填满值的列表。 1.4.2 方案 rep(1, 50) #&gt; [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #&gt; [26] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 rep(F, 20) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [9] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [17] FALSE FALSE FALSE FALSE rep(1:5, 4) #&gt; [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 rep(1:5, each = 4) #&gt; [1] 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 # 用在因子变量上 rep(factor(LETTERS[1:3]), 5) #&gt; [1] A B C A B C A B C A B C A B C #&gt; Levels: A B C 1.5 变量信息 1.5.1 问题 你想找到关于变量的信息。 1.5.2 方案 以下为关于样本变量的一些例子： x &lt;- 6 n &lt;- 1:4 let &lt;- LETTERS[1:4] df &lt;- data.frame(n, let) 1.5.2.1 关于存在的信息 # 列出当前所定义的变量 ls() #&gt; [1] &quot;contr&quot; &quot;data&quot; #&gt; [3] &quot;detachAllPackages&quot; &quot;df&quot; #&gt; [5] &quot;let&quot; &quot;n&quot; #&gt; [7] &quot;t&quot; &quot;tb&quot; #&gt; [9] &quot;v&quot; &quot;x&quot; # 检查名为“x”的变量是否存在 exists(&quot;x&quot;) #&gt; [1] TRUE # 检查名为“y”的变量是否存在 exists(&quot;y&quot;) #&gt; [1] FALSE # 删除变量“x” rm(x) x #&gt; Error in eval(expr, envir, enclos): 找不到对象&#39;x&#39; 1.5.2.2 关于大小/结构的信息 # 获得关于结构的信息 str(n) #&gt; int [1:4] 1 2 3 4 str(df) #&gt; &#39;data.frame&#39;: 4 obs. of 2 variables: #&gt; $ n : int 1 2 3 4 #&gt; $ let: Factor w/ 4 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;: 1 2 3 4 # 得到一个向量的长度 length(n) #&gt; [1] 4 # 可能会得不到我们想要的长度 length(df) #&gt; [1] 2 # 行数 nrow(df) #&gt; [1] 4 # 列数 ncol(df) #&gt; [1] 2 # 得到行数和列数 dim(df) #&gt; [1] 4 2 1.6 NULL、NA、NaN 的处理 1.6.1 问题 你想正确处理NULL、NA （Not Available）、NaN（Not a Number）。 1.6.2 方案 你的数据有时将会存在NULL、NA 、NaN。处理这些数据有些不同于「正常」值，并可能需要确定性测试。 以下是这些值相比较的例子： x &lt;- NULL x &gt; 5 #&gt; logical(0) y &lt;- NA y &gt; 5 #&gt; [1] NA z &lt;- NaN z &gt; 5 #&gt; [1] NA 如何测试某个变量是否是其中的一个值： is.null(x) #&gt; [1] TRUE is.na(y) #&gt; [1] TRUE is.nan(z) #&gt; [1] TRUE 注意，NULL 不同于其他两个。NULL 意味着没有值，而 NA 和 NaN 表示有值，尽管也许是不可用的。下面有一个例子区分： # y 是 null 吗？ is.null(y) #&gt; [1] FALSE # FALSE # x 是 NA 吗？ is.na(x) #&gt; logical(0) 第一个例子，检查 y 是否是 NULL ，结果 y 并不是；第二个例子，试图检查 x 是否是 NA，但并没有值被检测。 1.6.2.1 忽视向量汇总函数中的「坏」值 如果你对包含 NA 或 NaN 的向量使用诸如 mean() 或 sum() 之类的函数，结果将返回 NA 和 NaN，这通常没有任何意义，虽然这样的结果会提醒你有「坏」值的存在。许多函数都有 na.rm，可以将这些值忽略。 vy &lt;- c(1, 2, 3, NA, 5) mean(vy) #&gt; [1] NA mean(vy, na.rm = TRUE) #&gt; [1] 2.75 vz &lt;- c(1, 2, 3, NaN, 5) sum(vz) #&gt; [1] NaN sum(vz, na.rm = TRUE) #&gt; [1] 11 # NULL不是问题，因为它不存在 vx &lt;- c(1, 2, 3, NULL, 5) sum(vx) #&gt; [1] 11 1.6.2.2 从向量中移除「坏值」 使用 is.na() 或 is.nan() 的反向函数，可以将这些值移除。 vy #&gt; [1] 1 2 3 NA 5 vy[!is.na(vy)] #&gt; [1] 1 2 3 5 vz #&gt; [1] 1 2 3 NaN 5 vz[!is.nan(vz)] #&gt; [1] 1 2 3 5 1.6.2.3 注意 也有无限值 Inf 和 -Inf，及其相应的函数 is.finite() 和 is.infinite()。 "],
["section-2.html", "第 2 章 数字 2.1 生成随机数 2.2 生成可重复的随机序列 2.3 保持随机数生成器的状态 2.4 对数值取整 2.5 比较浮点数", " 第 2 章 数字 2.1 生成随机数 2.1.1 问题 你想要生成随机数。 2.1.2 方案 要生成均匀分布的随机数，可以使用 runif() 函数，它的默认范围是从 0 到 1。 runif(1) #&gt; [1] 0.246 # 得到 4 个数字的向量 runif(4) #&gt; [1] 0.1342 0.8996 0.6340 0.4691 # 得到 3 个范围在 0 到 100 的随机数向量 runif(3, min = 0, max = 100) #&gt; [1] 54.36 21.23 57.91 # 得到 3 个范围在 0 到 100 的整数 使用 max=101 # 因为它永远不可能等于 101，这里利用 floor # 函数实现向下取整数 floor(runif(3, min = 0, max = 101)) #&gt; [1] 46 22 28 # 以下方式得到的结果一样 sample(1:100, 3, replace = TRUE) #&gt; [1] 43 73 6 # 生成无重复的随机整数 sample(1:100, 3, replace = FALSE) #&gt; [1] 97 85 19 要生成服从正态分布的数字，使用 rnorm() 函数，该函数默认均值是 0，标准差是 1。 rnorm(4) #&gt; [1] -0.49078 -0.01156 1.64095 -0.45335 # 使用不同的均值和标准差 rnorm(4, mean = 50, sd = 10) #&gt; [1] 47.12 44.02 40.43 50.66 # 通过直方图检查分布是否正确 x &lt;- rnorm(400, mean = 50, sd = 10) hist(x) 2.1.3 注意 如果你想要生成随机数的结果可重复，参阅生成可重复的随机序列。 2.2 生成可重复的随机序列 2.2.1 问题 你想要生成可重复的随机数序列。 2.2.2 方案 使用 set.seed() 函数，并在括号内放入数字作为种子数。 set.seed(423) runif(3) #&gt; [1] 0.1090 0.5973 0.9726 set.seed(423) runif(3) #&gt; [1] 0.1090 0.5973 0.9726 2.3 保持随机数生成器的状态 2.3.1 问题 你想要保存和恢复随机数生成器的状态。 2.3.2 方案 将 .Random.seed 保存到其他变量，之后将变量值赋给 .Random.seed 从而恢复原来的值。 # 这个例子中，先设定随机数种子 set.seed(423) runif(3) #&gt; [1] 0.1090 0.5973 0.9726 # 保存种子 oldseed &lt;- .Random.seed runif(3) #&gt; [1] 0.7974 0.2278 0.5190 # 做其他随机数生成相关的事情，比如: runif(30) ... # 恢复种子 .Random.seed &lt;- oldseed # 保存种子之后，得到与之前相同的随机数 runif(3) #&gt; [1] 0.7974 0.2278 0.5190 如果你之前还没有在 R 线程中用过随机数生成器，变量 .Random.seed 将不会存在。如果你对此不确定，应当在保存和恢复之前进行检查： oldseed &lt;- NULL if (exists(&quot;.Random.seed&quot;)) oldseed &lt;- .Random.seed # 做一些随机数生成操作，比如： runif(30) ... if (!is.null(oldseed)) .Random.seed &lt;- oldseed 2.3.2.1 在函数中保存和恢复随机数生成器的状态 如果你试图在函数中通过使用 .Random.seed &lt;- x 来恢复随机数生成器的状态，结果是行不通的，因为这个操作改变的是名为 .Random.seed 的本地变量，而不是全局环境中的这个变量。 这里有两个例子。这些函数想要做的是生成一些随机数，并使得随机数生成器保留未改变的状态。 # 这是个坏的版本 bad_rand_restore &lt;- function() { if (exists(&quot;.Random.seed&quot;)) oldseed &lt;- .Random.seed else oldseed &lt;- NULL print(runif(3)) if (!is.null(oldseed)) .Random.seed &lt;- oldseed else rm(&quot;.Random.seed&quot;) } # 这是个好的版本 rand_restore &lt;- function() { if (exists(&quot;.Random.seed&quot;, .GlobalEnv)) oldseed &lt;- .GlobalEnv$.Random.seed else oldseed &lt;- NULL print(runif(3)) if (!is.null(oldseed)) .GlobalEnv$.Random.seed &lt;- oldseed else rm(&quot;.Random.seed&quot;, envir = .GlobalEnv) } # 坏的版本没有正确地重置随机数生成器状态，因此随机数一直在改变 set.seed(423) bad_rand_restore() #&gt; [1] 0.1090 0.5973 0.9726 bad_rand_restore() #&gt; [1] 0.7974 0.2278 0.5190 bad_rand_restore() #&gt; [1] 0.6929 0.8104 0.1019 # 好的版本每次都正确地重置了随机数生成器的状态，因此随机数可以保持一致 set.seed(423) rand_restore() #&gt; [1] 0.1090 0.5973 0.9726 rand_restore() #&gt; [1] 0.1090 0.5973 0.9726 rand_restore() #&gt; [1] 0.1090 0.5973 0.9726 2.3.2.2 注意 使用者最好不要修改 .Random.seed 变量。 2.4 对数值取整 2.4.1 问题 你想要对数值取整。 2.4.2 方案 存在许多种取整的方式：向最近的整数取整，向上或向下取整或者向 0 取整。 x &lt;- seq(-2.5, 2.5, by = 0.5) # 向最近的整数取整, 含有 .5 的值取整到最近一个偶数。 round(x) #&gt; [1] -2 -2 -2 -1 0 0 0 1 2 2 2 # 向上取整 ceiling(x) #&gt; [1] -2 -2 -1 -1 0 0 1 1 2 2 3 # 向下取整 floor(x) #&gt; [1] -3 -2 -2 -1 -1 0 0 1 1 2 2 # 向 0 取整 trunc(x) #&gt; [1] -2 -2 -1 -1 0 0 0 1 1 2 2 也可以近似到其它小数位： x &lt;- c(0.001, 0.07, 1.2, 44.02, 738, 9927) # 1 位小数近似 round(x, digits = 1) #&gt; [1] 0.0 0.1 1.2 44.0 738.0 9927.0 # 10 位取整 round(x, digits = -1) #&gt; [1] 0 0 0 40 740 9930 # 向最近的 5 的倍数近似 round(x/5) * 5 #&gt; [1] 0 0 0 45 740 9925 # 向最近的 .02 的倍数近似 round(x/0.02) * 0.02 #&gt; [1] 0.00 0.08 1.20 44.02 738.00 9927.00 2.5 比较浮点数 2.5.1 问题 浮点数比较结果通常未能如你所想。比如： 0.3 == 3 * 0.1 #&gt; [1] FALSE (0.1 + 0.1 + 0.1) - 0.3 #&gt; [1] 5.551e-17 x &lt;- seq(0, 1, by = 0.1) x #&gt; [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 10 * x - round(10 * x) #&gt; [1] 0.000e+00 0.000e+00 0.000e+00 4.441e-16 0.000e+00 #&gt; [6] 0.000e+00 8.882e-16 8.882e-16 0.000e+00 0.000e+00 #&gt; [11] 0.000e+00 2.5.2 方案 不存在通用的解决方案，因为这个问题通常是由于非整数（浮点数）在计算机和 R 中的存储方式所导致的。可以通过网址 http://www.mathworks.com/support/tech-notes/1100/1108.html 查阅更多信息。虽然里面使用 Matlab 代码写的，但是基本与 R 一致。 "],
["section-3.html", "第 3 章 字符串 3.1 使用 grep、sub、gsub 进行搜索和替换 3.2 通过变量创建字符串", " 第 3 章 字符串 3.1 使用 grep、sub、gsub 进行搜索和替换 3.1.1 问题 你想要搜索或替换字符串中特定的文本。 3.1.2 方案 两个常用字符串搜索函数 grep() 和 grepl()。两个常用字符串替换函数 sub() 和 gsub()。它们都是向量化操作，会应用到输入字符向量的每一个元素中。 3.1.2.1 文本搜索 grep() 和 grepl() 函数输入的第一个参数都是带有正则表达式的字符串或者固定的字符串（需要设定选项 fixed=TRUE ），它们的不同之处是前者返回匹配的索引或值向量，而后者返回一个逻辑向量。 下面通过简单的例子理解它们的用法和区别：从小写字母向量中搜索 c。 grep(&quot;c&quot;, letters) #&gt; [1] 3 grepl(&quot;c&quot;, letters) #&gt; [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE #&gt; [9] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [17] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [25] FALSE FALSE grep() 函数设定选项 value=TRUE 可以返回匹配的值。 grep(&quot;c&quot;, letters, value = TRUE) grep(&quot;c&quot;, c(&quot;dog&quot;, &quot;cat&quot;), value = TRUE) 正则表达式提供了一种表达字符模式的强大方式（详情查看 ?regex），我们可以将它应用于文本的搜索中。例如，我们想搜索字符向量中有4个数字连续出现的字符： grep(&quot;\\\\d{4}&quot;, c(&quot;This will not match&quot;, &quot;2018-04-11, This will match&quot;)) #&gt; [1] 2 3.1.2.2 文本替换 大部分情况下我们不仅仅想搜索到文本，而且还想要在搜索的基础上进行替换，这可以通过 sub() 和 gsub() 函数实现。这两个函数参数是一样的，第一个参数是搜索模式，第二个参数是替换模式，第三个参数是要操作的字符向量。两个函数的区别是前者只会替换字符串中第一个匹配的模式，而 gsub()（ g 是 global 的缩写）会替换字符串中所有匹配模式。 例如，我们想要将字符向量中的年份全部替换为 2019。 sub(pattern = &quot;\\\\d{4}&quot;, replacement = &quot;2019&quot;, x = c(&quot;This will not match&quot;, &quot;2018-04-11, 2017-04-11&quot;, &quot;2018-04-12&quot;)) #&gt; [1] &quot;This will not match&quot; &quot;2019-04-11, 2017-04-11&quot; #&gt; [3] &quot;2019-04-12&quot; gsub(pattern = &quot;\\\\d{4}&quot;, replacement = &quot;2019&quot;, x = c(&quot;This will not match&quot;, &quot;2018-04-11, 2017-04-11&quot;, &quot;2018-04-12&quot;)) #&gt; [1] &quot;This will not match&quot; &quot;2019-04-11, 2019-04-11&quot; #&gt; [3] &quot;2019-04-12&quot; 要操作的对象第二个元素包含2个可以匹配的模式，使用 sub() 只会将第一个替换为 2019，而使用 gsub() 会将所有能够匹配的模式都替换为 2019。 3.2 通过变量创建字符串 3.2.1 问题 你想要通过变量创建一个字符串。 3.2.2 方案 两种从变量创建字符串的通用方法是使用 paste() 和 sprintf() 函数。对向量来说，paste 更加有用；sprintf 则常用于对输出实现精确的控制。 3.2.2.1 使用 paste() a &lt;- &quot;apple&quot; b &lt;- &quot;banana&quot; # 将a、b变量内容连到一起，并用空格隔开 paste(a, b) #&gt; [1] &quot;apple banana&quot; # 如果不想要空格，可以设定参数 sep=&#39;&#39;, 或使用函数 # paste0(): paste(a, b, sep = &quot;&quot;) #&gt; [1] &quot;applebanana&quot; paste0(a, b) #&gt; [1] &quot;applebanana&quot; # 用逗号加空格分开: paste(a, b, sep = &quot;, &quot;) #&gt; [1] &quot;apple, banana&quot; # 设定一个字符向量 d &lt;- c(&quot;fig&quot;, &quot;grapefruit&quot;, &quot;honeydew&quot;) # 如果输入是一个向量，输出会将其每个元素堆叠到一起： paste(d, collapse = &quot;, &quot;) #&gt; [1] &quot;fig, grapefruit, honeydew&quot; # 如果输入是一个标量和一个向量， # 结果会将标量与向量里每个元素放到一起 # 并返回一个向量（译者注：R向量化操作的循环对齐原则）： paste(a, d) #&gt; [1] &quot;apple fig&quot; &quot;apple grapefruit&quot; #&gt; [3] &quot;apple honeydew&quot; # 使用 sep 和 collapse 参数: paste(a, d, sep = &quot;-&quot;, collapse = &quot;, &quot;) #&gt; [1] &quot;apple-fig, apple-grapefruit, apple-honeydew&quot; 3.2.2.2 使用 sprintf() 另一种方式是使用 sprintf 函数，它来自于 C 语言。 想要在字符串或字符变量中进行取代操作，使用 %s： a &lt;- &quot;string&quot; sprintf(&quot;This is where a %s goes.&quot;, a) #&gt; [1] &quot;This is where a string goes.&quot; 如果是整数，可以使用 %d 或它的变体： x &lt;- 8 sprintf(&quot;Regular:%d&quot;, x) #&gt; [1] &quot;Regular:8&quot; # 可以以空格开头，替代一定数量字符。 sprintf(&quot;Leading spaces:%4d&quot;, x) #&gt; [1] &quot;Leading spaces: 8&quot; # 也可以使用 0 替代一定数量字符。 sprintf(&quot;Leading zeros:%04d&quot;, x) #&gt; [1] &quot;Leading zeros:0008&quot; 对浮点数而言，使用 %f 进行标准释义，而 %e 或者 %E 则代表指数。你也可以使用 %g 或者 %G 让程序自动根据有效位数进行两种格式的转换。下面是 R help 页面中关于 sprintf 的例子： sprintf(&quot;%f&quot;, pi) # &quot;3.141593&quot; sprintf(&quot;%.3f&quot;, pi) # &quot;3.142&quot; sprintf(&quot;%1.0f&quot;, pi) # &quot;3&quot; sprintf(&quot;%5.1f&quot;, pi) # &quot; 3.1&quot; sprintf(&quot;%05.1f&quot;, pi) # &quot;003.1&quot; sprintf(&quot;%+f&quot;, pi) # &quot;+3.141593&quot; sprintf(&quot;% f&quot;, pi) # &quot; 3.141593&quot; sprintf(&quot;%-10f&quot;, pi) # &quot;3.141593 &quot; (左对齐) sprintf(&quot;%e&quot;, pi) # &quot;3.141593e+00&quot; sprintf(&quot;%E&quot;, pi) # &quot;3.141593E+00&quot; sprintf(&quot;%g&quot;, pi) # &quot;3.14159&quot; sprintf(&quot;%g&quot;, 1e6 * pi) # &quot;3.14159e+06&quot; (指数化) sprintf(&quot;%.9g&quot;, 1e6 * pi) # &quot;3141592.65&quot; (固定) sprintf(&quot;%G&quot;, 1e-6 * pi) # &quot;3.14159E-06&quot; 在 %m.nf 格式规范中：m 代表域宽，它是输出字符串中字符的最小位数，可以以空格或 0 开头。n 代表精度，它指小数点后的数字位数。 其他混合操作： x &lt;- &quot;string&quot; sprintf(&quot;Substitute in multiple strings: %s %s&quot;, x, &quot;string2&quot;) #&gt; [1] &quot;Substitute in multiple strings: string string2&quot; # 想要打印百分号，可以使用 &#39;%%&#39; sprintf(&quot;A single percent sign here %%&quot;) #&gt; [1] &quot;A single percent sign here %&quot; 3.2.2.3 注意 关于更多脚本输出的信息可以查看用 R 写入文本，分析输出到文件。 "],
["section-4.html", "第 4 章 公式 4.1 通过字符串创建公式 4.2 从公式中提取组分", " 第 4 章 公式 4.1 通过字符串创建公式 4.1.1 问题 你想通过字符串创建公式。 4.1.2 方案 通过字符串的方式来创建公式是非常有用的。这通常用于需要将公式参数当做字符串传入函数中。 最基础实用的方法就是调用函数 as.formula(): # 这将返回一个字符串 &quot;y ~ x1 + x2&quot; #&gt; [1] &quot;y ~ x1 + x2&quot; # 这将返回一个公式 as.formula(&quot;y ~ x1 + x2&quot;) #&gt; y ~ x1 + x2 下面是一个简单实例： # 存在一些变量名: measurevar &lt;- &quot;y&quot; groupvars &lt;- c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;) # 创建合适的字符串: paste(measurevar, paste(groupvars, collapse = &quot; + &quot;), sep = &quot; ~ &quot;) #&gt; [1] &quot;y ~ x1 + x2 + x3&quot; # 返回公式: as.formula(paste(measurevar, paste(groupvars, collapse = &quot; + &quot;), sep = &quot; ~ &quot;)) #&gt; y ~ x1 + x2 + x3 4.2 从公式中提取组分 4.2.1 问题 你想抽离公式的一部分用来使用。 4.2.2 方案 你可以把公式对象当作列表看待，使用 [[ 操作符对其组分进行操作。 f &lt;- y ~ x1 + x2 # 观察f结构 str(f) #&gt; Class &#39;formula&#39; language y ~ x1 + x2 #&gt; ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; # 获得每一部分 f[[1]] #&gt; `~` f[[2]] #&gt; y f[[3]] #&gt; x1 + x2 # 转换为列表观察 as.list(f) #&gt; [[1]] #&gt; `~` #&gt; #&gt; [[2]] #&gt; y #&gt; #&gt; [[3]] #&gt; x1 + x2 如果公式左边没有任何东西，那么列表只有两个元素： f2 &lt;- ~x1 + x2 as.list(f2) #&gt; [[1]] #&gt; `~` #&gt; #&gt; [[2]] #&gt; x1 + x2 公式的每一个元素都是一个符号或者语言对象（包含多个符号）： str(f[[1]]) #&gt; symbol ~ str(f[[2]]) #&gt; symbol y str(f[[3]]) #&gt; language x1 + x2 # 查看语言对象某部分 str(f[[3]][[1]]) #&gt; symbol + str(f[[3]][[2]]) #&gt; symbol x1 str(f[[3]][[3]]) #&gt; symbol x2 你可以使用 as.character() 或 deparse() 函数将它们转为字符串。 deparse() 函数可以返回一个看起来更为自然的结果： as.character(f[[1]]) #&gt; [1] &quot;~&quot; # &gt; [1] &#39;~&#39; as.character(f[[2]]) #&gt; [1] &quot;y&quot; # &gt; [1] &#39;y&#39; # 这里语言对象被强制转换为代表解析树的字符向量 as.character(f[[3]]) #&gt; [1] &quot;+&quot; &quot;x1&quot; &quot;x2&quot; # &gt; [1] &#39;+&#39; &#39;x1&#39; &#39;x2&#39; # 使用 deparse() 获取更为自然的结果 deparse(f[[3]]) #&gt; [1] &quot;x1 + x2&quot; deparse(f) #&gt; [1] &quot;y ~ x1 + x2&quot; 正如我们在运行 str(f) 命令时看到的那样，公式对象也会捕捉调用它的环境。如果要抽取它，可以使用 environment() 函数： environment(f) #&gt; &lt;environment: R_GlobalEnv&gt; "],
["section-5.html", "第 5 章 数据的导入与导出 5.1 R载入文件中的数据 5.2 通过键盘和剪贴板把数据载入并保存到 R 5.3 运行 R 脚本 5.4 用 R 把数据写入文件 5.5 用 R 写入文本，分析输出到文件", " 第 5 章 数据的导入与导出 5.1 R载入文件中的数据 5.1.1 问题 你想从文件中载入数据。 5.1.2 方案 5.1.2.1 带分隔符的文本文件 最简单的输入数据的方式就是将其保存为带分隔符（如：制表位或逗号）的文本文件。 data &lt;- read.csv(&quot;datafile.csv&quot;) # 导入一个没有表头的 CSV 文件 data &lt;- read.csv(&quot;datafile-noheader.csv&quot;, header=FALSE) 函数 read.table() 是一个更为常用的函数。它允许你设置分隔符，不管该文件是否有表头或者字符串是否有引号，等等。使用 ?read.table 查看更多详细信息。 data &lt;- read.table(&quot;datafile-noheader.csv&quot;, header=FALSE, sep=&quot;,&quot; # 制表位分隔的文件用 &quot;\\t&quot; ) 5.1.2.2 打开文件的文件选择器 有些平台可以使用 file.choose() 命令打开文件选择的对话窗口；而另一些平台则只会提示用户输入一个文件名。 data &lt;- read.csv(file.choose()) 5.1.2.3 把字符串看作因子（factor）或字符（character） 默认条件下，数据中的字符串都被转换为因子。如果你用 read.csv() 载入数据，所有的文本列都会被视为因子，而实际上某些文本列被处理为字符串才更为合理。要实现这一点，可以设定 stringsAsFactors=FALSE: data &lt;- read.csv(&quot;datafile.csv&quot;, stringsAsFactors=FALSE) # 将某一列转化为因子 data$Sex &lt;- factor(data$Sex) 另一种将全部文本列加载为因子，再把其中一些转换为字符的方法： data &lt;- read.csv(&quot;datafile.csv&quot;) data$First &lt;- as.character(data$First) data$Last &lt;- as.character(data$Last) # 另一种方法：转化名为 “First” 和 “Last” 的两列 stringcols &lt;- c(&quot;First&quot;,&quot;Last&quot;) data[stringcols] &lt;- lapply(data[stringcols], as.character) 5.1.2.4 从网上导入文件 也可以从 URL 加载数据。下面这些(很长的) URL 可以描述了将要加载的相关文件。 data &lt;- read.csv(&quot;http://www.cookbook-r.com/Data_input_and_output/Loading_data_from_a_file/datafile.csv&quot;) # 读取没有表头的 CSV 文件 data &lt;- read.csv(&quot;http://www.cookbook-r.com/Data_input_and_output/Loading_data_from_a_file/datafile-noheader.csv&quot;, header = FALSE) # 手动添加表头 names(data) &lt;- c(&quot;First&quot;, &quot;Last&quot;, &quot;Sex&quot;, &quot;Number&quot;) 上述所使用的数据文件及内容： datafile.csv： &quot;First&quot;,&quot;Last&quot;,&quot;Sex&quot;,&quot;Number&quot; &quot;Currer&quot;,&quot;Bell&quot;,&quot;F&quot;,2 &quot;Dr.&quot;,&quot;Seuss&quot;,&quot;M&quot;,49 &quot;&quot;,&quot;Student&quot;,NA,21 datafile-noheader.csv: &quot;Currer&quot;,&quot;Bell&quot;,&quot;F&quot;,2 &quot;Dr.&quot;,&quot;Seuss&quot;,&quot;M&quot;,49 &quot;&quot;,&quot;Student&quot;,NA,21 5.1.2.5 定宽文本文件 假如你的数据列宽固定，如下： First Last Sex Number Currer Bell F 2 Dr. Seuss M 49 &quot;&quot; Student NA 21 读取这种数据的一种方式是简单地使用 read.table() 函数 strip.white=TRUE，可以清除额外的空格。 read.table(&quot;clipboard&quot;, header=TRUE, strip.white=TRUE) 然而，数据文件里的某些列可能含有空格，也可能不包含空格。比如说下面的数据里，scores 列表示六个不同的测量值，每一个从 0 到 3 。 subject sex scores N 1 M 113311 NE 2 F 112231 S 3 F 111221 W 4 M 011002 这种情况，你可能需要使用 read.fwf() 函数。如果你读的列名来自于文件，按照要求它们需要用分隔符（如：制表位，空格，逗号）分开。如果它们之间是通过多个空格来隔开的（如下例），你需要直接指定列的名称。 # 指定列的名称 read.fwf(&quot;myfile.txt&quot;, c(7,5,-2,1,1,1,1,1,1), # 列的宽度，-2意味着放弃这些列 skip=1, # 跳过第一行（包括表头） col.names=c(&quot;subject&quot;,&quot;sex&quot;,&quot;s1&quot;,&quot;s2&quot;,&quot;s3&quot;,&quot;s4&quot;,&quot;s5&quot;,&quot;s6&quot;), strip.white=TRUE) # 跳过每个数据的前导和尾随空格 #&gt; subject sex s1 s2 s3 s4 s5 s6 #&gt; 1 N 1 M 1 1 3 3 1 1 #&gt; 2 NE 2 F 1 1 2 2 3 1 #&gt; 3 S 3 F 1 1 1 2 2 1 #&gt; 4 W 4 M 0 1 1 0 0 2 # subject sex s1 s2 s3 s4 s5 s6 # N 1 M 1 1 3 3 1 1 # NE 2 F 1 1 2 2 3 1 # S 3 F 1 1 1 2 2 1 # W 4 M 0 1 1 0 0 2 # 如果第一行如下： # subject,sex,scores # 我们可以使用 header=TRUE read.fwf(&quot;myfile.txt&quot;, c(7,5,-2,1,1,1,1,1,1), header=TRUE, strip.white=TRUE) #&gt; Error in read.table(file = FILE, header = header, sep = sep, row.names = row.names, : more columns than column names # 错误：列数比列名数量多 5.1.2.6 Excel 文件 gdata 包里的 read.xls() 函数可以读取 Excel 文件。 library(gdata) data &lt;- read.xls(&quot;data.xls&quot;) gdata 包使用说明见 http://cran.r-project.org/doc/manuals/R-data.html#Reading-Excel-spreadsheets。 包的安装，见安装和使用R包。 5.1.2.7 SPSS 数据 foreign 包里的 read.spss() 函数可以读取 SPSS 文件。 library(foreign) data &lt;- read.spss(&quot;data.sav&quot;, to.data.frame=TRUE) 5.2 通过键盘和剪贴板把数据载入并保存到 R 5.2.1 问题 你想用键盘输入数据，而不是从文件中载入。 5.2.2 方案 5.2.2.1 数据输入 假如你的数据如下： size weight cost small 5 6 medium 8 10 large 11 9 5.2.2.1.1 通过键盘输入或从剪贴板载入数据 从键盘上输入的方法之一是从标准输入读取（ stdin() ）。 # 使用 read.table 和 stdin() 剪切和粘贴 data &lt;- read.table(stdin(), header=TRUE) # 系统将提示您输入:在这复制和粘贴文本 # 或者： # data &lt;- read.csv(stdin()) 你也可以直接从剪贴板载入： # 首先将数据复制到剪贴板 data &lt;- read.table(&#39;clipboard&#39;, header=TRUE) # 或者： # data &lt;- read.csv(&#39;clipboard&#39;) 5.2.2.1.2 在脚本中载入数据 前面的方法不能用来加载脚本文件中的数据，因为输入（通过键入或粘贴)必须发生在运行该命令之后。 # 使用 read.table() data &lt;- read.table(header = TRUE, text = &quot; size weight cost small 5 6 medium 8 10 large 11 9 &quot;) 不同的数据格式(如：以逗号分隔，没有表头，等等)，选择 read.table() 可以设置。 阅读R载入文件中的数据查看更多信息。 5.2.2.2 数据输出 默认情况下，R 会打印行名称。当你希望打印出来的表格可以被复制粘贴，那么最好将这一设定关闭。 print(data, row.names = FALSE) #&gt; size weight cost #&gt; small 5 6 #&gt; medium 8 10 #&gt; large 11 9 5.2.2.2.1 写入可以复制粘贴或粘贴到剪贴板的数据 可以将带分隔符的数据写入终端（ stdout() ），这样它就可以被复制粘贴到其他地方，也可以直接写入到剪贴板。 write.csv(data, stdout(), row.names=FALSE) # &quot;size&quot;,&quot;weight&quot;,&quot;cost&quot; # &quot;small&quot;,5,6 # &quot;medium&quot;,8,10 # &quot;large&quot;,11,9 # 写到剪贴板(不支持 Mac 或 Unix) write.csv(data, &#39;clipboard&#39;, row.names=FALSE) 5.2.2.2.2 输出 R 中的载入数据 如果数据已经加载到 R，可以使用 dput() 保存数据。通过 dput() 得到的输出是一个命令，可以重建数据结构。这种方法的优点是，它可以保持各种数据类型的修改。举个例子，如果有一列包含各种数字的数据，并且你已经将这一列转化成了因子。这种方法将会在保留该数据类型的同时，只加载文本表格（如上所示）并将把它处理为数字。 # 假如你已经载入数据 dput(data) #&gt; structure(list(size = structure(c(3L, 2L, 1L), .Label = c(&quot;large&quot;, #&gt; &quot;medium&quot;, &quot;small&quot;), class = &quot;factor&quot;), weight = c(5L, 8L, 11L #&gt; ), cost = c(6L, 10L, 9L)), .Names = c(&quot;size&quot;, &quot;weight&quot;, &quot;cost&quot; #&gt; ), class = &quot;data.frame&quot;, row.names = c(NA, -3L)) # 之后，我们可以使用 dput 中输出，重新创建数据结构 newdata &lt;- structure(list(size = structure(c(3L, 2L, 1L), .Label = c(&quot;large&quot;, &quot;medium&quot;, &quot;small&quot;), class = &quot;factor&quot;), weight = c(5L, 8L, 11L ), cost = c(6L, 10L, 9L)), .Names = c(&quot;size&quot;, &quot;weight&quot;, &quot;cost&quot; ), class = &quot;data.frame&quot;, row.names = c(NA, -3L)) 5.3 运行 R 脚本 5.3.1 问题 你想从文本文件运行 R 代码 5.3.2 方案 使用 source() 函数。 # 首先，找到正确的目录 setwd(&#39;/home/username/desktop/rcode&#39;) source(&#39;analyze.r&#39;) 请注意，如果你想让你的脚本生成文本输出，你必须使用 print() 或 cat() 函数。 x &lt;- 1:10 # 这在脚本中，不会启动任何命令 x #&gt; [1] 1 2 3 4 5 6 7 8 9 10 # 使用print()函数: print(x) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 # 更简单的输出: 没有行/列，没有文本 cat(x) #&gt; 1 2 3 4 5 6 7 8 9 10 另一种代替方法是：运行 source() 并加上 print.eval=TRUE 选项。 5.4 用 R 把数据写入文件 5.4.1 问题 你想把数据写入一个文件。 5.4.2 方案 5.4.2.1 写到有分隔符的文本文件 最简单的方式是用 write.csv() 。默认情况下，write.csv() 包含行名，但是这通常没必要，而且可能会导致混乱。 # 一个简单的例子 data &lt;- read.table(header = TRUE, text = &quot; subject sex size 1 M 7 2 F NA 3 F 9 4 M 11 &quot;) # 写入到文件，不显示行名 write.csv(data, &quot;data.csv&quot;, row.names = FALSE) # 替代 “NA”，输出空格 write.csv(data, &quot;data.csv&quot;, row.names = FALSE, na = &quot;&quot;) # 用制表符可以不显示行和列名 write.table(data, &quot;data.csv&quot;, sep = &quot;\\t&quot;, row.names = FALSE, col.names = FALSE) 5.4.2.2 以 R 的数据格式保存 write.csv() 和 write.table() 是最适合与其他数据分析程序交互操作的函数。然而，他们不会保持数据结构中的特殊属性，如：该列是否为一个字符类型或因子，或因子的水平的顺序。为了实现这一点，我们应该将该数据写成适合 R 的特殊格式。 下面是三种主要的方法： 第一个方法是输出 R 源代码，代码运行时，该对象将被重新创建。这种方法应该适用于大部分数据对象，但它可能无法专一地重构一些较为复杂的数据对象。 # 保存在一个能容易被 R 载入的文本文件中 dump(&quot;data&quot;, &quot;data.Rdmpd&quot;) # 可以同时保存多个对象 dump(c(&quot;data&quot;, &quot;data1&quot;), &quot;data.Rdmpd&quot;) # 再次加载数据 source(&quot;data.Rdmpd&quot;) # 载入时，原始的数据名称将被自动使用 另一个方法是，在 RDS 格式中写入单个数据对象。这种格式可以是二进制或 ASCII。二进制更紧凑，而 ASCII 在配合版本控制系统（如 Git）方面则更有效率。 # 在二进制 RDS 格式中保存一个简单的对象 saveRDS(data, &quot;data.rds&quot;) # 或者使用 ASCII 格式 saveRDS(data, &quot;data.rds&quot;, ascii=TRUE) # 再次载入: data &lt;- readRDS(&quot;data.rds&quot;) 也可以将多个对象以 RData 格式保存到一个单一的文件。 # 在二进制 RData 格式中保存多个对象 save(data, file=&quot;data.RData&quot;) # 或者使用 ASCII 格式 save(data, file=&quot;data.RData&quot;, ascii=TRUE) # 可以保存多个对象 save(data, data1, file=&quot;data.RData&quot;) # 再次载入: load(&quot;data.RData&quot;) saveRDS() 和 save() 的一个重要区别：对于前者，当你用 readRDS() 读取数据时，是你指定对象的名称；而对于后者，当你用 load() 载入数据，R 会自动使用该数据原来的对象名称。自动使用原始对象名称有时可以简化工作流程，但这种在不同的环境中都使用相同数据对象名称的设定也会成为一个缺点。 5.5 用 R 写入文本，分析输出到文件 5.5.1 问题 如果你想将输出信息写到文件。 5.5.2 方案 sink() 函数将会重定向输出到一个文件，而不是 R 的终端。请注意，如果您在脚本中使用sink()，并且在结果输出到终端前崩溃，那么你将不会看到任何对你命令的响应。在不带任何参数的情况下调用 sink() ，将返回输出到终端。 # 开始写入到文件 sink(&#39;analysis-output.txt&#39;) set.seed(12345) x &lt;-rnorm(10,10,1) y &lt;-rnorm(10,11,1) # 添加一些内容 cat(sprintf(&quot;x has %d elements:\\n&quot;, length(x))) print(x) cat(&quot;y =&quot;, y, &quot;\\n&quot;) cat(&quot;=============================\\n&quot;) cat(&quot;T-test between x and y\\n&quot;) cat(&quot;=============================\\n&quot;) t.test(x,y) # 停止写入 sink() # 附加到文件 sink(&#39;analysis-output.txt&#39;, append=TRUE) cat(&quot;Some more stuff here...\\n&quot;) sink() 输出文件的内容： x has 10 elements: [1] 10.585529 10.709466 9.890697 9.546503 10.605887 8.182044 10.630099 9.723816 [9] 9.715840 9.080678 y = 10.88375 12.81731 11.37063 11.52022 10.24947 11.8169 10.11364 10.66842 12.12071 11.29872 ============================= T-test between x and y ============================= Welch Two Sample t-test data: x and y t = -3.8326, df = 17.979, p-value = 0.001222 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -2.196802 -0.641042 sample estimates: mean of x mean of y 9.867056 11.285978 Some more stuff here... "],
["section-6.html", "第 6 章 数据操作 6.1 排序 6.2 随机排序 6.3 转换向量类型 6.4 查找并移除重复记录 6.5 NA 存在时进行向量或因子比较 6.6 数据重新编码 6.7 映射向量值 6.8 重命名因子水平 6.9 重计算因子水平 6.10 改变因子水平次序 6.11 重命名数据框的列 6.12 添加和移除数据框的列 6.13 对数据框的列重新排序 6.14 合并数据框 6.15 比较数据框 6.16 重计算数据框所有因子列的水平 6.17 长宽格式数据互换 6.18 汇总数据 6.19 数据框与列联表互换 6.20 计算移动平均数 6.21 窗口平滑 6.22 寻找唯一值序列 6.23 用最后一个非 NA 值填充 NA", " 第 6 章 数据操作 6.1 排序 6.1.1 问题 你想将一个向量，矩阵或列表排序。 6.1.2 方案 6.1.2.1 向量 # 生成一个随机向量 v &lt;- sample(101:110) # 排序 sort(v) #&gt; [1] 101 102 103 104 105 106 107 108 109 110 # 反向排序 sort(v, decreasing = TRUE) #&gt; [1] 110 109 108 107 106 105 104 103 102 101 6.1.2.2 列表 对列表的一个或多个列进行排序，可以使用 plyr 包里的 arrange() 函数或者使用 R 的内置函数。arrange() 函数更容易使用，但需要额外安装包。 # 生成一个列表 df &lt;- data.frame(id = 1:4, weight = c(20, 27, 24, 22), size = c(&quot;small&quot;, &quot;large&quot;, &quot;medium&quot;, &quot;large&quot;)) df #&gt; id weight size #&gt; 1 1 20 small #&gt; 2 2 27 large #&gt; 3 3 24 medium #&gt; 4 4 22 large library(plyr) # 按照 &#39;weight&#39; 列排序，以下结果相同。 arrange(df, weight) # 使用 plyr 包里的 arrange 函数 #&gt; id weight size #&gt; 1 1 20 small #&gt; 2 4 22 large #&gt; 3 3 24 medium #&gt; 4 2 27 large df[order(df$weight), ] # 使用 R 内置函数 #&gt; id weight size #&gt; 1 1 20 small #&gt; 4 4 22 large #&gt; 3 3 24 medium #&gt; 2 2 27 large # 以 size 为第一关键词, weight 为第二关键词排序 arrange(df, size, weight) # 使用 plyr 包里的 arrange 函数 #&gt; id weight size #&gt; 1 4 22 large #&gt; 2 2 27 large #&gt; 3 3 24 medium #&gt; 4 1 20 small df[order(df$size, df$weight), ] # 使用 R 内置函数 #&gt; id weight size #&gt; 4 4 22 large #&gt; 2 2 27 large #&gt; 3 3 24 medium #&gt; 1 1 20 small # 所有列从左到右依次排序 df[do.call(order, as.list(df)), ] #&gt; id weight size #&gt; 1 1 20 small #&gt; 2 2 27 large #&gt; 3 3 24 medium #&gt; 4 4 22 large # 在这个特殊的例子中，顺序将保持不变 请注意，size 列是一个因子且按照因子水平进行排序。在这种情况下将自动按字母顺序排列（创建数据表格），所以大是第一而小是最后。 6.1.2.2.1 反向排序 设定 decreasing=TRUE 可以获取反向排序结果。 反向排序某一列的方法依赖于数据类型： 数字：变量名前加一个-。例如：df[order(-df$weight)] 因子：转换为整数，变量名前加一个-。例如：df[order(-xtfrm(df$size)), ] 字符：没有简单的方法能做到这一点。一种方法是先转换为一个因子，然后如上所述。 # 反向排序 weight 列，下面方法有相同结果： arrange(df, -weight) # 使用 plyr 包里的 arrange 函数 #&gt; id weight size #&gt; 1 2 27 large #&gt; 2 3 24 medium #&gt; 3 4 22 large #&gt; 4 1 20 small df[order(df$weight, decreasing = TRUE), ] # 使用 R 内置函数 #&gt; id weight size #&gt; 2 2 27 large #&gt; 3 3 24 medium #&gt; 4 4 22 large #&gt; 1 1 20 small df[order(-df$weight), ] # 使用 R 内置函数 #&gt; id weight size #&gt; 2 2 27 large #&gt; 3 3 24 medium #&gt; 4 4 22 large #&gt; 1 1 20 small # 升序排列 size ,然后降序排列 weight arrange(df, size, -weight) # 使用 plyr 包里的 arrange 函数 #&gt; id weight size #&gt; 1 2 27 large #&gt; 2 4 22 large #&gt; 3 3 24 medium #&gt; 4 1 20 small df[order(df$size, -df$weight), ] # 使用 R 内置函数 #&gt; id weight size #&gt; 2 2 27 large #&gt; 4 4 22 large #&gt; 3 3 24 medium #&gt; 1 1 20 small # 升序排列 size,然后降序排列 weight 因子需要 xtfrm() arrange(df, -xtfrm(size), weight) # 使用 plyr 包里的 arrange 函数 #&gt; id weight size #&gt; 1 1 20 small #&gt; 2 3 24 medium #&gt; 3 4 22 large #&gt; 4 2 27 large df[order(-xtfrm(df$size), df$weight), ] # 使用 R 内置函数 #&gt; id weight size #&gt; 1 1 20 small #&gt; 3 3 24 medium #&gt; 4 4 22 large #&gt; 2 2 27 large 6.2 随机排序 6.2.1 问题 你想使一个数据结构随机排序。 6.2.2 方案 # 创建一个向量 v &lt;- 11:20 # 随机化向量的顺序 v &lt;- sample(v) # 创建一个列表 data &lt;- data.frame(label = letters[1:5], number = 11:15) data #&gt; label number #&gt; 1 a 11 #&gt; 2 b 12 #&gt; 3 c 13 #&gt; 4 d 14 #&gt; 5 e 15 # 随机化列表的顺序 data &lt;- data[sample(1:nrow(data)), ] data #&gt; label number #&gt; 5 e 15 #&gt; 4 d 14 #&gt; 3 c 13 #&gt; 2 b 12 #&gt; 1 a 11 6.2.2.1 注意 为了使随机化可重复，你应该设置随机数生成器。详见：生成随机数、生成可重复的随机数序列。 6.3 转换向量类型 6.3.1 问题 你想在数值向量、字符串向量和因子向量间做转换。 6.3.2 方案 假设你刚开始有一个数值型向量 n: n &lt;- 10:14 n #&gt; [1] 10 11 12 13 14 将这个数值型向量转换为其他两种类型（将结果保存在 c 和 f ）： # 数值型转换字符串 c &lt;- as.character(n) c #&gt; [1] &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; # 数值型转换因子型 f &lt;- factor(n) f #&gt; [1] 10 11 12 13 14 #&gt; Levels: 10 11 12 13 14 将字符串向量转化为另外两种： # 数值 as.numeric(c) #&gt; [1] 10 11 12 13 14 # 字符串转换为因子 factor(c) #&gt; [1] 10 11 12 13 14 #&gt; Levels: 10 11 12 13 14 把一个因子转变为一个字符串型向量很简单： # 因子转换为字符串 as.character(f) #&gt; [1] &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; 然而，将因子转化为数值型向量有点棘手。如果你使用as.numberic，它将会给你因子编码的数值，恐怕不是你想要的。 as.numeric(f) #&gt; [1] 1 2 3 4 5 # 另一种方式得到数字的编码，如果这是你想要的: unclass(f) #&gt; [1] 1 2 3 4 5 #&gt; attr(,&quot;levels&quot;) #&gt; [1] &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; 将因子转换为数值型的方法是先转化为字符串型，再转化为数值型。 # 因子转换为数值型 as.numeric(as.character(f)) #&gt; [1] 10 11 12 13 14 6.4 查找并移除重复记录 6.4.1 问题 你想查找和（或）移除向量或列表里重复的条目。 6.4.2 方案 6.4.2.1 向量 # 生成一个向量 set.seed(158) x &lt;- round(rnorm(20, 10, 5)) x #&gt; [1] 14 11 8 4 12 5 10 10 3 3 11 6 0 16 8 10 8 #&gt; [18] 5 6 6 # 对于每一个元素：它是否重复（第一个值不算） duplicated(x) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE #&gt; [9] FALSE TRUE TRUE FALSE FALSE FALSE TRUE TRUE #&gt; [17] TRUE TRUE TRUE TRUE # 重复条目的值 注意“6”出现了三次，所以它有两个 x[duplicated(x)] #&gt; [1] 10 3 11 8 10 8 5 6 6 # 重复的条目无需重复出现 unique(x[duplicated(x)]) #&gt; [1] 10 3 11 8 5 6 # 移除重复数据，下面两种方法效果一样: unique(x) #&gt; [1] 14 11 8 4 12 5 10 3 6 0 16 x[!duplicated(x)] #&gt; [1] 14 11 8 4 12 5 10 3 6 0 16 6.4.2.2 列表 # 一个样本列表: df &lt;- read.table(header = TRUE, text = &quot; label value A 4 B 3 C 6 B 3 B 1 A 2 A 4 A 4 &quot;) # 每一行是否有重复？ duplicated(df) #&gt; [1] FALSE FALSE FALSE TRUE FALSE FALSE TRUE TRUE # 显示重复的条目 df[duplicated(df), ] #&gt; label value #&gt; 4 B 3 #&gt; 7 A 4 #&gt; 8 A 4 # 显示没有重复的条目 (行名可能不同，但值相同) unique(df[duplicated(df), ]) #&gt; label value #&gt; 4 B 3 #&gt; 7 A 4 # 移除重复的数据，下面两种方法效果一样: unique(df) #&gt; label value #&gt; 1 A 4 #&gt; 2 B 3 #&gt; 3 C 6 #&gt; 5 B 1 #&gt; 6 A 2 df[!duplicated(df), ] #&gt; label value #&gt; 1 A 4 #&gt; 2 B 3 #&gt; 3 C 6 #&gt; 5 B 1 #&gt; 6 A 2 6.5 NA 存在时进行向量或因子比较 6.5.1 问题 你想在 NA 存在的情况下比较比较两个向量或因子并返回 TRUE 或 FALSE（而不是 NA）。 6.5.2 方案 假设你有一个两列（包含布尔值）的列表： df &lt;- data.frame(a = c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, NA, NA, NA), b = c(TRUE, FALSE, NA, TRUE, FALSE, NA, TRUE, FALSE, NA)) df #&gt; a b #&gt; 1 TRUE TRUE #&gt; 2 TRUE FALSE #&gt; 3 TRUE NA #&gt; 4 FALSE TRUE #&gt; 5 FALSE FALSE #&gt; 6 FALSE NA #&gt; 7 NA TRUE #&gt; 8 NA FALSE #&gt; 9 NA NA 通常情况下，当你比较两个包含NA值的向量或因子时，原始值是NA，结果也将有NA。根据你的目的，这或许是是你想要的结果。 df$a == df$b #&gt; [1] TRUE FALSE NA FALSE TRUE NA NA NA #&gt; [9] NA # 同样的比较，但是可以生成列表的另一列： data.frame(df, isSame = (df$a == df$b)) #&gt; a b isSame #&gt; 1 TRUE TRUE TRUE #&gt; 2 TRUE FALSE FALSE #&gt; 3 TRUE NA NA #&gt; 4 FALSE TRUE FALSE #&gt; 5 FALSE FALSE TRUE #&gt; 6 FALSE NA NA #&gt; 7 NA TRUE NA #&gt; 8 NA FALSE NA #&gt; 9 NA NA NA 6.5.2.1 可以与 NA 相比的函数 这个比较函数会把NA赋予另一个值。如果一个向量的两项都是 NA ，则返回 TRUE；如果其中一个是 NA，则返回 FALSE；所有其他比较(无NA之间)的方式是一样的。 # 这个函数将会返回 TRUE，当两个元素相同（包括两个 # NA），其他情况返回 FALSE compareNA &lt;- function(v1, v2) { same &lt;- (v1 == v2) | (is.na(v1) &amp; is.na(v2)) same[is.na(same)] &lt;- FALSE return(same) } 6.5.2.2 使用该函数的例子 比较两个布尔向量： compareNA(df$a, df$b) #&gt; [1] TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [9] TRUE # 同样的比较，生成另一列 data.frame(df, isSame = compareNA(df$a, df$b)) #&gt; a b isSame #&gt; 1 TRUE TRUE TRUE #&gt; 2 TRUE FALSE FALSE #&gt; 3 TRUE NA FALSE #&gt; 4 FALSE TRUE FALSE #&gt; 5 FALSE FALSE TRUE #&gt; 6 FALSE NA FALSE #&gt; 7 NA TRUE FALSE #&gt; 8 NA FALSE FALSE #&gt; 9 NA NA TRUE 它也能用于因子，即使因子的水平处于不同的次序： # 创建一个含因子的列表 df1 &lt;- data.frame(a = factor(c(&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;, NA, NA, NA)), b = factor(c(&quot;x&quot;, &quot;y&quot;, NA, &quot;x&quot;, &quot;y&quot;, NA, &quot;x&quot;, &quot;y&quot;, NA))) # 比较 data.frame(df1, isSame = compareNA(df1$a, df1$b)) #&gt; a b isSame #&gt; 1 x x TRUE #&gt; 2 x y FALSE #&gt; 3 x &lt;NA&gt; FALSE #&gt; 4 y x FALSE #&gt; 5 y y TRUE #&gt; 6 y &lt;NA&gt; FALSE #&gt; 7 &lt;NA&gt; x FALSE #&gt; 8 &lt;NA&gt; y FALSE #&gt; 9 &lt;NA&gt; &lt;NA&gt; TRUE # 也能用于因子，即使因子的水平处于不同的次序 df1$b &lt;- factor(df1$b, levels = c(&quot;y&quot;, &quot;x&quot;)) data.frame(df1, isSame = compareNA(df1$a, df1$b)) #&gt; a b isSame #&gt; 1 x x TRUE #&gt; 2 x y FALSE #&gt; 3 x &lt;NA&gt; FALSE #&gt; 4 y x FALSE #&gt; 5 y y TRUE #&gt; 6 y &lt;NA&gt; FALSE #&gt; 7 &lt;NA&gt; x FALSE #&gt; 8 &lt;NA&gt; y FALSE #&gt; 9 &lt;NA&gt; &lt;NA&gt; TRUE 6.6 数据重新编码 6.6.1 问题 你想重新编码数据或从现有的数据中计算生产新的数据列。 6.6.2 方案 下面的例子将使用这些数据： data &lt;- read.table(header = T, text = &quot; subject sex control cond1 cond2 1 M 7.9 12.3 10.7 2 F 6.3 10.6 11.1 3 F 9.5 13.1 13.8 4 M 11.5 13.4 12.9 &quot;) 6.6.2.1 重新编码分类变量 最简单的方法是使用 plyr 包里的 revalue() 或 mapvalues()。这可以令M 为 1、F 为 2，并把它放在一个新生产的列。注意，这两个函数均保存数据类型：如果输入一个因子，输出将会是一个因子；如果输入是一个字符串向量，输出将会是一个字符串向量。 library(plyr) # 下面两行是等价的: data$scode &lt;- revalue(data$sex, c(M = &quot;1&quot;, F = &quot;2&quot;)) data$scode &lt;- mapvalues(data$sex, from = c(&quot;M&quot;, &quot;F&quot;), to = c(&quot;1&quot;, &quot;2&quot;)) data #&gt; subject sex control cond1 cond2 scode #&gt; 1 1 M 7.9 12.3 10.7 1 #&gt; 2 2 F 6.3 10.6 11.1 2 #&gt; 3 3 F 9.5 13.1 13.8 2 #&gt; 4 4 M 11.5 13.4 12.9 1 # data$sex是一个因子，因此data$scode也是因子 详见映射向量的值。 如果你不想依赖 plyr包，你可以使用 R 内置函数： data$scode[data$sex == &quot;M&quot;] &lt;- &quot;1&quot; data$scode[data$sex == &quot;F&quot;] &lt;- &quot;2&quot; # 把列转换为因子 data$scode &lt;- factor(data$scode) data #&gt; subject sex control cond1 cond2 scode #&gt; 1 1 M 7.9 12.3 10.7 1 #&gt; 2 2 F 6.3 10.6 11.1 2 #&gt; 3 3 F 9.5 13.1 13.8 2 #&gt; 4 4 M 11.5 13.4 12.9 1 另一种方法是使用 match() 函数： oldvalues &lt;- c(&quot;M&quot;, &quot;F&quot;) newvalues &lt;- factor(c(&quot;g1&quot;, &quot;g2&quot;)) # 转换为因子 data$scode &lt;- newvalues[match(data$sex, oldvalues)] data #&gt; subject sex control cond1 cond2 scode #&gt; 1 1 M 7.9 12.3 10.7 g1 #&gt; 2 2 F 6.3 10.6 11.1 g2 #&gt; 3 3 F 9.5 13.1 13.8 g2 #&gt; 4 4 M 11.5 13.4 12.9 g1 6.6.2.2 将一个连续变量重编码为分类变量 标记 control 值小于 7 为 low，大于或等于 7 为 high： data$category[data$control &lt; 7] &lt;- &quot;low&quot; data$category[data$control &gt;= 7] &lt;- &quot;high&quot; # 把列转换为因子 data$category &lt;- factor(data$category) data #&gt; subject sex control cond1 cond2 scode category #&gt; 1 1 M 7.9 12.3 10.7 g1 high #&gt; 2 2 F 6.3 10.6 11.1 g2 low #&gt; 3 3 F 9.5 13.1 13.8 g2 high #&gt; 4 4 M 11.5 13.4 12.9 g1 high 用 cut() 函数，可以指定边限和新值： data$category &lt;- cut(data$control, breaks = c(-Inf, 7, 9, Inf), labels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;)) data #&gt; subject sex control cond1 cond2 scode category #&gt; 1 1 M 7.9 12.3 10.7 g1 medium #&gt; 2 2 F 6.3 10.6 11.1 g2 low #&gt; 3 3 F 9.5 13.1 13.8 g2 high #&gt; 4 4 M 11.5 13.4 12.9 g1 high 默认情况下，范围是左边开放、右边关闭，如 (7，9] 。使用 right= FALSE 可以设置成左边关闭、右边开放，像 [7、9)。 6.6.2.3 计算得到一个新的连续变量 假设您想添加一个新列，为三个量的和。 data$total &lt;- data$control + data$cond1 + data$cond2 data #&gt; subject sex control cond1 cond2 scode category total #&gt; 1 1 M 7.9 12.3 10.7 g1 medium 30.9 #&gt; 2 2 F 6.3 10.6 11.1 g2 low 28.0 #&gt; 3 3 F 9.5 13.1 13.8 g2 high 36.4 #&gt; 4 4 M 11.5 13.4 12.9 g1 high 37.8 6.7 映射向量值 6.7.1 问题 你想将向量中所有值为 x 的实例改为值 y。 6.7.2 方案 # 创建一些样本数据 str &lt;- c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;) num &lt;- c(1, 2, 3) 最简单的方法是使用 plyr 包里的 revalue() 或 mapvalues()。 library(plyr) revalue(str, c(beta = &quot;two&quot;, gamma = &quot;three&quot;)) #&gt; [1] &quot;alpha&quot; &quot;two&quot; &quot;three&quot; mapvalues(str, from = c(&quot;beta&quot;, &quot;gamma&quot;), to = c(&quot;two&quot;, &quot;three&quot;)) #&gt; [1] &quot;alpha&quot; &quot;two&quot; &quot;three&quot; # 对于数值型向量，revalue() # 没作用，由于它使用一个命名了的向量，向量名一般是字符串而不是数值，但 # mapvalues()仍然有作用 mapvalues(num, from = c(2, 3), to = c(5, 6)) #&gt; [1] 1 5 6 如果你不想依赖 plyr包，你可以使用 R 内置函数。注意，这些方法将直接修改向量；也就是说，你不需要把结果保存回变量。 # 把&#39;beta&#39; 替换为 &#39;two&#39; str[str == &quot;beta&quot;] &lt;- &quot;two&quot; str #&gt; [1] &quot;alpha&quot; &quot;two&quot; &quot;gamma&quot; num[num == 2] &lt;- 5 num #&gt; [1] 1 5 3 也可以使用R的字符串查找和替换函数来重新映射字符串向量的值。注意，alpha 前后的 ^ 和 $ 确保整个字符串匹配。没有它们，如果有一个值为alphabet，它也会被匹配，替代 onebet。 str &lt;- c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;) sub(&quot;^alpha$&quot;, &quot;one&quot;, str) #&gt; [1] &quot;one&quot; &quot;beta&quot; &quot;gamma&quot; # 把所有列的 &#39;a&#39; 替代为 &#39;X&#39; gsub(&quot;a&quot;, &quot;X&quot;, str) #&gt; [1] &quot;XlphX&quot; &quot;betX&quot; &quot;gXmmX&quot; # gsub() 替代所有匹配的元素 sub() # 只替代每一个元素首先匹配到的内容 6.8 重命名因子水平 6.8.1 问题 你想要重命名因子水平。 6.8.2 方案 # 处理一个因子的样例 x &lt;- factor(c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;alpha&quot;, &quot;beta&quot;)) x #&gt; [1] alpha beta gamma alpha beta #&gt; Levels: alpha beta gamma levels(x) #&gt; [1] &quot;alpha&quot; &quot;beta&quot; &quot;gamma&quot; 最简单的办法是使用 plyr 包中的 revalue()或者 mapvalues() 函数。 library(plyr) revalue(x, c(beta = &quot;two&quot;, gamma = &quot;three&quot;)) #&gt; [1] alpha two three alpha two #&gt; Levels: alpha two three mapvalues(x, from = c(&quot;beta&quot;, &quot;gamma&quot;), to = c(&quot;two&quot;, &quot;three&quot;)) #&gt; [1] alpha two three alpha two #&gt; Levels: alpha two three 如果你不想要依赖 plyr 包，你可以使用 R 的内置函数进行以下处理。注意这些方法会直接修改变量x；你不需要将结果重新赋值回给x。 # 通过名字重命名: change &#39;beta&#39; to &#39;two&#39; levels(x)[levels(x) == &quot;beta&quot;] &lt;- &quot;two&quot; # 你也可以通过位置重命名，但这种做法比较危险（会因数据变化造成不可控结果），不值得推荐 # 通过因子列表索引重命名: change third item, &#39;gamma&#39;, to # &#39;three&#39;. levels(x)[3] &lt;- &quot;three&quot; x #&gt; [1] alpha two three alpha two #&gt; Levels: alpha two three # 重命名所有的因子水平 levels(x) &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) x #&gt; [1] one two three one two #&gt; Levels: one two three 我们可以不使用 plyr 包而通过名字实现因子水平的重命名，但记住这只有在所有的水平都在列表中时才起作用，否则会返回 NA 以代替寻找不到的因子水平。 # 用名字重命名所有因子 x &lt;- factor(c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;alpha&quot;, &quot;beta&quot;)) levels(x) &lt;- list(A = &quot;alpha&quot;, B = &quot;beta&quot;, C = &quot;gamma&quot;) x #&gt; [1] A B C A B #&gt; Levels: A B C 我们也可以使用 R 的字符串搜索与替换函数去重命名因子水平。注意字符 alpha 周围的 ^ 与 $ 符号是用来确保整个字符串能够匹配（正则表达式）。如果没有它们，字符 alphabet 也能够被成功匹配并会被替换为 onbet。 # 一个样例 x &lt;- factor(c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;alpha&quot;, &quot;beta&quot;)) x #&gt; [1] alpha beta gamma alpha beta #&gt; Levels: alpha beta gamma levels(x) &lt;- sub(&quot;^alpha$&quot;, &quot;one&quot;, levels(x)) x #&gt; [1] one beta gamma one beta #&gt; Levels: one beta gamma # 将所有的 &#39;a&#39; 替换为 &#39;X&#39; levels(x) &lt;- gsub(&quot;a&quot;, &quot;X&quot;, levels(x)) x #&gt; [1] one betX gXmmX one betX #&gt; Levels: one betX gXmmX # gsub() 替代所有匹配的元素 sub() # 只替代每一个元素首先匹配到的内容 6.8.3 更多参考 匹配向量中值并将其替换为新的值操作类似，参见映射向量值获取更多信息。 6.9 重计算因子水平 6.9.1 问题 你想要重新计算一个因子的水平。这在因子水平实际并没有出现在数据中时非常有用。它可能发生在数据的导入或者当你移除一些行时。 6.9.2 方案 对于单个因子变量： # 创建额外的因子水平 (gamma) x &lt;- factor(c(&quot;alpha&quot;, &quot;beta&quot;, &quot;alpha&quot;), levels = c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;)) x #&gt; [1] alpha beta alpha #&gt; Levels: alpha beta gamma # 移除额外的因子水平 x &lt;- factor(x) x #&gt; [1] alpha beta alpha #&gt; Levels: alpha beta 当导入数据之后，你可能有一个混合因子变量和其他向量的数据框，然后想要重新计算所有因子的水平。你可以使用 droplevels() 函数实现这一点。 # 创建一些因子的数据框 (有额外的因子水平) df &lt;- data.frame(x = factor(c(&quot;alpha&quot;, &quot;beta&quot;, &quot;alpha&quot;), levels = c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;)), y = c(5, 8, 2), z = factor(c(&quot;red&quot;, &quot;green&quot;, &quot;green&quot;), levels = c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;))) # 显示因子水平 (with extra levels) df$x #&gt; [1] alpha beta alpha #&gt; Levels: alpha beta gamma df$z #&gt; [1] red green green #&gt; Levels: red green blue # 丢掉额外因子水平 df &lt;- droplevels(df) # 再次显示因子，现在没有额外的因子水平了 df$x #&gt; [1] alpha beta alpha #&gt; Levels: alpha beta df$z #&gt; [1] red green green #&gt; Levels: red green 6.9.3 另见 想要重计算一个数据框中所有的因子变量列的因子水平，参见重计算数据框所有因子列的水平。 6.10 改变因子水平次序 6.10.1 问题 你想要改变因子水平出现的次序。 6.10.2 方案 R 中有两种不同类型的因子变量：有序和无序。比如{小，中，大}和｛钢笔，橡皮擦，铅笔｝。对于绝大多数分析而言，一个因子变量是有序还是无序并不重要。如果因子是有序的，那么这个因子水平的特定次序是重要的（小 &lt; 中 &lt; 大）。如果因子是无序的，那么因子水平同样会以一定的顺序出现，但这仅仅为了方便而已（钢笔，橡皮擦，铅笔） - 但有时它是重要的，例如它会指导结果如何输出，图形元素如何展示。 一种改变因子次序的方式是对因子使用 factor() 函数并且直接指定它们的次序。下面这个例子中，ordered() 函数可以替换 factor() 函数。 下面是这个例子的数据： # 创建一个错误次序的因子 sizes &lt;- factor(c(&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;, &quot;medium&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: large medium small 因子水平被显式地指定： sizes &lt;- factor(sizes, levels = c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: small medium large 我们同样可以对有序因子这样操作： sizes &lt;- ordered(c(&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;, &quot;medium&quot;)) sizes &lt;- ordered(sizes, levels = c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: small &lt; medium &lt; large 另一种方式是使用 relevel() 函数在列表中制作一个特定水平（这对有序因子不起作用）。 # 创建错误次序的因子 sizes &lt;- factor(c(&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;, &quot;medium&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: large medium small # 使得 medium 排最前面 sizes &lt;- relevel(sizes, &quot;medium&quot;) sizes #&gt; [1] small large large small medium #&gt; Levels: medium large small # 使得 small 排最前面 sizes &lt;- relevel(sizes, &quot;small&quot;) sizes #&gt; [1] small large large small medium #&gt; Levels: small medium large 当因子创建时，我们可以指定合适的顺序。 sizes &lt;- factor(c(&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;, &quot;medium&quot;), levels = c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: small medium large 反转因子水平次序。 # 创建错误次序的因子 sizes &lt;- factor(c(&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;, &quot;medium&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: large medium small sizes &lt;- factor(sizes, levels = rev(levels(sizes))) sizes #&gt; [1] small large large small medium #&gt; Levels: small medium large 6.11 重命名数据框的列 6.11.1 问题 你想要给数据框的列重新命名。 6.11.2 方案 让我们从有三列的一个数据框开始： d &lt;- data.frame(alpha = 1:3, beta = 4:6, gamma = 7:9) d #&gt; alpha beta gamma #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 names(d) #&gt; [1] &quot;alpha&quot; &quot;beta&quot; &quot;gamma&quot; 最简单的方式是使用 plyr 包的 rename() 函数： library(plyr) rename(d, c(beta = &quot;two&quot;, gamma = &quot;three&quot;)) #&gt; alpha two three #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 如果你不想要依赖 plyr 包，可以使用下面的 R 内置函数。注意这些直接修改了d，意味着你不需要把结果保存回d。 # 通过 name 函数重命名列：把 &#39;beta&#39; 改为 &#39;two&#39; names(d)[names(d) == &quot;beta&quot;] &lt;- &quot;two&quot; d #&gt; alpha two gamma #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 # 你也可以通过位置索引改变名字，但这种操作会有点危险，一旦你以后对数据做出改变，这些操作可能就不适用了。 # 通过名字向量的位置索引重命名：改变第三项，将 &#39;gamma&#39; # 改成 &#39;three&#39; names(d)[3] &lt;- &quot;three&quot; d #&gt; alpha two three #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 也可以使用 R 的字符串搜索和替换函数来重命名列。注意alpha周围的^和$是确保全部字符串匹配。没有他们的话，如果存在一个叫 alphabet 的列也会匹配成功。 names(d) &lt;- sub(&quot;^alpha$&quot;, &quot;one&quot;, names(d)) d #&gt; one two three #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 # 所有的列中，替换列名中的&#39;t&#39;为&#39;X&#39; names(d) &lt;- gsub(&quot;t&quot;, &quot;X&quot;, names(d)) d #&gt; one Xwo Xhree #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 # gsub() 替换每个列名中所有的匹配项 sub() # 只替换每个列名中匹配的第一项 6.12 添加和移除数据框的列 6.12.1 问题 你想要对一个数据框添加或者移除一些列（变量）。 6.12.2 方案 这里有许多解决办法： data &lt;- read.table(header = TRUE, text = &quot; id weight 1 20 2 27 3 24 &quot;) # 添加一列的办法 data$size &lt;- c(&quot;small&quot;, &quot;large&quot;, &quot;medium&quot;) data[[&quot;size&quot;]] &lt;- c(&quot;small&quot;, &quot;large&quot;, &quot;medium&quot;) data[, &quot;size&quot;] &lt;- c(&quot;small&quot;, &quot;large&quot;, &quot;medium&quot;) data$size &lt;- 0 # 添加的变量所有行都是一样的值 # 移除列的办法 data$size &lt;- NULL data[[&quot;size&quot;]] &lt;- NULL data[,&quot;size&quot;] &lt;- NULL data[[3]] &lt;- NULL data[,3] &lt;- NULL data &lt;- subset(data, select=-size) 6.13 对数据框的列重新排序 6.13.1 问题 你想要对一个数据框的列重新排序。 6.13.2 方案 # 一个样例数据框 data &lt;- read.table(header = TRUE, text = &quot; id weight size 1 20 small 2 27 large 3 24 medium &quot;) # 根据列名数字排序 data[c(1, 3, 2)] #&gt; id size weight #&gt; 1 1 small 20 #&gt; 2 2 large 27 #&gt; 3 3 medium 24 # 如果你想要实际改变 `data`，需要把它重新赋值回 `data` # 符号： data &lt;- data[c(1,3,2)] # 根据列名重新排序 data[c(&quot;size&quot;, &quot;id&quot;, &quot;weight&quot;)] #&gt; size id weight #&gt; 1 small 1 20 #&gt; 2 large 2 27 #&gt; 3 medium 3 24 上面例子中对数据框进行索引是将数据框作为一个列表（一个数据框实际上就是向量列表）。你也可以使用矩阵形式的索引方式： data[, c(1, 3, 2)] #&gt; id size weight #&gt; 1 1 small 20 #&gt; 2 2 large 27 #&gt; 3 3 medium 24 矩阵形式索引的缺点在于当你只指定一列时结果会不同。下面例子中，返回的结果对象是一个向量而不是数据框。因为返回的数据类型并不能总是与矩阵索引保持一致，所以通常使用列表形式进行索引更为安全，或者在矩阵索引形式中指定 drop=FALSE 选项： # 列表形式的索引 data[2] #&gt; weight #&gt; 1 20 #&gt; 2 27 #&gt; 3 24 # 矩阵形式的索引——降维会变为一个向量 data[, 2] #&gt; [1] 20 27 24 # 矩阵形式的索引，指定 drop=FALSE # ——保留维度以保存数据框形式 data[, 2, drop = FALSE] #&gt; weight #&gt; 1 20 #&gt; 2 27 #&gt; 3 24 6.14 合并数据框 6.14.1 问题 你想要基于一个给定的列合并两个数据框（像 SQL 的 join）。 6.14.2 方案 # 创建一个将 storyid 映射到 titles 上的数据框 stories &lt;- read.table(header = TRUE, text = &quot; storyid title 1 lions 2 tigers 3 bears &quot;) # 创建另一个有数据和 storyid 的数据框（没有 titles） data &lt;- read.table(header = TRUE, text = &quot; subject storyid rating 1 1 6.7 1 2 4.5 1 3 3.7 2 2 3.3 2 3 4.1 2 1 5.2 &quot;) # 合并两个数据框 merge(stories, data, &quot;storyid&quot;) #&gt; storyid title subject rating #&gt; 1 1 lions 1 6.7 #&gt; 2 1 lions 2 5.2 #&gt; 3 2 tigers 1 4.5 #&gt; 4 2 tigers 2 3.3 #&gt; 5 3 bears 1 3.7 #&gt; 6 3 bears 2 4.1 如果两个数据框里你想要匹配的列有不同的名字，可以通过选项指定： # 下面使用的是 id 替换了 storyid stories2 &lt;- read.table(header = TRUE, text = &quot; id title 1 lions 2 tigers 3 bears &quot;) # 合并两个数据框 merge(x = stories2, y = data, by.x = &quot;id&quot;, by.y = &quot;storyid&quot;) #&gt; id title subject rating #&gt; 1 1 lions 1 6.7 #&gt; 2 1 lions 2 5.2 #&gt; 3 2 tigers 1 4.5 #&gt; 4 2 tigers 2 3.3 #&gt; 5 3 bears 1 3.7 #&gt; 6 3 bears 2 4.1 # 注意结果的列名继承第一个数据框 我们也可以合并多个列： # 制造更多的数据 animals &lt;- read.table(header = T, text = &quot; size type name small cat lynx big cat tiger small dog chihuahua big dog \\&quot;great dane\\&quot; &quot;) observations &lt;- read.table(header = T, text = &quot; number size type 1 big cat 2 small dog 3 small dog 4 big dog &quot;) merge(observations, animals, c(&quot;size&quot;, &quot;type&quot;)) #&gt; size type number name #&gt; 1 big cat 1 tiger #&gt; 2 big dog 4 great dane #&gt; 3 small dog 2 chihuahua #&gt; 4 small dog 3 chihuahua 6.14.3 注意 合并之后，改变列名的顺序可能是有用的，参见对数据框的列重新排序 。 6.15 比较数据框 6.15.1 问题 你想要比较两个或多个数据框并找到在超过一个数据框中出现的行，或者仅在一个数据框中出现的行。 6.15.2 方案 6.15.2.1 一个例子 假设你有下面三个数据框，你想要知道那些至少在两个数据框中出现的行。 dfA &lt;- data.frame(Subject = c(1, 1, 2, 2), Response = c(&quot;X&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;)) dfA #&gt; Subject Response #&gt; 1 1 X #&gt; 2 1 X #&gt; 3 2 X #&gt; 4 2 X dfB &lt;- data.frame(Subject = c(1, 2, 3), Response = c(&quot;X&quot;, &quot;Y&quot;, &quot;X&quot;)) dfB #&gt; Subject Response #&gt; 1 1 X #&gt; 2 2 Y #&gt; 3 3 X dfC &lt;- data.frame(Subject = c(1, 2, 3), Response = c(&quot;Z&quot;, &quot;Y&quot;, &quot;Z&quot;)) dfC #&gt; Subject Response #&gt; 1 1 Z #&gt; 2 2 Y #&gt; 3 3 Z 在 dfA 中，包括 (1,X) 的行同样出现在了 dfB，但是包含 (2,X) 的行没有出现在任何其他的数据框。相似地，dfB 包含的 (1,X) 出现在了 dfA，(2,Y) 出现在了 dfC，但是 (3,X) 没有出现在其他数据框。 你可能想要标记在其他数据框中出现了的行，或者在每个数据框中都是唯一的行。 6.15.2.2 连接数据框 进一步地，我们首先用一个可以识别每一行来自哪里的列来连接数据框。这里称为 Coder 变量因为它可能是由三个不同的人编码的数据。在这个例子中，你可能想要找到编码者相同之处（至少出现在两个数据框中的行），或者它们不同之处。 dfA$Coder &lt;- &quot;A&quot; dfB$Coder &lt;- &quot;B&quot; dfC$Coder &lt;- &quot;C&quot; df &lt;- rbind(dfA, dfB, dfC) # 把它们粘在一起 df &lt;- df[, c(&quot;Coder&quot;, &quot;Subject&quot;, &quot;Response&quot;)] # 重新排序 df #&gt; Coder Subject Response #&gt; 1 A 1 X #&gt; 2 A 1 X #&gt; 3 A 2 X #&gt; 4 A 2 X #&gt; 5 B 1 X #&gt; 6 B 2 Y #&gt; 7 B 3 X #&gt; 8 C 1 Z #&gt; 9 C 2 Y #&gt; 10 C 3 Z 如果你的数据一开始就是这种格式，那就不要将它们连接到一起啦。 6.15.2.3 dupsBetweenGroups() 函数 该函数用来寻找不同组别的重复行： dupsBetweenGroups &lt;- function(df, idcol) { # df: the data frame idcol: the column which identifies # the group each row belongs to # Get the data columns to use for finding matches datacols &lt;- setdiff(names(df), idcol) # Sort by idcol, then datacols. Save order so we can # undo the sorting later. sortorder &lt;- do.call(order, df) df &lt;- df[sortorder, ] # Find duplicates within each id group (first copy not # marked) dupWithin &lt;- duplicated(df) # With duplicates within each group filtered out, find # duplicates between groups. Need to scan up and down # with duplicated() because first copy is not marked. dupBetween = rep(NA, nrow(df)) dupBetween[!dupWithin] &lt;- duplicated(df[!dupWithin, datacols]) dupBetween[!dupWithin] &lt;- duplicated(df[!dupWithin, datacols], fromLast = TRUE) | dupBetween[!dupWithin] # ============= Replace NA&#39;s with previous non-NA value # ============== This is why we sorted earlier - it was # necessary to do this part efficiently # Get indexes of non-NA&#39;s goodIdx &lt;- !is.na(dupBetween) # These are the non-NA values from x only Add a leading # NA for later use when we index into this vector goodVals &lt;- c(NA, dupBetween[goodIdx]) # Fill the indices of the output vector with the indices # pulled from these offsets of goodVals. Add 1 to avoid # indexing to zero. fillIdx &lt;- cumsum(goodIdx) + 1 # The original vector, now with gaps filled dupBetween &lt;- goodVals[fillIdx] # Undo the original sort dupBetween[sortorder] &lt;- dupBetween # Return the vector of which entries are duplicated # across groups return(dupBetween) } 6.15.2.4 寻找重复行 使用在前文定义的函数 dupsBetweenGroups()，我们可以找出在不同组别中重复的行。 # 找出在不同组别中重复的行 dupRows &lt;- dupsBetweenGroups(df, &quot;Coder&quot;) # 在数据框的旁边打印出来 cbind(df, dup = dupRows) #&gt; Coder Subject Response dup #&gt; 1 A 1 X TRUE #&gt; 2 A 1 X TRUE #&gt; 3 A 2 X FALSE #&gt; 4 A 2 X FALSE #&gt; 5 B 1 X TRUE #&gt; 6 B 2 Y TRUE #&gt; 7 B 3 X FALSE #&gt; 8 C 1 Z FALSE #&gt; 9 C 2 Y TRUE #&gt; 10 C 3 Z FALSE 注意这不会标记在同一组中的重复行，比如 Coder=A 时，有两行 Subject=2 以及 Response=X，但没有标记出来。 6.15.2.5 寻找唯一行 同样可以找出在每一组中唯一出现的行。 cbind(df, unique = !dupRows) #&gt; Coder Subject Response unique #&gt; 1 A 1 X FALSE #&gt; 2 A 1 X FALSE #&gt; 3 A 2 X TRUE #&gt; 4 A 2 X TRUE #&gt; 5 B 1 X FALSE #&gt; 6 B 2 Y FALSE #&gt; 7 B 3 X TRUE #&gt; 8 C 1 Z TRUE #&gt; 9 C 2 Y FALSE #&gt; 10 C 3 Z TRUE 6.15.2.6 拆分数据框 如果你想要把连接的数据框拆分为三个原始的数据框： # 保存df的结果 dfDup &lt;- cbind(df, dup = dupRows) dfA &lt;- subset(dfDup, Coder == &quot;A&quot;, select = -Coder) dfA #&gt; Subject Response dup #&gt; 1 1 X TRUE #&gt; 2 1 X TRUE #&gt; 3 2 X FALSE #&gt; 4 2 X FALSE dfB &lt;- subset(dfDup, Coder == &quot;B&quot;, select = -Coder) dfB #&gt; Subject Response dup #&gt; 5 1 X TRUE #&gt; 6 2 Y TRUE #&gt; 7 3 X FALSE dfC &lt;- subset(dfDup, Coder == &quot;C&quot;, select = -Coder) dfC #&gt; Subject Response dup #&gt; 8 1 Z FALSE #&gt; 9 2 Y TRUE #&gt; 10 3 Z FALSE 6.15.2.7 忽略列 有可能需要通过移除数据框的列来忽略一个或者多个列，结果又可以把原始完整的数据框连接起来。 # 忽略 Subject 列——仅使用 Response 列 dfNoSub &lt;- subset(df, select = -Subject) dfNoSub #&gt; Coder Response #&gt; 1 A X #&gt; 2 A X #&gt; 3 A X #&gt; 4 A X #&gt; 5 B X #&gt; 6 B Y #&gt; 7 B X #&gt; 8 C Z #&gt; 9 C Y #&gt; 10 C Z # 检查重复行 dupRows &lt;- dupsBetweenGroups(dfNoSub, &quot;Coder&quot;) # 把结果连接起来 cbind(df, dup = dupRows) #&gt; Coder Subject Response dup #&gt; 1 A 1 X TRUE #&gt; 2 A 1 X TRUE #&gt; 3 A 2 X TRUE #&gt; 4 A 2 X TRUE #&gt; 5 B 1 X TRUE #&gt; 6 B 2 Y TRUE #&gt; 7 B 3 X TRUE #&gt; 8 C 1 Z FALSE #&gt; 9 C 2 Y TRUE #&gt; 10 C 3 Z FALSE 6.15.3 注意 想要寻找单个数据框中的重复行，参见查找并移除重复记录。 6.16 重计算数据框所有因子列的水平 6.16.1 问题 你想要重新计算一个数据框中所有因子列（变量）的因子水平。 6.16.2 方案 有时候在读入和清理数据之后，你会发现数据（数据框）结果中有的因子列有一些不存在的因子水平。 例如，下面的d有一个空行。当它被读入时，因子列会出现水平 &quot;&quot;，它不应该是数据的一部分。 d &lt;- read.csv(header = TRUE, text = &quot; x,y,value a,one,1 ,,5 b,two,4 c,three,10 &quot;) d #&gt; x y value #&gt; 1 a one 1 #&gt; 2 5 #&gt; 3 b two 4 #&gt; 4 c three 10 str(d) #&gt; &#39;data.frame&#39;: 4 obs. of 3 variables: #&gt; $ x : Factor w/ 4 levels &quot;&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 2 1 3 4 #&gt; $ y : Factor w/ 4 levels &quot;&quot;,&quot;one&quot;,&quot;three&quot;,..: 2 1 4 3 #&gt; $ value: int 1 5 4 10 即便移除了空行，因子中仍有水平 &quot;&quot;： # 移除第二行 d &lt;- d[-2, ] d #&gt; x y value #&gt; 1 a one 1 #&gt; 3 b two 4 #&gt; 4 c three 10 str(d) #&gt; &#39;data.frame&#39;: 3 obs. of 3 variables: #&gt; $ x : Factor w/ 4 levels &quot;&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 2 3 4 #&gt; $ y : Factor w/ 4 levels &quot;&quot;,&quot;one&quot;,&quot;three&quot;,..: 2 4 3 #&gt; $ value: int 1 4 10 6.16.2.1 使用 droplevels() 最简单的方式是使用 droplevels() 函数： d1 &lt;- droplevels(d) str(d1) #&gt; &#39;data.frame&#39;: 3 obs. of 3 variables: #&gt; $ x : Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3 #&gt; $ y : Factor w/ 3 levels &quot;one&quot;,&quot;three&quot;,..: 1 3 2 #&gt; $ value: int 1 4 10 6.16.2.2 使用 vapply() 和 lapply() 为了重新计算所有因子列的水平，我们使用以 is.factor() 为参数的 vapply()函数去找出哪些列是因子，然后再利用以 factor()函数为参数的 lapply() 操作将那些列重新计算因子水平。 # 找出哪些列是因子 factor_cols &lt;- vapply(d, is.factor, logical(1)) # 把 factor() 函数应用到那些列，并把结果赋回 d d[factor_cols] &lt;- lapply(d[factor_cols], factor) str(d) #&gt; &#39;data.frame&#39;: 3 obs. of 3 variables: #&gt; $ x : Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3 #&gt; $ y : Factor w/ 3 levels &quot;one&quot;,&quot;three&quot;,..: 1 3 2 #&gt; $ value: int 1 4 10 6.16.3 另见 关于重计算一个因子变量水平的信息，参见重计算因子水平。 6.17 长宽格式数据互换 6.17.1 问题 你想要把数据从宽格式转换为长格式。 R中许多函数希望输入的数据是长格式而不是宽格式。然而像 SPSS 软件经常使用宽格式数据。 6.17.2 方案 下面有两类方法： tidyr 包的 gather() 和 spread() 函数。这 是reshape2 包的一个新接口。 reshape2包的 melt() 与 dcast() 函数。 这里不包含其他一些实现的方法，因为这些方法不是很好使用： reshape() 函数比较让人迷惑，因为它是 R 基础包的一部分，而不是 reshape2 包的一部分。 stack() 和 unstack() 6.17.2.1 样例数据 这里使用的数据框包含同样数据的长、宽格式。它们接下来会被相互转换。 olddata_wide &lt;- read.table(header = TRUE, text = &quot; subject sex control cond1 cond2 1 M 7.9 12.3 10.7 2 F 6.3 10.6 11.1 3 F 9.5 13.1 13.8 4 M 11.5 13.4 12.9 &quot;) # 确保 subject 列是一个因子 olddata_wide$subject &lt;- factor(olddata_wide$subject) olddata_long &lt;- read.table(header = TRUE, text = &quot; subject sex condition measurement 1 M control 7.9 1 M cond1 12.3 1 M cond2 10.7 2 F control 6.3 2 F cond1 10.6 2 F cond2 11.1 3 F control 9.5 3 F cond1 13.1 3 F cond2 13.8 4 M control 11.5 4 M cond1 13.4 4 M cond2 12.9 &quot;) # 确保 subject 列是一个因子 olddata_long$subject &lt;- factor(olddata_long$subject) 6.17.2.2 tidyr 6.17.2.2.1 从宽格式到长格式 使用 gather(): olddata_wide #&gt; subject sex control cond1 cond2 #&gt; 1 1 M 7.9 12.3 10.7 #&gt; 2 2 F 6.3 10.6 11.1 #&gt; 3 3 F 9.5 13.1 13.8 #&gt; 4 4 M 11.5 13.4 12.9 library(tidyr) # gather() 的主要参数: - data: 输入数据 - key: # 分类key的列名 - value: 包含值的列名 - ...: # 包换需要转换值的列名 - factor_key: # 把新的合成列设置为因子 data_long &lt;- gather(olddata_wide, condition, measurement, control:cond2, factor_key = TRUE) data_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 2 2 F control 6.3 #&gt; 3 3 F control 9.5 #&gt; 4 4 M control 11.5 #&gt; 5 1 M cond1 12.3 #&gt; 6 2 F cond1 10.6 #&gt; 7 3 F cond1 13.1 #&gt; 8 4 M cond1 13.4 #&gt; 9 1 M cond2 10.7 #&gt; 10 2 F cond2 11.1 #&gt; 11 3 F cond2 13.8 #&gt; 12 4 M cond2 12.9 在这个例子中，来源列通过 control:cond2 指定聚集到一起。这里的意思是使用位置上在 control 和 conda2 之间（包括 control 与 conda2 ）的所有列。另一种使用的方式是单独为每一列命名，如下： gather(olddata_wide, condition, measurement, control, cond1, cond2) #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 2 2 F control 6.3 #&gt; 3 3 F control 9.5 #&gt; 4 4 M control 11.5 #&gt; 5 1 M cond1 12.3 #&gt; 6 2 F cond1 10.6 #&gt; 7 3 F cond1 13.1 #&gt; 8 4 M cond1 13.4 #&gt; 9 1 M cond2 10.7 #&gt; 10 2 F cond2 11.1 #&gt; 11 3 F cond2 13.8 #&gt; 12 4 M cond2 12.9 如果你需要编程化使用gather()函数，可能需要使用包含列名的变量。想要实现它的话，你需要使用 gather_() 函数，它会使用字符串而不是没加引号的列名。 keycol &lt;- &quot;condition&quot; valuecol &lt;- &quot;measurement&quot; gathercols &lt;- c(&quot;control&quot;, &quot;cond1&quot;, &quot;cond2&quot;) gather_(olddata_wide, keycol, valuecol, gathercols) #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 2 2 F control 6.3 #&gt; 3 3 F control 9.5 #&gt; 4 4 M control 11.5 #&gt; 5 1 M cond1 12.3 #&gt; 6 2 F cond1 10.6 #&gt; 7 3 F cond1 13.1 #&gt; 8 4 M cond1 13.4 #&gt; 9 1 M cond2 10.7 #&gt; 10 2 F cond2 11.1 #&gt; 11 3 F cond2 13.8 #&gt; 12 4 M cond2 12.9 可选内容：重命名变量列的因子水平并排序。 # 重命名因子水平 levels(data_long$condition)[levels(data_long$condition) == &quot;cond1&quot;] &lt;- &quot;first&quot; levels(data_long$condition)[levels(data_long$condition) == &quot;cond2&quot;] &lt;- &quot;second&quot; # 首先按照 subject 排序，然后按 condition data_long &lt;- data_long[order(data_long$subject, data_long$condition), ] data_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 5 1 M first 12.3 #&gt; 9 1 M second 10.7 #&gt; 2 2 F control 6.3 #&gt; 6 2 F first 10.6 #&gt; 10 2 F second 11.1 #&gt; 3 3 F control 9.5 #&gt; 7 3 F first 13.1 #&gt; 11 3 F second 13.8 #&gt; 4 4 M control 11.5 #&gt; 8 4 M first 13.4 #&gt; 12 4 M second 12.9 6.17.2.2.2 从长格式到宽格式 使用 spread(): olddata_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 2 1 M cond1 12.3 #&gt; 3 1 M cond2 10.7 #&gt; 4 2 F control 6.3 #&gt; 5 2 F cond1 10.6 #&gt; 6 2 F cond2 11.1 #&gt; 7 3 F control 9.5 #&gt; 8 3 F cond1 13.1 #&gt; 9 3 F cond2 13.8 #&gt; 10 4 M control 11.5 #&gt; 11 4 M cond1 13.4 #&gt; 12 4 M cond2 12.9 library(tidyr) # spread() 主要参数: - data: 数据对象 - key: # 包含新列名的列名 - value: 包含值得列名 data_wide &lt;- spread(olddata_long, condition, measurement) data_wide #&gt; subject sex cond1 cond2 control #&gt; 1 1 M 12.3 10.7 7.9 #&gt; 2 2 F 10.6 11.1 6.3 #&gt; 3 3 F 13.1 13.8 9.5 #&gt; 4 4 M 13.4 12.9 11.5 可选项：一些可以使数据看起来更易读的操作。 # 重命名 names(data_wide)[names(data_wide) == &quot;cond1&quot;] &lt;- &quot;first&quot; names(data_wide)[names(data_wide) == &quot;cond2&quot;] &lt;- &quot;second&quot; # 排序 data_wide &lt;- data_wide[, c(1, 2, 5, 3, 4)] data_wide #&gt; subject sex control first second #&gt; 1 1 M 7.9 12.3 10.7 #&gt; 2 2 F 6.3 10.6 11.1 #&gt; 3 3 F 9.5 13.1 13.8 #&gt; 4 4 M 11.5 13.4 12.9 因子水平的顺序决定了列的顺序。水平次序能够在重塑之前被改变，或者列也可以在之后重新排序。 6.17.2.3 reshape2 6.17.2.3.1 从宽格式到长格式 使用 melt(): olddata_wide #&gt; subject sex control cond1 cond2 #&gt; 1 1 M 7.9 12.3 10.7 #&gt; 2 2 F 6.3 10.6 11.1 #&gt; 3 3 F 9.5 13.1 13.8 #&gt; 4 4 M 11.5 13.4 12.9 library(reshape2) #&gt; #&gt; Attaching package: &#39;reshape2&#39; #&gt; The following object is masked from &#39;package:tidyr&#39;: #&gt; #&gt; smiths # 指定id.vars：需要保持的变量名 melt(olddata_wide, id.vars = c(&quot;subject&quot;, &quot;sex&quot;)) #&gt; subject sex variable value #&gt; 1 1 M control 7.9 #&gt; 2 2 F control 6.3 #&gt; 3 3 F control 9.5 #&gt; 4 4 M control 11.5 #&gt; 5 1 M cond1 12.3 #&gt; 6 2 F cond1 10.6 #&gt; 7 3 F cond1 13.1 #&gt; 8 4 M cond1 13.4 #&gt; 9 1 M cond2 10.7 #&gt; 10 2 F cond2 11.1 #&gt; 11 3 F cond2 13.8 #&gt; 12 4 M cond2 12.9 melt() 的一些选项可以使得输出更好处理： data_long &lt;- melt(olddata_wide, # 变量ID，需要保持的变量名 id.vars=c(&quot;subject&quot;, &quot;sex&quot;), # 来源列（被转换的） measure.vars=c(&quot;control&quot;, &quot;cond1&quot;, &quot;cond2&quot; ), # 目的列的名字可以确定测量列数值的来自的原始列（变量） # 这里 measurement 是数值，condition 指定了其来源 variable.name=&quot;condition&quot;, value.name=&quot;measurement&quot; ) data_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 2 2 F control 6.3 #&gt; 3 3 F control 9.5 #&gt; 4 4 M control 11.5 #&gt; 5 1 M cond1 12.3 #&gt; 6 2 F cond1 10.6 #&gt; 7 3 F cond1 13.1 #&gt; 8 4 M cond1 13.4 #&gt; 9 1 M cond2 10.7 #&gt; 10 2 F cond2 11.1 #&gt; 11 3 F cond2 13.8 #&gt; 12 4 M cond2 12.9 如果你不设定 measure.vars，melt() 函数会自动使用除 id.vars 的所有其他变量。反之亦然。 如果你不指定 variable.name，它会把那列命名为&quot;variable&quot;，如果你不使用 value.name 变量，它会将它命名为 &quot;measurement&quot;。 可选项：重命名变量列的因子水平。 # 重命名因子 levels(data_long$condition)[levels(data_long$condition) == &quot;cond1&quot;] &lt;- &quot;first&quot; levels(data_long$condition)[levels(data_long$condition) == &quot;cond2&quot;] &lt;- &quot;second&quot; # 首先按 subject 排序，然后按 condition 排序 data_long &lt;- data_long[order(data_long$subject, data_long$condition), ] data_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 5 1 M first 12.3 #&gt; 9 1 M second 10.7 #&gt; 2 2 F control 6.3 #&gt; 6 2 F first 10.6 #&gt; 10 2 F second 11.1 #&gt; 3 3 F control 9.5 #&gt; 7 3 F first 13.1 #&gt; 11 3 F second 13.8 #&gt; 4 4 M control 11.5 #&gt; 8 4 M first 13.4 #&gt; 12 4 M second 12.9 6.17.2.3.2 从长格式到宽格式 下面代码使用 dcast() 函数重塑数据。这个函数用于数据框，如果你处理数组或矩阵，替换使用 acast()。 olddata_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 2 1 M cond1 12.3 #&gt; 3 1 M cond2 10.7 #&gt; 4 2 F control 6.3 #&gt; 5 2 F cond1 10.6 #&gt; 6 2 F cond2 11.1 #&gt; 7 3 F control 9.5 #&gt; 8 3 F cond1 13.1 #&gt; 9 3 F cond2 13.8 #&gt; 10 4 M control 11.5 #&gt; 11 4 M cond1 13.4 #&gt; 12 4 M cond2 12.9 # 信息: &#39;subject&#39; 和 &#39;sex&#39; 是我们想要保留的列 # &#39;condition&#39; 是我们想要放入新列名的列 &#39;measurement&#39; # 包含数值 library(reshape2) data_wide &lt;- dcast(olddata_long, subject + sex ~ condition, value.var = &quot;measurement&quot;) data_wide #&gt; subject sex cond1 cond2 control #&gt; 1 1 M 12.3 10.7 7.9 #&gt; 2 2 F 10.6 11.1 6.3 #&gt; 3 3 F 13.1 13.8 9.5 #&gt; 4 4 M 13.4 12.9 11.5 可选项：一些可以使数据看起来更易读的操作。 # 重命名 names(data_wide)[names(data_wide) == &quot;cond1&quot;] &lt;- &quot;first&quot; names(data_wide)[names(data_wide) == &quot;cond2&quot;] &lt;- &quot;second&quot; # 重排序 data_wide &lt;- data_wide[, c(1, 2, 5, 3, 4)] data_wide #&gt; subject sex control first second #&gt; 1 1 M 7.9 12.3 10.7 #&gt; 2 2 F 6.3 10.6 11.1 #&gt; 3 3 F 9.5 13.1 13.8 #&gt; 4 4 M 11.5 13.4 12.9 因子水平的顺序决定了列的顺序。水平次序能够在重塑之前被改变，或者列也可以在之后重新排序。 6.18 汇总数据 6.18.1 问题 你想要按照组别汇总你的数据（均值、标准差等等）。 6.18.2 方案 有三种方法描述基于一些特定变量的分组数据，然后对每一组使用汇总函数（像均值、标准差等等）。 ddply() 函数：它比较容易使用，但需要载入 plyr 包。这种方法可能就是你要找的。 summaryBy() 函数：它也比较容易使用，然而它需要载入 doBy 包。 aggregate() 函数，它比较难使用一点但内置于 R 中。 假设你有以下数据并想求得每一组样本大小、均值的改变、标准差以及均值的标准误，而这里的组别是根据性别和条件指定的：F-placebo, F-aspirin, M-placebo和 M-aspirin。 data &lt;- read.table(header=TRUE, text=&#39; subject sex condition before after change 1 F placebo 10.1 6.9 -3.2 2 F placebo 6.3 4.2 -2.1 3 M aspirin 12.4 6.3 -6.1 4 F placebo 8.1 6.1 -2.0 5 M aspirin 15.2 9.9 -5.3 6 F aspirin 10.9 7.0 -3.9 7 F aspirin 11.6 8.5 -3.1 8 M aspirin 9.5 3.0 -6.5 9 F placebo 11.5 9.0 -2.5 10 M placebo 11.9 11.0 -0.9 11 F aspirin 11.4 8.0 -3.4 12 M aspirin 10.0 4.4 -5.6 13 M aspirin 12.5 5.4 -7.1 14 M placebo 10.6 10.6 0.0 15 M aspirin 9.1 4.3 -4.8 16 F placebo 12.1 10.2 -1.9 17 F placebo 11.0 8.8 -2.2 18 F placebo 11.9 10.2 -1.7 19 M aspirin 9.1 3.6 -5.5 20 M placebo 13.5 12.4 -1.1 21 M aspirin 12.0 7.5 -4.5 22 F placebo 9.1 7.6 -1.5 23 M placebo 9.9 8.0 -1.9 24 F placebo 7.6 5.2 -2.4 25 F placebo 11.8 9.7 -2.1 26 F placebo 11.8 10.7 -1.1 27 F aspirin 10.1 7.9 -2.2 28 M aspirin 11.6 8.3 -3.3 29 F aspirin 11.3 6.8 -4.5 30 F placebo 10.3 8.3 -2.0 &#39;) 6.18.2.1 使用 ddply library(plyr) # 给每一组运行长度、均值、标准差等函数 # 每一组依据性别+条件划分 cdata &lt;- ddply(data, c(&quot;sex&quot;, &quot;condition&quot;), summarise, N = length(change), mean = mean(change), sd = sd(change), se = sd/sqrt(N)) cdata #&gt; sex condition N mean sd se #&gt; 1 F aspirin 5 -3.420 0.8643 0.3865 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 #&gt; 3 M aspirin 9 -5.411 1.1308 0.3769 #&gt; 4 M placebo 4 -0.975 0.7805 0.3902 6.18.2.1.1 处理缺失值 如果数据中存在 NA 值，需要给每个函数添加 na.rm=TRUE 标记去除缺失值。因为函数 length() 没有 na.rm 选项，所以可以使用 sum(!is.na(...))的方式对非缺失值进行计数。 # 给数据加些 NA 值 dataNA &lt;- data dataNA$change[11:14] &lt;- NA cdata &lt;- ddply(dataNA, c(&quot;sex&quot;, &quot;condition&quot;), summarise, N = sum(!is.na(change)), mean = mean(change, na.rm = TRUE), sd = sd(change, na.rm = TRUE), se = sd/sqrt(N)) cdata #&gt; sex condition N mean sd se #&gt; 1 F aspirin 4 -3.425 0.9979 0.4990 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 #&gt; 3 M aspirin 7 -5.143 1.0675 0.4035 #&gt; 4 M placebo 3 -1.300 0.5292 0.3055 6.18.2.1.2 自动汇总函数 不像我们刚才手动地指定想要的值然后计算标准误，这个函数可以自动处理所有的细节。它可以干以下的事情： 寻找均值、标准差和计数 寻找均值的标准误（强调，如果你处理的是被试内变量这可能不是你想要的) 寻找 95% 的置信区间（也可以指定其他值） 重命令结果数据集的变量名，这样更方便后续处理 要使用的话，把函数放你的代码中然后像下面一样调用它。 ## Summarizes data. Gives count, mean, standard ## deviation, standard error of the mean, and confidence ## interval (default 95%). data: a data frame. ## measurevar: the name of a column that contains the ## variable to be summariezed groupvars: a vector ## containing names of columns that contain grouping ## variables na.rm: a boolean that indicates whether to ## ignore NA&#39;s conf.interval: the percent range of the ## confidence interval (default is 95%) summarySE &lt;- function(data = NULL, measurevar, groupvars = NULL, na.rm = FALSE, conf.interval = 0.95, .drop = TRUE) { library(plyr) # New version of length which can handle NA&#39;s: if # na.rm==T, don&#39;t count them length2 &lt;- function(x, na.rm = FALSE) { if (na.rm) sum(!is.na(x)) else length(x) } # This does the summary. For each group&#39;s data frame, # return a vector with N, mean, and sd datac &lt;- ddply(data, groupvars, .drop = .drop, .fun = function(xx, col) { c(N = length2(xx[[col]], na.rm = na.rm), mean = mean(xx[[col]], na.rm = na.rm), sd = sd(xx[[col]], na.rm = na.rm)) }, measurevar) # Rename the &#39;mean&#39; column datac &lt;- rename(datac, c(mean = measurevar)) datac$se &lt;- datac$sd/sqrt(datac$N) # Calculate standard error of the mean # Confidence interval multiplier for standard error # Calculate t-statistic for confidence interval: e.g., # if conf.interval is .95, use .975 (above/below), and # use df=N-1 ciMult &lt;- qt(conf.interval/2 + 0.5, datac$N - 1) datac$ci &lt;- datac$se * ciMult return(datac) } 举个例子使用它（用95%的置信区间）。与之前手动计算这些步骤相比 summarySE() 函数一步搞定： summarySE(data, measurevar = &quot;change&quot;, groupvars = c(&quot;sex&quot;, &quot;condition&quot;)) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420 0.8643 0.3865 1.0732 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 0.3334 #&gt; 3 M aspirin 9 -5.411 1.1308 0.3769 0.8692 #&gt; 4 M placebo 4 -0.975 0.7805 0.3902 1.2419 # 使用 NA&#39;的数据框, 使用 na.rm=TRUE summarySE(dataNA, measurevar = &quot;change&quot;, groupvars = c(&quot;sex&quot;, &quot;condition&quot;), na.rm = TRUE) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 4 -3.425 0.9979 0.4990 1.5879 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 0.3334 #&gt; 3 M aspirin 7 -5.143 1.0675 0.4035 0.9873 #&gt; 4 M placebo 3 -1.300 0.5292 0.3055 1.3145 6.18.2.1.3 用零填满空组合 有时候汇总的数据框中存在因子的空组合——意思是因子组合可能存在，但原始数据框里又没有实际出现。它在自动填满有 NA 值的数据框时有用。要做到这一点，当调用ddply() 或 summarySE() 时设置 .drop=FALSE。 例子： # 首先移除所有 Male+Placebo 条目 dataSub &lt;- subset(data, !(sex == &quot;M&quot; &amp; condition == &quot;placebo&quot;)) # 如果我们汇总数据，在本来有 Male+Placebo # 的地方会存在空行 因为这个组合已经被我们删除了 summarySE(dataSub, measurevar = &quot;change&quot;, groupvars = c(&quot;sex&quot;, &quot;condition&quot;)) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420 0.8643 0.3865 1.0732 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 0.3334 #&gt; 3 M aspirin 9 -5.411 1.1308 0.3769 0.8692 # 设置 .drop=FALSE 指定不要扔掉这个组合 summarySE(dataSub, measurevar = &quot;change&quot;, groupvars = c(&quot;sex&quot;, &quot;condition&quot;), .drop = FALSE) #&gt; Warning in qt(conf.interval/2 + 0.5, datac$N - 1): 产生 #&gt; 了NaNs #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420 0.8643 0.3865 1.0732 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 0.3334 #&gt; 3 M aspirin 9 -5.411 1.1308 0.3769 0.8692 #&gt; 4 M placebo 0 NaN NA NA NaN 6.18.2.2 使用summaryBy 使用 summarizeBy() 函数瓦解数据： library(doBy) # 给每一组运行长度、均值、标准差等函数 # 每一组依据性别+条件划分 cdata &lt;- summaryBy(change ~ sex + condition, data = data, FUN = c(length, mean, sd)) cdata #&gt; sex condition change.length change.mean change.sd #&gt; 1 F aspirin 5 -3.420 0.8643 #&gt; 2 F placebo 12 -2.058 0.5248 #&gt; 3 M aspirin 9 -5.411 1.1308 #&gt; 4 M placebo 4 -0.975 0.7805 # 重命名 change.length 为 N names(cdata)[names(cdata) == &quot;change.length&quot;] &lt;- &quot;N&quot; # 计算平均值的标准误差 cdata$change.se &lt;- cdata$change.sd/sqrt(cdata$N) cdata #&gt; sex condition N change.mean change.sd change.se #&gt; 1 F aspirin 5 -3.420 0.8643 0.3865 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 #&gt; 3 M aspirin 9 -5.411 1.1308 0.3769 #&gt; 4 M placebo 4 -0.975 0.7805 0.3902 注意，如果你有任何被试间变量，这些标准误值在比对组别差异时就没用了。 6.18.2.2.1 处理缺失值 如果数据中存在 NA 值，你需要添加 na.rm=TRUE 选项。通常你可以在 summaryBy() 函数中设置，但 length() 函数识别不了这个选项。一种解决方式是根据 length() 函数定义一个新的取长度函数去处理NA值。 # 新版的 length 函数可以处理 NA 值，如果 na.rm=T,则不对 # NA 计数 length2 &lt;- function(x, na.rm = FALSE) { if (na.rm) sum(!is.na(x)) else length(x) } # 给数据添加一些 NA 值 dataNA &lt;- data dataNA$change[11:14] &lt;- NA cdataNA &lt;- summaryBy(change ~ sex + condition, data = dataNA, FUN = c(length2, mean, sd), na.rm = TRUE) cdataNA #&gt; sex condition change.length2 change.mean change.sd #&gt; 1 F aspirin 4 -3.425 0.9979 #&gt; 2 F placebo 12 -2.058 0.5248 #&gt; 3 M aspirin 7 -5.143 1.0675 #&gt; 4 M placebo 3 -1.300 0.5292 # 做些其他事情 6.18.2.2.2 自动汇总函数 注意这里的自动汇总函数与之前的不同，它是通过 summaryBy() 实现的 不像我们刚才手动地指定想要的值然后计算标准误，这个函数可以自动处理所有的细节。它可以干以下的事情： 寻找均值、标准差和计数 寻找均值的标准误 寻找95%的置信区间（也可以指定其他值） 重命令结果数据集的变量名，这样更方便后续处理 要使用的话，把函数放你的代码中然后像下面一样调用它。 ## Summarizes data. Gives count, mean, standard ## deviation, standard error of the mean, and confidence ## interval (default 95%). data: a data frame. ## measurevar: the name of a column that contains the ## variable to be summariezed groupvars: a vector ## containing names of columns that contain grouping ## variables na.rm: a boolean that indicates whether to ## ignore NA&#39;s conf.interval: the percent range of the ## confidence interval (default is 95%) summarySE &lt;- function(data = NULL, measurevar, groupvars = NULL, na.rm = FALSE, conf.interval = 0.95) { library(doBy) # New version of length which can handle NA&#39;s: if # na.rm==T, don&#39;t count them length2 &lt;- function(x, na.rm = FALSE) { if (na.rm) sum(!is.na(x)) else length(x) } # Collapse the data formula &lt;- as.formula(paste(measurevar, paste(groupvars, collapse = &quot; + &quot;), sep = &quot; ~ &quot;)) datac &lt;- summaryBy(formula, data = data, FUN = c(length2, mean, sd), na.rm = na.rm) # Rename columns names(datac)[names(datac) == paste(measurevar, &quot;.mean&quot;, sep = &quot;&quot;)] &lt;- measurevar names(datac)[names(datac) == paste(measurevar, &quot;.sd&quot;, sep = &quot;&quot;)] &lt;- &quot;sd&quot; names(datac)[names(datac) == paste(measurevar, &quot;.length2&quot;, sep = &quot;&quot;)] &lt;- &quot;N&quot; datac$se &lt;- datac$sd/sqrt(datac$N) # Calculate standard error of the mean # Confidence interval multiplier for standard error # Calculate t-statistic for confidence interval: e.g., # if conf.interval is .95, use .975 (above/below), and # use df=N-1 ciMult &lt;- qt(conf.interval/2 + 0.5, datac$N - 1) datac$ci &lt;- datac$se * ciMult return(datac) } 举个例子使用它（用95%的置信区间）。与之前手动计算这些步骤相反，summarySE() 函数一步搞定： summarySE(data, measurevar = &quot;change&quot;, groupvars = c(&quot;sex&quot;, &quot;condition&quot;)) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420 0.8643 0.3865 1.0732 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 0.3334 #&gt; 3 M aspirin 9 -5.411 1.1308 0.3769 0.8692 #&gt; 4 M placebo 4 -0.975 0.7805 0.3902 1.2419 # 对于含有 NA 值得数据集，使用 na.rm=TRUE summarySE(dataNA, measurevar = &quot;change&quot;, groupvars = c(&quot;sex&quot;, &quot;condition&quot;), na.rm = TRUE) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 4 -3.425 0.9979 0.4990 1.5879 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 0.3334 #&gt; 3 M aspirin 7 -5.143 1.0675 0.4035 0.9873 #&gt; 4 M placebo 3 -1.300 0.5292 0.3055 1.3145 6.18.2.2.3 用零填满空组合 有时候汇总的数据框中存在因子的空组合 - 这意思是，因子组合可能存在，但原始数据框里又没有实际出现。它在自动填满有 NA 值的数据框时有用。 这个例子将会用 0 填满缺失的组合： fillMissingCombs &lt;- function(df, factors, measures) { # 创建含因子水平组合的列表 levelList &lt;- list() for (f in factors) { levelList[[f]] &lt;- levels(df[, f]) } fullFactors &lt;- expand.grid(levelList) dfFull &lt;- merge(fullFactors, df, all.x = TRUE) # 将 measure 变量中的 NA 都替换为 0 for (m in measures) { dfFull[is.na(dfFull[, m]), m] &lt;- 0 } return(dfFull) } 使用例子： # 首先移除所有 Male+Placebo 条目 dataSub &lt;- subset(data, !(sex == &quot;M&quot; &amp; condition == &quot;placebo&quot;)) # 如果我们汇总数据，在本来有 Male+Placebo # 的地方会存在空行 因为这个组合已经被我们删除了 cdataSub &lt;- summarySE(dataSub, measurevar = &quot;change&quot;, groupvars = c(&quot;sex&quot;, &quot;condition&quot;)) cdataSub #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420 0.8643 0.3865 1.0732 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 0.3334 #&gt; 3 M aspirin 9 -5.411 1.1308 0.3769 0.8692 # 设置 .drop=FALSE 指定不要扔掉这个组合 fillMissingCombs(cdataSub, factors = c(&quot;sex&quot;, &quot;condition&quot;), measures = c(&quot;N&quot;, &quot;change&quot;, &quot;sd&quot;, &quot;se&quot;, &quot;ci&quot;)) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420 0.8643 0.3865 1.0732 #&gt; 2 F placebo 12 -2.058 0.5248 0.1515 0.3334 #&gt; 3 M aspirin 9 -5.411 1.1308 0.3769 0.8692 #&gt; 4 M placebo 0 0.000 0.0000 0.0000 0.0000 6.18.2.3 使用 aggregate() aggregate() 函数比较难用，但它内置于 R，所以不需要安装其他包。 # 对每个目录 (sex*condition) 中的对象计数 cdata &lt;- aggregate(data[&quot;subject&quot;], by = data[c(&quot;sex&quot;, &quot;condition&quot;)], FUN = length) cdata #&gt; sex condition subject #&gt; 1 F aspirin 5 #&gt; 2 M aspirin 9 #&gt; 3 F placebo 12 #&gt; 4 M placebo 4 # 重命名 &#39;subject&#39; 列为 &#39;N&#39; names(cdata)[names(cdata) == &quot;subject&quot;] &lt;- &quot;N&quot; cdata #&gt; sex condition N #&gt; 1 F aspirin 5 #&gt; 2 M aspirin 9 #&gt; 3 F placebo 12 #&gt; 4 M placebo 4 # 按性别排序 cdata &lt;- cdata[order(cdata$sex), ] cdata #&gt; sex condition N #&gt; 1 F aspirin 5 #&gt; 3 F placebo 12 #&gt; 2 M aspirin 9 #&gt; 4 M placebo 4 # 我们也保留 before 和 after列： # 得到性别和条件下的平均影响大小 Get the average effect # size by sex and condition cdata.means &lt;- aggregate(data[c(&quot;before&quot;, &quot;after&quot;, &quot;change&quot;)], by = data[c(&quot;sex&quot;, &quot;condition&quot;)], FUN = mean) cdata.means #&gt; sex condition before after change #&gt; 1 F aspirin 11.06 7.640 -3.420 #&gt; 2 M aspirin 11.27 5.856 -5.411 #&gt; 3 F placebo 10.13 8.075 -2.058 #&gt; 4 M placebo 11.47 10.500 -0.975 # 合并数据框 cdata &lt;- merge(cdata, cdata.means) cdata #&gt; sex condition N before after change #&gt; 1 F aspirin 5 11.06 7.640 -3.420 #&gt; 2 F placebo 12 10.13 8.075 -2.058 #&gt; 3 M aspirin 9 11.27 5.856 -5.411 #&gt; 4 M placebo 4 11.47 10.500 -0.975 # 得到标准差 cdata.sd &lt;- aggregate(data[&quot;change&quot;], by = data[c(&quot;sex&quot;, &quot;condition&quot;)], FUN = sd) # 重命名列 names(cdata.sd)[names(cdata.sd) == &quot;change&quot;] &lt;- &quot;change.sd&quot; cdata.sd #&gt; sex condition change.sd #&gt; 1 F aspirin 0.8643 #&gt; 2 M aspirin 1.1308 #&gt; 3 F placebo 0.5248 #&gt; 4 M placebo 0.7805 # 合并 cdata &lt;- merge(cdata, cdata.sd) cdata #&gt; sex condition N before after change change.sd #&gt; 1 F aspirin 5 11.06 7.640 -3.420 0.8643 #&gt; 2 F placebo 12 10.13 8.075 -2.058 0.5248 #&gt; 3 M aspirin 9 11.27 5.856 -5.411 1.1308 #&gt; 4 M placebo 4 11.47 10.500 -0.975 0.7805 # 计算标准误 cdata$change.se &lt;- cdata$change.sd/sqrt(cdata$N) cdata #&gt; sex condition N before after change change.sd #&gt; 1 F aspirin 5 11.06 7.640 -3.420 0.8643 #&gt; 2 F placebo 12 10.13 8.075 -2.058 0.5248 #&gt; 3 M aspirin 9 11.27 5.856 -5.411 1.1308 #&gt; 4 M placebo 4 11.47 10.500 -0.975 0.7805 #&gt; change.se #&gt; 1 0.3865 #&gt; 2 0.1515 #&gt; 3 0.3769 #&gt; 4 0.3902 如果你有 NA 值想要跳过，设置 na.rm=TRUE: cdata.means &lt;- aggregate(data[c(&quot;before&quot;, &quot;after&quot;, &quot;change&quot;)], by = data[c(&quot;sex&quot;, &quot;condition&quot;)], FUN = mean, na.rm = TRUE) cdata.means #&gt; sex condition before after change #&gt; 1 F aspirin 11.06 7.640 -3.420 #&gt; 2 M aspirin 11.27 5.856 -5.411 #&gt; 3 F placebo 10.13 8.075 -2.058 #&gt; 4 M placebo 11.47 10.500 -0.975 6.19 数据框与列联表互换 6.19.1 问题 你想要在多种情况的一个数据框、每种情况类型计数的数据框以及一个列联表之间转换。 6.19.2 方案 这里有 3 种数据结构代表相同的信息，但是形式不同： cases: 每一行代表一个情况的数据框 ctable: 一个列联表 counts: 计数的数据框，每行代表每一种组合的数目 # 每一行代表一种情况 cases &lt;- data.frame(Sex = c(&quot;M&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;), Color = c(&quot;brown&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;brown&quot;, &quot;brown&quot;)) cases #&gt; Sex Color #&gt; 1 M brown #&gt; 2 M blue #&gt; 3 F brown #&gt; 4 F brown #&gt; 5 F brown # 一个列联表 ctable &lt;- table(cases) ctable #&gt; Color #&gt; Sex blue brown #&gt; F 0 3 #&gt; M 1 1 # 一个每种组合计数的表格 counts &lt;- data.frame(Sex = c(&quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;), Color = c(&quot;blue&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;brown&quot;), Freq = c(0, 1, 3, 1)) counts #&gt; Sex Color Freq #&gt; 1 F blue 0 #&gt; 2 M blue 1 #&gt; 3 F brown 3 #&gt; 4 M brown 1 6.19.2.1 将情况记录转为列联表 将情况记录转为列联表（上面已经展示了）： ctable &lt;- table(cases) ctable #&gt; Color #&gt; Sex blue brown #&gt; F 0 3 #&gt; M 1 1 # 如果你使用两个向量调用table函数，它将不会给维度添加名字（Sex和Color） table(cases$Sex, cases$Color) #&gt; #&gt; blue brown #&gt; F 0 3 #&gt; M 1 1 # 维度名可以通过`dnn`选项手动指定 table(cases$Sex, cases$Color, dnn = c(&quot;Sex&quot;, &quot;Color&quot;)) #&gt; Color #&gt; Sex blue brown #&gt; F 0 3 #&gt; M 1 1 6.19.2.2 将情况记录转为计数 它可以用一个数据框代表每一种组合的计数。注意它被转换并存储在 countdf 对象中： # Cases to Counts countdf &lt;- as.data.frame(table(cases)) countdf #&gt; Sex Color Freq #&gt; 1 F blue 0 #&gt; 2 M blue 1 #&gt; 3 F brown 3 #&gt; 4 M brown 1 6.19.2.3 countsToCases() 函数 这个函数使用在上面的例子中： # Convert from data frame of counts to data frame of # cases. `countcol` is the name of the column # containing the counts countsToCases &lt;- function(x, countcol = &quot;Freq&quot;) { # Get the row indices to pull from x idx &lt;- rep.int(seq_len(nrow(x)), x[[countcol]]) # Drop count column x[[countcol]] &lt;- NULL # Get the rows from x x[idx, ] } 6.19.2.4 列联表转为情况记录 countsToCases(as.data.frame(ctable)) #&gt; Sex Color #&gt; 2 M blue #&gt; 3 F brown #&gt; 3.1 F brown #&gt; 3.2 F brown #&gt; 4 M brown 注意，countsToCases() 函数定义在上面。 6.19.2.5 列联表转为计数 as.data.frame(ctable) #&gt; Sex Color Freq #&gt; 1 F blue 0 #&gt; 2 M blue 1 #&gt; 3 F brown 3 #&gt; 4 M brown 1 从这里我们可以看到上一个代码的中间效果 6.19.2.6 计数转为情况记录 countsToCases(countdf) #&gt; Sex Color #&gt; 2 M blue #&gt; 3 F brown #&gt; 3.1 F brown #&gt; 3.2 F brown #&gt; 4 M brown 这相当于是列联表转为情况记录的第二步。 6.19.2.7 计数转为列联表 xtabs(Freq ~ Sex + Color, data = countdf) #&gt; Color #&gt; Sex blue brown #&gt; F 0 3 #&gt; M 1 1 6.20 计算移动平均数 6.20.1 问题 你想要计算移动平均数。 6.20.2 解决方案 假设你的数据是带缺失值的噪声正弦波。 set.seed(993) x &lt;- 1:300 y &lt;- sin(x/20) + rnorm(300, sd = 0.1) y[251:255] &lt;- NA filter() 函数可以用来计算移动平均数。 # 绘制未平滑的数据（灰色） plot(x, y, type = &quot;l&quot;, col = grey(0.5)) # 绘制网格 grid() # 延迟平滑 当前样本和之前 19 个样本的平均数（红色） f20 &lt;- rep(1/20, 20) f20 #&gt; [1] 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 #&gt; [11] 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 y_lag &lt;- filter(y, f20, sides = 1) lines(x, y_lag, col = &quot;red&quot;) # 对称性平滑： # 计算当前样本，时间上将来样本和过去10个样本的平均数（蓝色） f21 &lt;- rep(1/21, 21) f21 #&gt; [1] 0.04762 0.04762 0.04762 0.04762 0.04762 0.04762 #&gt; [7] 0.04762 0.04762 0.04762 0.04762 0.04762 0.04762 #&gt; [13] 0.04762 0.04762 0.04762 0.04762 0.04762 0.04762 #&gt; [19] 0.04762 0.04762 0.04762 y_sym &lt;- filter(y, f21, sides = 2) lines(x, y_sym, col = &quot;blue&quot;) filter() 会在遭遇缺失值时留下空缺，就像上面图中显示的一样。 一种处理缺失值的方法是简单地忽略它，不把它包含在平均数的计算中。这个功能可以由下面的函数实现： # x: the vector n: the number of samples centered: if # FALSE, then average current sample and previous (n-1) # samples if TRUE, then average symmetrically in past # and future. (If n is even, use one more sample from # future.) movingAverage &lt;- function(x, n = 1, centered = FALSE) { if (centered) { before &lt;- floor((n - 1)/2) after &lt;- ceiling((n - 1)/2) } else { before &lt;- n - 1 after &lt;- 0 } # Track the sum and count of number of non-NA items s &lt;- rep(0, length(x)) count &lt;- rep(0, length(x)) # Add the centered data new &lt;- x # Add to count list wherever there isn&#39;t a count &lt;- count + !is.na(new) # Now replace NA_s with 0_s and add to total new[is.na(new)] &lt;- 0 s &lt;- s + new # Add the data from before i &lt;- 1 while (i &lt;= before) { # This is the vector with offset values to add new &lt;- c(rep(NA, i), x[1:(length(x) - i)]) count &lt;- count + !is.na(new) new[is.na(new)] &lt;- 0 s &lt;- s + new i &lt;- i + 1 } # Add the data from after i &lt;- 1 while (i &lt;= after) { # This is the vector with offset values to add new &lt;- c(x[(i + 1):length(x)], rep(NA, i)) count &lt;- count + !is.na(new) new[is.na(new)] &lt;- 0 s &lt;- s + new i &lt;- i + 1 } # return sum divided by count s/count } # 用比较厚的线条绘制和之前一样的图 plot(x, y, type = &quot;l&quot;, col = grey(0.5)) grid() y_lag &lt;- filter(y, rep(1/20, 20), sides = 1) lines(x, y_lag, col = &quot;red&quot;, lwd = 4) # 用红色表示延迟平均 y_sym &lt;- filter(y, rep(1/21, 21), sides = 2) lines(x, y_sym, col = &quot;blue&quot;, lwd = 4) # 用蓝色表示对称平均 # 用上面定义的函数计算延迟平均 y_lag_na.rm &lt;- movingAverage(y, 20) lines(x, y_lag_na.rm, col = &quot;green&quot;, lwd = 2) # 用上面定义的函数计算对称性平均 y_sym_na.rm &lt;- movingAverage(y, 21, TRUE) lines(x, y_sym_na.rm, col = &quot;green&quot;, lwd = 2) 6.21 窗口平滑 6.21.1 问题 你想要计算序列给定窗口长度的平均数。这是平滑数据的一种方式。 6.21.2 方案 假设你有一个数值向量并且想要找出第一个连续四个数、第二个连续四个数等等如此的平均数（就像用一个窗口在序列上移动，移动一次，计算一次）。 # 生成有22个（0-99）以内的随机数向量 set.seed(123) x &lt;- floor(runif(22) * 100) x #&gt; [1] 28 78 40 88 94 4 52 89 55 45 95 45 67 57 10 89 24 #&gt; [18] 4 32 95 88 69 # 将向量长度取整到最接近的4的倍数 newlength &lt;- ceiling(length(x)/4) * 4 newlength #&gt; [1] 24 # 给新增的数值取NA值 x[newlength] &lt;- NA x #&gt; [1] 28 78 40 88 94 4 52 89 55 45 95 45 67 57 10 89 24 #&gt; [18] 4 32 95 88 69 NA NA # 将它转换为4行的矩阵 x &lt;- matrix(x, nrow = 4) x #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 28 94 55 67 24 88 #&gt; [2,] 78 4 45 57 4 69 #&gt; [3,] 40 52 95 10 32 NA #&gt; [4,] 88 89 45 89 95 NA # 计算每一列的均值，忽略NA值 colMeans(x, na.rm = TRUE) #&gt; [1] 58.50 59.75 60.00 55.75 38.75 78.50 6.22 寻找唯一值序列 6.22.1 问题 你需要找到一个向量或者因子的唯一值。 6.22.2 方案 你可以通过在向量里迭代寻找唯一值，但这样做在 R 里是很慢的。一个比较快的方案是通过 rle() 函数： # 示例数据 v &lt;- c(&quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, NA, NA, &quot;C&quot;, &quot;C&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;) v #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; NA NA &quot;C&quot; &quot;C&quot; &quot;B&quot; #&gt; [13] &quot;C&quot; &quot;C&quot; &quot;C&quot; vr &lt;- rle(v) vr #&gt; Run Length Encoding #&gt; lengths: int [1:7] 3 4 1 1 2 1 3 #&gt; values : chr [1:7] &quot;A&quot; &quot;B&quot; NA NA &quot;C&quot; &quot;B&quot; &quot;C&quot; RLE 编码的数据能够通过 inverse.rle() 转换回到一个向量。 inverse.rle(vr) #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; NA NA &quot;C&quot; &quot;C&quot; &quot;B&quot; #&gt; [13] &quot;C&quot; &quot;C&quot; &quot;C&quot; 一个问题是每一个缺失值 NA 都会视为长度为1，即使 NA 是相邻的，不过可以通过用别的值替代 NA 来做到。对于数值变量，Inf 或者别的数字都可使用；对于字符变量，任何字符串都能使用。当然，特殊值不得以其他方式出现在向量中。 w &lt;- v w[is.na(w)] &lt;- &quot;ZZZ&quot; w #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;ZZZ&quot; #&gt; [9] &quot;ZZZ&quot; &quot;C&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; wr &lt;- rle(w) wr #&gt; Run Length Encoding #&gt; lengths: int [1:6] 3 4 2 2 1 3 #&gt; values : chr [1:6] &quot;A&quot; &quot;B&quot; &quot;ZZZ&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; # 在RLE编码数据中用NA代替ZZZ wr$values[wr$values == &quot;ZZZ&quot;] &lt;- NA wr #&gt; Run Length Encoding #&gt; lengths: int [1:6] 3 4 2 2 1 3 #&gt; values : chr [1:6] &quot;A&quot; &quot;B&quot; NA &quot;C&quot; &quot;B&quot; &quot;C&quot; w2 &lt;- inverse.rle(wr) w2 #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; NA NA &quot;C&quot; &quot;C&quot; &quot;B&quot; #&gt; [13] &quot;C&quot; &quot;C&quot; &quot;C&quot; 6.22.3 处理因子 虽然因子基本上只是带有一些关于级别信息的整数向量，但是 rle() 函数不能处理因子。解决方案是手动将因子转换为整数向量或字符向量。使用整数向量速度快，内存效率高，这对于大型数据集可能很重要，但是很难理解。使用字符向量比较慢，需要更多的内存，但是更容易理解。 # 假设这是我们要处理的向量 f &lt;- factor(v) f #&gt; [1] A A A B B B B &lt;NA&gt; &lt;NA&gt; C #&gt; [11] C B C C C #&gt; Levels: A B C # 将向量级别保存到一个新的变量 # 这个不是必须的，但是保存顺序是很有用的 f_levels &lt;- levels(f) f_levels #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; fc &lt;- as.character(f) fc[is.na(fc)] &lt;- &quot;ZZZ&quot; fc #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;ZZZ&quot; #&gt; [9] &quot;ZZZ&quot; &quot;C&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; fr &lt;- rle(fc) fr #&gt; Run Length Encoding #&gt; lengths: int [1:6] 3 4 2 2 1 3 #&gt; values : chr [1:6] &quot;A&quot; &quot;B&quot; &quot;ZZZ&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; # 在RLE编码数据中用 NA 代替 ZZZ fr$values[fr$values == &quot;ZZZ&quot;] &lt;- NA fr #&gt; Run Length Encoding #&gt; lengths: int [1:6] 3 4 2 2 1 3 #&gt; values : chr [1:6] &quot;A&quot; &quot;B&quot; NA &quot;C&quot; &quot;B&quot; &quot;C&quot; # 将RLE编码数据转换成因子 f2 &lt;- inverse.rle(fr) f2 &lt;- factor(f, levels = f_levels) f2 #&gt; [1] A A A B B B B &lt;NA&gt; &lt;NA&gt; C #&gt; [11] C B C C C #&gt; Levels: A B C 6.23 用最后一个非 NA 值填充 NA 6.23.1 问题 你想要将非 NA 值代替向量或者因子中的 NA 值。 6.23.2 方案 这段代码展示了如何填充向量中的空白。如果需要重复执行此操作，请参阅下面的函数。该函数还可以用第一个确定的值填充第一个即为NA的情况，并正确处理因子。 # 示例数据 x &lt;- c(NA, NA, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, NA, NA, &quot;C&quot;, NA, NA, NA, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, NA, NA) goodIdx &lt;- !is.na(x) goodIdx #&gt; [1] FALSE FALSE TRUE TRUE TRUE TRUE TRUE FALSE #&gt; [9] FALSE TRUE FALSE FALSE FALSE TRUE TRUE TRUE #&gt; [17] FALSE FALSE # 这些是来自x的非NA数值 # 加入领头的NA，后边会使用。用来进行索引 goodVals &lt;- c(NA, x[goodIdx]) goodVals #&gt; [1] NA &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; # 用来自输出向量的索引填充输出向量的索引 # 这些补偿了goodVals。加1是为了避免索引为0 fillIdx &lt;- cumsum(goodIdx) + 1 fillIdx #&gt; [1] 1 1 2 3 4 5 6 6 6 7 7 7 7 8 9 10 10 #&gt; [18] 10 # 原本向量的值被填充了 6.23.2.1 填充 NA 的函数 此函数执行与上面代码相同的操作。它还可以用第一个良好的值填充第一个就是NA的情况，并正确处理因子。 fillNAgaps &lt;- function(x, firstBack = FALSE) { ## 向量或因子中的 NA 被之前一个非 NA 值代替 如果 ## firstBack 为 TRUE，将会对领头的 NA 填充第一个非 NA ## 值，否则不会 ## 如果是一个因子，保存因子的水平，并转换为整数 lvls &lt;- NULL if (is.factor(x)) { lvls &lt;- levels(x) x &lt;- as.integer(x) } goodIdx &lt;- !is.na(x) # 这些是来自于x的非NA值 # 加入领头NA或者以第一个值代替，取决于firstBack参数 if (firstBack) goodVals &lt;- c(x[goodIdx][1], x[goodIdx]) else goodVals &lt;- c(NA, x[goodIdx]) # 用来自输出向量的索引填充输出向量的索引 # 这些补偿了goodVals。加1是为了避免索引为0 fillIdx &lt;- cumsum(goodIdx) + 1 x &lt;- goodVals[fillIdx] # 如果它最初是一个因子，那么将它转换回来 if (!is.null(lvls)) { x &lt;- factor(x, levels = seq_along(lvls), labels = lvls) } x } # 示例数据 x &lt;- c(NA, NA, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, NA, NA, &quot;C&quot;, NA, NA, NA, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, NA, NA) x #&gt; [1] NA NA &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; NA NA &quot;C&quot; NA NA #&gt; [13] NA &quot;A&quot; &quot;A&quot; &quot;B&quot; NA NA fillNAgaps(x) #&gt; [1] NA NA &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; #&gt; [13] &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; # 对领头的 NA 以第一个非 NA 值进行填充 fillNAgaps(x, firstBack = TRUE) #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; #&gt; [13] &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; # 因子数据也能使用 y &lt;- factor(x) y #&gt; [1] &lt;NA&gt; &lt;NA&gt; A A B B B &lt;NA&gt; &lt;NA&gt; C #&gt; [11] &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; A A B &lt;NA&gt; &lt;NA&gt; #&gt; Levels: A B C fillNAgaps(y) #&gt; [1] &lt;NA&gt; &lt;NA&gt; A A B B B B B C #&gt; [11] C C C A A B B B #&gt; Levels: A B C 6.23.2.2 注释 改编自来自于 zoo 包的 na.locf() 函数。 "],
["section-7.html", "第 7 章 统计分析 7.1 回归和相关分析 7.2 t 检验 7.3 频率检验 7.4 ANOVA 7.5 逻辑回归 7.6 变量同质性", " 第 7 章 统计分析 7.1 回归和相关分析 7.1.1 问题 你想要做线性回归或相关分析。 7.1.2 方案 要处理的一些样例数据： # 制造一些数据 X 增加（大的干扰噪声） Z 缓慢增加 构建 # Y，它与 X 变量负相关，与 X*Z 变量正相关 set.seed(955) xvar &lt;- 1:20 + rnorm(20, sd = 3) zvar &lt;- 1:20/4 + rnorm(20, sd = 2) yvar &lt;- -2 * xvar + xvar * zvar/5 + 3 + rnorm(20, sd = 4) # 通过组合已创建的向量来构建数据框 dat &lt;- data.frame(x = xvar, y = yvar, z = zvar) # 展示前 6 行 head(dat) #&gt; x y z #&gt; 1 -4.252 4.586 1.89877 #&gt; 2 1.702 -4.903 -0.82937 #&gt; 3 4.323 -4.308 -1.31283 #&gt; 4 1.781 0.205 -0.28479 #&gt; 5 11.537 -29.767 -1.27304 #&gt; 6 6.672 -10.146 -0.09459 7.1.2.1 相关系数 # 相关系数 - 默认使用 pearson 方法 cor(dat$x, dat$y) #&gt; [1] -0.7695 7.1.2.2 相关矩阵（多个变量） 同时可以对多个变量进行两两相关性分析，结果是一个 nxn 的平方矩阵或是数据框。 # 变量之间的相关矩阵 cor(dat) #&gt; x y z #&gt; x 1.0000 -0.769538 0.491699 #&gt; y -0.7695 1.000000 0.004172 #&gt; z 0.4917 0.004172 1.000000 # 保留两位小数点 round(cor(dat), 2) #&gt; x y z #&gt; x 1.00 -0.77 0.49 #&gt; y -0.77 1.00 0.00 #&gt; z 0.49 0.00 1.00 7.1.2.3 线性回归 线性回归，当 dat$x 是预测变量时，dat$y 为响应变量。这可以使用一个数据框的两列，或者是直接使用数值向量。 # 下面两个命令会显示一样的结果 fit &lt;- lm(y ~ x, data = dat) # 使用数据框的 x 列和 y 列 fit &lt;- lm(dat$y ~ dat$x) # 使用 dat$x 和 dat$y 进行拟合 fit #&gt; #&gt; Call: #&gt; lm(formula = dat$y ~ dat$x) #&gt; #&gt; Coefficients: #&gt; (Intercept) dat$x #&gt; -0.228 -1.183 # 这说明预测 y = -0.2278 - 1.1829*x 获取更详细的信息 summary(fit) #&gt; #&gt; Call: #&gt; lm(formula = dat$y ~ dat$x) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -15.892 -2.511 0.287 4.465 9.329 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) -0.228 2.632 -0.09 0.93 #&gt; dat$x -1.183 0.231 -5.11 7.3e-05 *** #&gt; --- #&gt; Signif. codes: #&gt; 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 6.51 on 18 degrees of freedom #&gt; Multiple R-squared: 0.592, Adjusted R-squared: 0.57 #&gt; F-statistic: 26.1 on 1 and 18 DF, p-value: 7.28e-05 7.1.2.4 多个预测变量的线性回归（多元线性回归） 使用 y 作为线性回归的响应变量，x 和 z 作为预测变量。 注意下面的公式没有检测 x 与 z 之间的交互效应。 # 这些都有相同的结果 fit2 &lt;- lm(y ~ x + z, data = dat) # 使用数据框的 x,y,z 列 fit2 &lt;- lm(dat$y ~ dat$x + dat$z) # 使用向量 fit2 #&gt; #&gt; Call: #&gt; lm(formula = dat$y ~ dat$x + dat$z) #&gt; #&gt; Coefficients: #&gt; (Intercept) dat$x dat$z #&gt; -1.38 -1.56 1.86 summary(fit2) #&gt; #&gt; Call: #&gt; lm(formula = dat$y ~ dat$x + dat$z) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -7.97 -3.19 -1.21 3.85 7.52 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) -1.382 1.988 -0.70 0.4964 #&gt; dat$x -1.564 0.198 -7.88 4.5e-07 *** #&gt; dat$z 1.858 0.475 3.91 0.0011 ** #&gt; --- #&gt; Signif. codes: #&gt; 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 4.86 on 17 degrees of freedom #&gt; Multiple R-squared: 0.785, Adjusted R-squared: 0.76 #&gt; F-statistic: 31.1 on 2 and 17 DF, p-value: 2.1e-06 7.1.2.4.1 交互效应 如何合适地构建多元线性回归并且检验交互效应非常复杂，这里不作讲述。这里我们仅仅用 x 和 z 变量以及它们之间的交互效应拟合模型。 想要构建 x 与 z 之间的交互效应模型，需要添加 x:z 项。我们也可以使用公式 x*z 来代表 x+z+x:z 。 # 下面两个公式等效 fit3 &lt;- lm(y ~ x * z, data = dat) fit3 &lt;- lm(y ~ x + z + x:z, data = dat) fit3 #&gt; #&gt; Call: #&gt; lm(formula = y ~ x + z + x:z, data = dat) #&gt; #&gt; Coefficients: #&gt; (Intercept) x z x:z #&gt; 2.282 -2.131 -0.107 0.208 summary(fit3) #&gt; #&gt; Call: #&gt; lm(formula = y ~ x + z + x:z, data = dat) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -5.305 -3.600 0.393 2.138 8.396 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 2.2820 2.2006 1.04 0.315 #&gt; x -2.1311 0.2741 -7.78 8e-07 *** #&gt; z -0.1068 0.8482 -0.13 0.901 #&gt; x:z 0.2081 0.0787 2.64 0.018 * #&gt; --- #&gt; Signif. codes: #&gt; 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 4.18 on 16 degrees of freedom #&gt; Multiple R-squared: 0.85, Adjusted R-squared: 0.822 #&gt; F-statistic: 30.3 on 3 and 16 DF, p-value: 7.76e-07 7.2 t 检验 7.2.1 问题 你想要检验来自两个总体的样本是否有不同的均值（显著性差异），或者检验从一个总体抽取的样本均值和理论均值有显著性差异。 7.2.2 方案 7.2.2.1 样本数据 我们将使用内置的 sleep 数据集。 sleep #&gt; extra group ID #&gt; 1 0.7 1 1 #&gt; 2 -1.6 1 2 #&gt; 3 -0.2 1 3 #&gt; 4 -1.2 1 4 #&gt; 5 -0.1 1 5 #&gt; 6 3.4 1 6 #&gt; 7 3.7 1 7 #&gt; 8 0.8 1 8 #&gt; 9 0.0 1 9 #&gt; 10 2.0 1 10 #&gt; 11 1.9 2 1 #&gt; 12 0.8 2 2 #&gt; 13 1.1 2 3 #&gt; 14 0.1 2 4 #&gt; 15 -0.1 2 5 #&gt; 16 4.4 2 6 #&gt; 17 5.5 2 7 #&gt; 18 1.6 2 8 #&gt; 19 4.6 2 9 #&gt; 20 3.4 2 10 我们将制造 sleep 数据的宽格式版本；下面我们将看看如何处理长格式和宽格式的数据。 sleep_wide &lt;- data.frame(ID = 1:10, group1 = sleep$extra[1:10], group2 = sleep$extra[11:20]) sleep_wide #&gt; ID group1 group2 #&gt; 1 1 0.7 1.9 #&gt; 2 2 -1.6 0.8 #&gt; 3 3 -0.2 1.1 #&gt; 4 4 -1.2 0.1 #&gt; 5 5 -0.1 -0.1 #&gt; 6 6 3.4 4.4 #&gt; 7 7 3.7 5.5 #&gt; 8 8 0.8 1.6 #&gt; 9 9 0.0 4.6 #&gt; 10 10 2.0 3.4 7.2.2.2 比较两组：独立双样本 t 检验 假设有两组独立样本（我们这里忽略ID变量）。 t.test() 函数能够操作像 sleep 这样的长格式数据——一列记录测量值，一列指定组别；或者操作两个单独的向量。 # Welch t 检验 t.test(extra ~ group, sleep) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: extra by group #&gt; t = -1.9, df = 18, p-value = 0.08 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -3.3655 0.2055 #&gt; sample estimates: #&gt; mean in group 1 mean in group 2 #&gt; 0.75 2.33 # 2 个独立的向量 t.test(sleep_wide$group1, sleep_wide$group2) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: sleep_wide$group1 and sleep_wide$group2 #&gt; t = -1.9, df = 18, p-value = 0.08 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -3.3655 0.2055 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 0.75 2.33 默认，t 检验不假设有方差齐性（或称作方差同质）。默认的不是 Student t 检验而是使用了 Welch t 检验。注意 Welch t 检验结果中 df=17.776，这是因为对不同质方差进行了校正。要使用 Student t 检验的话，设置 var.equal=TRUE 。 # Student t 检验 t.test(extra ~ group, sleep, var.equal = TRUE) #&gt; #&gt; Two Sample t-test #&gt; #&gt; data: extra by group #&gt; t = -1.9, df = 18, p-value = 0.08 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -3.3639 0.2039 #&gt; sample estimates: #&gt; mean in group 1 mean in group 2 #&gt; 0.75 2.33 # 针对宽数据相同的操作 (2个分离的向量) t.test(sleep_wide$group1, sleep_wide$group2, var.equal = TRUE) #&gt; #&gt; Two Sample t-test #&gt; #&gt; data: sleep_wide$group1 and sleep_wide$group2 #&gt; t = -1.9, df = 18, p-value = 0.08 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -3.3639 0.2039 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 0.75 2.33 7.2.2.3 配对样本t检验 你也可以使用配对样本 t 检验比较配对的数据。数据配对是指你可能有对某种药物治疗前后有观测值或者不同治疗有配对的研究对象。 再次说明，t-test() 函数可以用于有分组变量的数据框或者两个向量。它依赖相对位置来决定配对。如果你使用有分组变量的长格式数据，group 1 的第一行与 group 2 的第一行配对。确保数据排序好并且不存在缺失值是非常重要的；否则配对可以丢弃。这种情况中，我们能通过 group 和 ID 变量进行排序来确保顺序是一样的。 # 按 group 和 ID排序 sleep &lt;- sleep[order(sleep$group, sleep$ID), ] # 配对 t-test t.test(extra ~ group, sleep, paired = TRUE) #&gt; #&gt; Paired t-test #&gt; #&gt; data: extra by group #&gt; t = -4.1, df = 9, p-value = 0.003 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -2.4599 -0.7001 #&gt; sample estimates: #&gt; mean of the differences #&gt; -1.58 # 针对宽数据相同的操作 (2个分离的向量) t.test(sleep_wide$group1, sleep_wide$group2, paired = TRUE) #&gt; #&gt; Paired t-test #&gt; #&gt; data: sleep_wide$group1 and sleep_wide$group2 #&gt; t = -4.1, df = 9, p-value = 0.003 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -2.4599 -0.7001 #&gt; sample estimates: #&gt; mean of the differences #&gt; -1.58 配对 t 检验等价于检测是否配对的观察值的总体均值是否为 0 。 t.test(sleep_wide$group1 - sleep_wide$group2, mu = 0, var.equal = TRUE) #&gt; #&gt; One Sample t-test #&gt; #&gt; data: sleep_wide$group1 - sleep_wide$group2 #&gt; t = -4.1, df = 9, p-value = 0.003 #&gt; alternative hypothesis: true mean is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -2.4599 -0.7001 #&gt; sample estimates: #&gt; mean of x #&gt; -1.58 7.2.2.4 与期望的总体均值进行比较：单样本 t 检验 假设你想要检测是否 extra 列的数据抽取自总体均值为0的总体（这里忽略 group 与 ID 列）。 t.test(sleep$extra, mu = 0) #&gt; #&gt; One Sample t-test #&gt; #&gt; data: sleep$extra #&gt; t = 3.4, df = 19, p-value = 0.003 #&gt; alternative hypothesis: true mean is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 0.5956 2.4844 #&gt; sample estimates: #&gt; mean of x #&gt; 1.54 7.3 频率检验 7.3.1 问题 你有分类数据然后想要检验是否这些数据值的频数分布是否与预期不符，或者是否组间的频数分布有（显著）差异。 7.3.2 方案 频数检验通常解决两类问题： 频数分布与预期或者理论的分布（比如 50% 的 yes，50% 的 no ）符合吗？（拟合优度检验） 两组或多组之间的频率分布有差异吗？（独立检验） 通常用于解决这样问题的统计检验方法，分为精确检验与近似检验两种。 期望分布 比较组别 精确 精确二项检验 Fisher精确检验 近似 卡方拟合优度 独立卡方检验 注意：精确二项检验仅能用于有两个水平的单变量。Fisher 精确检验仅能用于二维列联表（比如，当存在一个独立变量和一个非独立变量时它可以使用；但不能用于两个独立变量和一个非独立变量的情况）。 想要检验配对或被试内效应，我们可以使用 McNemar 检验。使用该检验必须满足存在两个水平的独立变量和两个水平的非独立变量。 想要检验有重复测量的两个变量独立性，我们可以使用 Cochran-Mantel-Haenszel 检验。 假设你有下面的数据，其中每一行代表一个记录： data &lt;- read.table(header = TRUE, text = &quot; condition result control 0 control 0 control 0 control 0 treatment 1 control 0 control 0 treatment 0 treatment 1 control 1 treatment 1 treatment 1 treatment 1 treatment 1 treatment 0 control 0 control 1 control 0 control 1 treatment 0 treatment 1 treatment 0 treatment 0 control 0 treatment 1 control 0 control 0 treatment 1 treatment 0 treatment 1 &quot;) 相比于以记录的数据框存储，你的数据可能是计数的数据框，或者是一个列联表。 7.3.2.1 拟合优度检验 （期望频率） 7.3.2.1.1 卡方检验 想要检验假设：结果列 result（忽略条件 condition ）中的两个值在总体中几乎相等（50% - 50%）。 # 为result列创建列联表，包含 0 和 1 两个值 注意，&#39;0&#39; # 和 &#39;1&#39; 是列名而不是实际的值 ct &lt;- table(data$result) ct #&gt; #&gt; 0 1 #&gt; 17 13 # 也可以手动创建表格 ct &lt;- matrix(c(17, 13), ncol = 2) colnames(ct) &lt;- c(&quot;0&quot;, &quot;1&quot;) # 执行卡方检验 chisq.test(ct) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: ct #&gt; X-squared = 0.53, df = 1, p-value = 0.5 想要检验有不同期望频率的样本（比如下面一个 0.75，一个 0.25 ）： # 概率表 —— 和必须为 1 pt &lt;- c(0.75, 0.25) chisq.test(ct, p = pt) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: ct #&gt; X-squared = 5.4, df = 1, p-value = 0.02 如果你想要从检验结果中提取信息，可以将结果保存进一个变量，然后用 str() 函数查看变量信息，接着把你想要的部分取出来。例如： chi_res &lt;- chisq.test(ct, p = pt) # 查看所有组分 str(chi_res) #&gt; List of 9 #&gt; $ statistic: Named num 5.38 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;X-squared&quot; #&gt; $ parameter: Named num 1 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;df&quot; #&gt; $ p.value : num 0.0204 #&gt; $ method : chr &quot;Chi-squared test for given probabilities&quot; #&gt; $ data.name: chr &quot;ct&quot; #&gt; $ observed : num [1:2] 17 13 #&gt; $ expected : num [1:2] 22.5 7.5 #&gt; $ residuals: num [1:2] -1.16 2.01 #&gt; $ stdres : num [1:2] -2.32 2.32 #&gt; - attr(*, &quot;class&quot;)= chr &quot;htest&quot; # 获取卡方值 chi_res$statistic #&gt; X-squared #&gt; 5.378 # 获取p值 chi_res$p.value #&gt; [1] 0.02039 7.3.2.1.2 精确二项检验 精确二项检验仅能用于存在两个值的单变量数据。 ct &lt;- table(data$result) ct #&gt; #&gt; 0 1 #&gt; 17 13 binom.test(ct, p = 0.5) #&gt; #&gt; Exact binomial test #&gt; #&gt; data: ct #&gt; number of successes = 17, number of trials = 30, #&gt; p-value = 0.6 #&gt; alternative hypothesis: true probability of success is not equal to 0.5 #&gt; 95 percent confidence interval: #&gt; 0.3743 0.7454 #&gt; sample estimates: #&gt; probability of success #&gt; 0.5667 # 使用 75% 的期望概率——注意 1 在第二列，所以只需要令 p # = 0.25 binom.test(ct, p = 0.25) #&gt; #&gt; Exact binomial test #&gt; #&gt; data: ct #&gt; number of successes = 17, number of trials = 30, #&gt; p-value = 2e-04 #&gt; alternative hypothesis: true probability of success is not equal to 0.25 #&gt; 95 percent confidence interval: #&gt; 0.3743 0.7454 #&gt; sample estimates: #&gt; probability of success #&gt; 0.5667 如果你想要从检验结果中提取信息，可以将结果保存进一个变量，然后用 str() 函数查看变量信息，接着把你想要的部分取出来。例如： bin_res &lt;- binom.test(ct, p = 0.25) # 字符串格式化后查看信息 str(bin_res) #&gt; List of 9 #&gt; $ statistic : Named num 17 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;number of successes&quot; #&gt; $ parameter : Named num 30 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;number of trials&quot; #&gt; $ p.value : Named num 0.000216 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;0&quot; #&gt; $ conf.int : num [1:2] 0.374 0.745 #&gt; ..- attr(*, &quot;conf.level&quot;)= num 0.95 #&gt; $ estimate : Named num 0.567 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;probability of success&quot; #&gt; $ null.value : Named num 0.25 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;probability of success&quot; #&gt; $ alternative: chr &quot;two.sided&quot; #&gt; $ method : chr &quot;Exact binomial test&quot; #&gt; $ data.name : chr &quot;ct&quot; #&gt; - attr(*, &quot;class&quot;)= chr &quot;htest&quot; # 获取 p 值 bin_res$p.value #&gt; 0 #&gt; 0.0002157 # 获取 95% 置信区间 bin_res$conf.int #&gt; [1] 0.3743 0.7454 #&gt; attr(,&quot;conf.level&quot;) #&gt; [1] 0.95 7.3.2.2 独立检验（比较组间） 7.3.2.2.1 卡方检验 想要检验控制和处理组结果的频数差异，使用二维列联表。 ct &lt;- table(data$condition, data$result) ct #&gt; #&gt; 0 1 #&gt; control 11 3 #&gt; treatment 6 10 chisq.test(ct) #&gt; #&gt; Pearson&#39;s Chi-squared test with Yates&#39; #&gt; continuity correction #&gt; #&gt; data: ct #&gt; X-squared = 3.6, df = 1, p-value = 0.06 chisq.test(ct, correct = FALSE) #&gt; #&gt; Pearson&#39;s Chi-squared test #&gt; #&gt; data: ct #&gt; X-squared = 5.1, df = 1, p-value = 0.02 7.3.2.2.2 Fisher 精确检验 对于小样本而言 Fisher 精确检验更为适合。小样本的 2x2 列表非常典型，样本更多、更复杂的列表计算强度非常大。当然，用R进行比较复杂的计算也是没有太大问题的。 ct &lt;- table(data$condition, data$result) ct #&gt; #&gt; 0 1 #&gt; control 11 3 #&gt; treatment 6 10 fisher.test(ct) #&gt; #&gt; Fisher&#39;s Exact Test for Count Data #&gt; #&gt; data: ct #&gt; p-value = 0.03 #&gt; alternative hypothesis: true odds ratio is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0.9669 45.5550 #&gt; sample estimates: #&gt; odds ratio #&gt; 5.714 7.3.2.2.3 Cochran-Mantel-Haenszel 检验 Cochran-Mantel-Haenszel 检验 （或称为 Mantel-Haenszel 检验)）用于检验重复测量两离散变量的独立性。通常使用 2x2xK 列表表示，K是测量条件的次数。比如你想要指导是否一个处理（C vs. D）是否影响了恢复的概率（yes or no）。假设该处理一天监控测量三次——早上、中午和晚上，而你想要你的检验能够控制它。那么你可以使用 CMH 检验对 2x2x3 列联表进行操作，第三个变量是你想要控制的变量。 R 中的 CMH 检验可以处理比 2x2xK 维度更高的数据，例如你处理 3x3xK 列联表。 在接下来的例子里有三个变量：Location、Allele 和 Habitat。问题是——当控制 location 变量时，Allel（94 或非 94）和 Habitat（marine 或 estuarine）两个变量是否独立。 fish &lt;- read.table(header = TRUE, text = &quot; Location Allele Habitat Count tillamook 94 marine 56 tillamook 94 estuarine 69 tillamook non-94 marine 40 tillamook non-94 estuarine 77 yaquina 94 marine 61 yaquina 94 estuarine 257 yaquina non-94 marine 57 yaquina non-94 estuarine 301 alsea 94 marine 73 alsea 94 estuarine 65 alsea non-94 marine 71 alsea non-94 estuarine 79 umpqua 94 marine 71 umpqua 94 estuarine 48 umpqua non-94 marine 55 umpqua non-94 estuarine 48 &quot;) 注意上面的数据是计数的数据框，而不是像之前的例子是记录的数据框。这里我们使用 xtabs() 函数将它转换为列联表。 # 制造一个三维的列联表，最后一个变量时要控制的 Location # 变量 ct &lt;- xtabs(Count ~ Allele + Habitat + Location, data = fish) ct #&gt; , , Location = alsea #&gt; #&gt; Habitat #&gt; Allele estuarine marine #&gt; 94 65 73 #&gt; non-94 79 71 #&gt; #&gt; , , Location = tillamook #&gt; #&gt; Habitat #&gt; Allele estuarine marine #&gt; 94 69 56 #&gt; non-94 77 40 #&gt; #&gt; , , Location = umpqua #&gt; #&gt; Habitat #&gt; Allele estuarine marine #&gt; 94 48 71 #&gt; non-94 48 55 #&gt; #&gt; , , Location = yaquina #&gt; #&gt; Habitat #&gt; Allele estuarine marine #&gt; 94 257 61 #&gt; non-94 301 57 # 以扁平化显示 ftable(ct) #&gt; Location alsea tillamook umpqua yaquina #&gt; Allele Habitat #&gt; 94 estuarine 65 69 48 257 #&gt; marine 73 56 71 61 #&gt; non-94 estuarine 79 77 48 301 #&gt; marine 71 40 55 57 # 按指定方式进行变量输出 ftable(ct, row.vars = c(&quot;Location&quot;, &quot;Allele&quot;), col.vars = &quot;Habitat&quot;) #&gt; Habitat estuarine marine #&gt; Location Allele #&gt; alsea 94 65 73 #&gt; non-94 79 71 #&gt; tillamook 94 69 56 #&gt; non-94 77 40 #&gt; umpqua 94 48 71 #&gt; non-94 48 55 #&gt; yaquina 94 257 61 #&gt; non-94 301 57 mantelhaen.test(ct) #&gt; #&gt; Mantel-Haenszel chi-squared test with #&gt; continuity correction #&gt; #&gt; data: ct #&gt; Mantel-Haenszel X-squared = 5, df = 1, p-value = #&gt; 0.02 #&gt; alternative hypothesis: true common odds ratio is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0.6006 0.9593 #&gt; sample estimates: #&gt; common odds ratio #&gt; 0.759 根据检验结果，当控制 Location 变量时 Allele 与 Habitat 变量存在相关（p = 0.025）。 注意列联表的前两个维度处理是一致的，所以前后顺序变化都不会影响结果。而最后一个变量变化会导致结果的不同，下面是一个实例。 # 下面两个看似不同的列联表，实际检验结果相同 ct.1 &lt;- xtabs(Count ~ Habitat + Allele + Location, data = fish) ct.2 &lt;- xtabs(Count ~ Allele + Habitat + Location, data = fish) mantelhaen.test(ct.1) #&gt; #&gt; Mantel-Haenszel chi-squared test with #&gt; continuity correction #&gt; #&gt; data: ct.1 #&gt; Mantel-Haenszel X-squared = 5, df = 1, p-value = #&gt; 0.02 #&gt; alternative hypothesis: true common odds ratio is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0.6006 0.9593 #&gt; sample estimates: #&gt; common odds ratio #&gt; 0.759 mantelhaen.test(ct.2) #&gt; #&gt; Mantel-Haenszel chi-squared test with #&gt; continuity correction #&gt; #&gt; data: ct.2 #&gt; Mantel-Haenszel X-squared = 5, df = 1, p-value = #&gt; 0.02 #&gt; alternative hypothesis: true common odds ratio is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0.6006 0.9593 #&gt; sample estimates: #&gt; common odds ratio #&gt; 0.759 # 把 Allele 放到最后，结果不同了 ct.3 &lt;- xtabs(Count ~ Location + Habitat + Allele, data = fish) ct.4 &lt;- xtabs(Count ~ Habitat + Location + Allele, data = fish) mantelhaen.test(ct.3) #&gt; #&gt; Cochran-Mantel-Haenszel test #&gt; #&gt; data: ct.3 #&gt; Cochran-Mantel-Haenszel M^2 = 168, df = 3, #&gt; p-value &lt;2e-16 mantelhaen.test(ct.4) #&gt; #&gt; Cochran-Mantel-Haenszel test #&gt; #&gt; data: ct.4 #&gt; Cochran-Mantel-Haenszel M^2 = 168, df = 3, #&gt; p-value &lt;2e-16 # 把 Habitat 放最后，结果也不同 ct.5 &lt;- xtabs(Count ~ Allele + Location + Habitat, data = fish) ct.6 &lt;- xtabs(Count ~ Location + Allele + Habitat, data = fish) mantelhaen.test(ct.5) #&gt; #&gt; Cochran-Mantel-Haenszel test #&gt; #&gt; data: ct.5 #&gt; Cochran-Mantel-Haenszel M^2 = 2, df = 3, p-value #&gt; = 0.6 mantelhaen.test(ct.6) #&gt; #&gt; Cochran-Mantel-Haenszel test #&gt; #&gt; data: ct.6 #&gt; Cochran-Mantel-Haenszel M^2 = 2, df = 3, p-value #&gt; = 0.6 7.3.2.3 McNemar 检验 McNemar 检验概念上是频数数据的一个被试内检验。例如，假设你想要检验是否一个处理增加了一个人对某个问题反应「yes」的概率，而且你只有每个人处理前和处理后的数据。标准的卡方检验将不合适，因为它假设了组别是独立的。取而代之，我们可以使用 McNemar 检验。该检验仅适用于当存在一个独立变量的两次测量时。用于 McNemar 的列联表与用于卡方检验的非常相似，但结构上是不同的。 假设你有下面的数据。每个对象有处理前和后的反应。 data &lt;- read.table(header = TRUE, text = &quot; subject time result 1 pre 0 1 post 1 2 pre 1 2 post 1 3 pre 0 3 post 1 4 pre 1 4 post 0 5 pre 1 5 post 1 6 pre 0 6 post 1 7 pre 0 7 post 1 8 pre 0 8 post 1 9 pre 0 9 post 1 10 pre 1 10 post 1 11 pre 0 11 post 0 12 pre 1 12 post 1 13 pre 0 13 post 1 14 pre 0 14 post 0 15 pre 0 15 post 1 &quot;) library(tidyr) data_wide &lt;- spread(data, time, result) data_wide #&gt; subject post pre #&gt; 1 1 1 0 #&gt; 2 2 1 1 #&gt; 3 3 1 0 #&gt; 4 4 0 1 #&gt; 5 5 1 1 #&gt; 6 6 1 0 #&gt; 7 7 1 0 #&gt; 8 8 1 0 #&gt; 9 9 1 0 #&gt; 10 10 1 1 #&gt; 11 11 0 0 #&gt; 12 12 1 1 #&gt; 13 13 1 0 #&gt; 14 14 0 0 #&gt; 15 15 1 0 接下来从数据框的 pre 和 post 列生成列联表： ct &lt;- table(data_wide[, c(&quot;pre&quot;, &quot;post&quot;)]) ct #&gt; post #&gt; pre 0 1 #&gt; 0 2 8 #&gt; 1 1 4 # 下面是用于标准卡方检验的列联表，注意差别 table(data[, c(&quot;time&quot;, &quot;result&quot;)]) #&gt; result #&gt; time 0 1 #&gt; post 3 12 #&gt; pre 10 5 执行检验： mcnemar.test(ct) #&gt; #&gt; McNemar&#39;s Chi-squared test with continuity #&gt; correction #&gt; #&gt; data: ct #&gt; McNemar&#39;s chi-squared = 4, df = 1, p-value = #&gt; 0.05 对于小样本，它会使用连续校正。我们可以使用精确校正的 McNemar 检验替换这种校正方式，前者更加的精确，可通过 exact2x2 包获取。 library(exact2x2) #&gt; Loading required package: exactci #&gt; Loading required package: ssanv mcnemar.exact(ct) #&gt; #&gt; Exact McNemar test (with central confidence #&gt; intervals) #&gt; #&gt; data: ct #&gt; b = 8, c = 1, p-value = 0.04 #&gt; alternative hypothesis: true odds ratio is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 1.073 354.981 #&gt; sample estimates: #&gt; odds ratio #&gt; 8 7.4 ANOVA 7.4.1 问题 你想要使用 ANOVA 比较多组之间的差异。 7.4.2 方案 假设这是你的数据： data &lt;- read.table(header = TRUE, text = &quot; subject sex age before after 1 F old 9.5 7.1 2 M old 10.3 11.0 3 M old 7.5 5.8 4 F old 12.4 8.8 5 M old 10.2 8.6 6 M old 11.0 8.0 7 M young 9.1 3.0 8 F young 7.9 5.2 9 F old 6.6 3.4 10 M young 7.7 4.0 11 M young 9.4 5.3 12 M old 11.6 11.3 13 M young 9.9 4.6 14 F young 8.6 6.4 15 F young 14.3 13.5 16 F old 9.2 4.7 17 M young 9.8 5.1 18 F old 9.9 7.3 19 F young 13.0 9.5 20 M young 10.2 5.4 21 M young 9.0 3.7 22 F young 7.9 6.2 23 M old 10.1 10.0 24 M young 9.0 1.7 25 M young 8.6 2.9 26 M young 9.4 3.2 27 M young 9.7 4.7 28 M young 9.3 4.9 29 F young 10.7 9.8 30 M old 9.3 9.4 &quot;) # 确保 subject # 列是一个因子变量，这样不会当作连续变量对待 data$subject &lt;- factor(data$subject) 7.4.2.1 单因素 ANOVA 分析 # 单因素： 独立变量: sex 依赖变量: before aov1 &lt;- aov(before ~ sex, data = data) summary(aov1) #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; sex 1 1.5 1.53 0.57 0.46 #&gt; Residuals 28 74.7 2.67 # 显示均值 model.tables(aov1, &quot;means&quot;) #&gt; Tables of means #&gt; Grand mean #&gt; #&gt; 9.703 #&gt; #&gt; sex #&gt; F M #&gt; 10 9.532 #&gt; rep 11 19.000 7.4.2.2 双因素 ANOVA 分析 # 2x2: 独立变量: sex 独立变量: age 依赖变量: after # 下面两种调用方式等价： aov2 &lt;- aov(after ~ sex * age, data = data) aov2 &lt;- aov(after ~ sex + age + sex:age, data = data) summary(aov2) #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; sex 1 16.1 16.1 4.04 0.0550 . #&gt; age 1 39.0 39.0 9.79 0.0043 ** #&gt; sex:age 1 89.6 89.6 22.51 6.6e-05 *** #&gt; Residuals 26 103.5 4.0 #&gt; --- #&gt; Signif. codes: #&gt; 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # 显示均值 model.tables(aov2, &quot;means&quot;) #&gt; Tables of means #&gt; Grand mean #&gt; #&gt; 6.483 #&gt; #&gt; sex #&gt; F M #&gt; 7.445 5.926 #&gt; rep 11.000 19.000 #&gt; #&gt; age #&gt; old young #&gt; 7.874 5.556 #&gt; rep 12.000 18.000 #&gt; #&gt; sex:age #&gt; age #&gt; sex old young #&gt; F 6.260 8.433 #&gt; rep 5.000 6.000 #&gt; M 9.157 4.042 #&gt; rep 7.000 12.000 7.4.2.3 Tukey HSD post-hoc 检验 TukeyHSD(aov2) #&gt; Tukey multiple comparisons of means #&gt; 95% family-wise confidence level #&gt; #&gt; Fit: aov(formula = after ~ sex + age + sex:age, data = data) #&gt; #&gt; $sex #&gt; diff lwr upr p adj #&gt; M-F -1.519 -3.073 0.03475 0.055 #&gt; #&gt; $age #&gt; diff lwr upr p adj #&gt; young-old -2.318 -3.846 -0.7893 0.0044 #&gt; #&gt; $`sex:age` #&gt; diff lwr upr p adj #&gt; M:old-F:old 2.8971 -0.308 6.1022 0.0870 #&gt; F:young-F:old 2.1733 -1.141 5.4878 0.2966 #&gt; M:young-F:old -2.2183 -5.132 0.6953 0.1833 #&gt; F:young-M:old -0.7238 -3.769 2.3215 0.9139 #&gt; M:young-M:old -5.1155 -7.719 -2.5122 0.0001 #&gt; M:young-F:young -4.3917 -7.129 -1.6548 0.0009 7.4.3 有受试内变量的 ANOVAs 对于有受试内变量的 ANOVA 分析，数据必须满足为长格式。上面提到的数据都是宽格式，所以我们需要先转换数据格式（参见长宽格式互相转换）。 同样地，有受试内变量的 ANOVA 分析需要一个识别列。当前数据里是 subject 列。识别变量必须是一个因子，如果是数值类型，函数会解析错误导致不能正常工作。 library(tidyr) # 原始数据 subject sex age before after 1 F old 9.5 7.1 # 2 M old 10.3 11.0 3 M old 7.5 5.8 # 转换为长格式 data_long &lt;- gather(data, time, value, before:after) # Look at first few rows head(data_long) #&gt; subject sex age time value #&gt; 1 1 F old before 9.5 #&gt; 2 2 M old before 10.3 #&gt; 3 3 M old before 7.5 #&gt; 4 4 F old before 12.4 #&gt; 5 5 M old before 10.2 #&gt; 6 6 M old before 11.0 # 确保subject列是一个因子 data_long$subject &lt;- factor(data_long$subject) 7.4.3.1 单因素被试内 ANOVA 首先，像上面展示的一样将数据从宽格式转换到长格式并确保 subject 列是因子变量。如果 subject 是数值向量，而不是因子，结果将会出错。 # 独立变量 (被试内): time 依赖变量: value aov_time &lt;- aov(value ~ time + Error(subject/time), data = data_long) summary(aov_time) #&gt; #&gt; Error: subject #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; Residuals 29 261 9.01 #&gt; #&gt; Error: subject:time #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; time 1 155.5 155.5 71.4 2.6e-09 *** #&gt; Residuals 29 63.1 2.2 #&gt; --- #&gt; Signif. codes: #&gt; 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # 因为一些原因，下面的代码不工作 model.tables(aov_time, &quot;means&quot;) #&gt; Tables of means #&gt; Grand mean #&gt; #&gt; 8.093 #&gt; #&gt; time #&gt; time #&gt; after before #&gt; 6.483 9.703 7.4.3.2 混合设计 ANOVA 首先，像上面展示的一样将数据从宽格式转换到长格式并确保 subject 列是因子变量。 # 2x2 mixed: 独立变量（被试间） : age 独立变量（被试内） # : time 依赖变量: value aov_age_time &lt;- aov(value ~ age * time + Error(subject/time), data = data_long) summary(aov_age_time) #&gt; #&gt; Error: subject #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; age 1 24.4 24.44 2.89 0.1 #&gt; Residuals 28 236.8 8.46 #&gt; #&gt; Error: subject:time #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; time 1 155.5 155.5 98.1 1.2e-10 *** #&gt; age:time 1 18.8 18.8 11.8 0.0018 ** #&gt; Residuals 28 44.4 1.6 #&gt; --- #&gt; Signif. codes: #&gt; 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # 因为数据不平衡，下面代码不会工作 model.tables(aov_age_time, &quot;means&quot;) #&gt; Tables of means #&gt; Grand mean #&gt; #&gt; 8.093 #&gt; #&gt; age #&gt; old young #&gt; 8.875 7.572 #&gt; rep 24.000 36.000 #&gt; #&gt; time #&gt; after before #&gt; 6.483 9.703 #&gt; rep 30.000 30.000 #&gt; #&gt; age:time #&gt; time #&gt; age after before #&gt; old 7.950 9.800 #&gt; rep 12.000 12.000 #&gt; young 5.506 9.639 #&gt; rep 18.000 18.000 7.4.3.3 更多被试内变量的 ANOVA 下面这些例子使用的不是上面的数据，但可以解释怎么进行相应的处理。首先，像上面展示的一样将数据从宽格式转换到长格式并确保 subject 列是因子变量。 # # 两个被试内变量 aov.ww &lt;- aov(y ~ w1*w2 + # Error(subject/(w1*w2)), data=data_long) # # 1个被试间变量，两个被试内变量 aov.bww &lt;- aov(y ~ # b1*w1*w2 + Error(subject/(w1*w2)) + b1, # data=data_long) # 两个被试间变量，一个被试内变量 # aov.bww &lt;- aov(y ~ b1*b2*w1 + Error(subject/(w1)) + # b1*b2, data=data_long) 7.5 逻辑回归 7.5.1 问题 你想要运用逻辑回归分析。 7.5.2 方案 逻辑回归典型使用于当存在一个离散的响应变量（比如赢和输）和一个与响应变量（也称为结果变量、因变量）的概率或几率相关联的连续预测变量的情况。它也适用于有多个预测变量的分类预测。 假设我们从内置的 mtcars 数据集的一部分开始，像下面这样，我们将 vs 作为响应变量，mpg 作为一个连续的预测变量，am 作为一个分类（离散）的预测变量。 data(mtcars) dat &lt;- subset(mtcars, select = c(mpg, am, vs)) dat #&gt; mpg am vs #&gt; Mazda RX4 21.0 1 0 #&gt; Mazda RX4 Wag 21.0 1 0 #&gt; Datsun 710 22.8 1 1 #&gt; Hornet 4 Drive 21.4 0 1 #&gt; Hornet Sportabout 18.7 0 0 #&gt; Valiant 18.1 0 1 #&gt; Duster 360 14.3 0 0 #&gt; Merc 240D 24.4 0 1 #&gt; Merc 230 22.8 0 1 #&gt; Merc 280 19.2 0 1 #&gt; Merc 280C 17.8 0 1 #&gt; Merc 450SE 16.4 0 0 #&gt; Merc 450SL 17.3 0 0 #&gt; Merc 450SLC 15.2 0 0 #&gt; Cadillac Fleetwood 10.4 0 0 #&gt; Lincoln Continental 10.4 0 0 #&gt; Chrysler Imperial 14.7 0 0 #&gt; Fiat 128 32.4 1 1 #&gt; Honda Civic 30.4 1 1 #&gt; Toyota Corolla 33.9 1 1 #&gt; Toyota Corona 21.5 0 1 #&gt; Dodge Challenger 15.5 0 0 #&gt; AMC Javelin 15.2 0 0 #&gt; Camaro Z28 13.3 0 0 #&gt; Pontiac Firebird 19.2 0 0 #&gt; Fiat X1-9 27.3 1 1 #&gt; Porsche 914-2 26.0 1 0 #&gt; Lotus Europa 30.4 1 1 #&gt; Ford Pantera L 15.8 1 0 #&gt; Ferrari Dino 19.7 1 0 #&gt; Maserati Bora 15.0 1 0 #&gt; Volvo 142E 21.4 1 1 7.5.2.1 连续预测变量，离散响应变量 如果数据集有一个离散变量和一个连续变量，并且连续变量离散变量概率的预测器（就像直线回归中 x 可以预测 y 一样，只不过是两个连续变量，而逻辑回归中被预测的是离散变量），逻辑回归可能适用。 下面例子中，mpg 是连续预测变量，vs 是离散响应变量。. # 执行逻辑回归 —— 下面两种方式等效 # logit是二项分布家族的默认模型 logr_vm &lt;- glm(vs ~ mpg, data = dat, family = binomial) logr_vm &lt;- glm(vs ~ mpg, data = dat, family = binomial(link = &quot;logit&quot;)) 查看模型信息： # 输出模型信息 logr_vm #&gt; #&gt; Call: glm(formula = vs ~ mpg, family = binomial(link = &quot;logit&quot;), data = dat) #&gt; #&gt; Coefficients: #&gt; (Intercept) mpg #&gt; -8.83 0.43 #&gt; #&gt; Degrees of Freedom: 31 Total (i.e. Null); 30 Residual #&gt; Null Deviance: 43.9 #&gt; Residual Deviance: 25.5 AIC: 29.5 # 汇总该模型的更多信息 summary(logr_vm) #&gt; #&gt; Call: #&gt; glm(formula = vs ~ mpg, family = binomial(link = &quot;logit&quot;), data = dat) #&gt; #&gt; Deviance Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -2.213 -0.512 -0.228 0.640 1.698 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error z value Pr(&gt;|z|) #&gt; (Intercept) -8.833 3.162 -2.79 0.0052 ** #&gt; mpg 0.430 0.158 2.72 0.0066 ** #&gt; --- #&gt; Signif. codes: #&gt; 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; (Dispersion parameter for binomial family taken to be 1) #&gt; #&gt; Null deviance: 43.860 on 31 degrees of freedom #&gt; Residual deviance: 25.533 on 30 degrees of freedom #&gt; AIC: 29.53 #&gt; #&gt; Number of Fisher Scoring iterations: 6 7.5.2.1.1 画图 我们可以使用 ggplot2 或者基本图形绘制数据和逻辑回归结果。 library(ggplot2) ggplot(dat, aes(x = mpg, y = vs)) + geom_point() + stat_smooth(method = &quot;glm&quot;, method.args = list(family = &quot;binomial&quot;), se = FALSE) par(mar = c(4, 4, 1, 1)) # 减少一些边缘使得图形显示更好些 plot(dat$mpg, dat$vs) curve(predict(logr_vm, data.frame(mpg = x), type = &quot;response&quot;), add = TRUE) 7.5.2.2 离散预测变量，离散响应变量 这个跟上面的操作大致相同，am 是一个离散的预测变量，vs 是一个离散的响应变量。 # 执行逻辑回归 logr_va &lt;- glm(vs ~ am, data = dat, family = binomial) # 打印模型信息 logr_va #&gt; #&gt; Call: glm(formula = vs ~ am, family = binomial, data = dat) #&gt; #&gt; Coefficients: #&gt; (Intercept) am #&gt; -0.539 0.693 #&gt; #&gt; Degrees of Freedom: 31 Total (i.e. Null); 30 Residual #&gt; Null Deviance: 43.9 #&gt; Residual Deviance: 43 AIC: 47 # 汇总模型的信息 summary(logr_va) #&gt; #&gt; Call: #&gt; glm(formula = vs ~ am, family = binomial, data = dat) #&gt; #&gt; Deviance Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -1.244 -0.959 -0.959 1.113 1.413 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error z value Pr(&gt;|z|) #&gt; (Intercept) -0.539 0.476 -1.13 0.26 #&gt; am 0.693 0.732 0.95 0.34 #&gt; #&gt; (Dispersion parameter for binomial family taken to be 1) #&gt; #&gt; Null deviance: 43.860 on 31 degrees of freedom #&gt; Residual deviance: 42.953 on 30 degrees of freedom #&gt; AIC: 46.95 #&gt; #&gt; Number of Fisher Scoring iterations: 4 7.5.2.2.1 画图 尽管图形可能会比连续预测变量的信息少，我们还是可以使用 ggplot2 或者基本图形绘制逻辑数据和回归结果。因为数据点大致在 4 个位置，我们可以使用抖动点避免叠加。 library(ggplot2) ggplot(dat, aes(x = am, y = vs)) + geom_point(shape = 1, position = position_jitter(width = 0.05, height = 0.05)) + stat_smooth(method = &quot;glm&quot;, method.args = list(family = &quot;binomial&quot;), se = FALSE) par(mar = c(4, 4, 1, 1)) # 减少一些边缘使得图形显示更好些 plot(jitter(dat$am, 0.2), jitter(dat$vs, 0.2)) curve(predict(logr_va, data.frame(am = x), type = &quot;response&quot;), add = TRUE) 7.5.2.3 连续和离散预测变量，离散响应变量 这跟先前的例子相似，这里 mpg 是连续预测变量，am 是离散预测变量，vs 是离散响应变量。 logr_vma &lt;- glm(vs ~ mpg + am, data = dat, family = binomial) logr_vma #&gt; #&gt; Call: glm(formula = vs ~ mpg + am, family = binomial, data = dat) #&gt; #&gt; Coefficients: #&gt; (Intercept) mpg am #&gt; -12.705 0.681 -3.007 #&gt; #&gt; Degrees of Freedom: 31 Total (i.e. Null); 29 Residual #&gt; Null Deviance: 43.9 #&gt; Residual Deviance: 20.6 AIC: 26.6 summary(logr_vma) #&gt; #&gt; Call: #&gt; glm(formula = vs ~ mpg + am, family = binomial, data = dat) #&gt; #&gt; Deviance Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -2.0589 -0.4454 -0.0876 0.3333 1.6841 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error z value Pr(&gt;|z|) #&gt; (Intercept) -12.705 4.625 -2.75 0.006 ** #&gt; mpg 0.681 0.252 2.70 0.007 ** #&gt; am -3.007 1.599 -1.88 0.060 . #&gt; --- #&gt; Signif. codes: #&gt; 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; (Dispersion parameter for binomial family taken to be 1) #&gt; #&gt; Null deviance: 43.860 on 31 degrees of freedom #&gt; Residual deviance: 20.646 on 29 degrees of freedom #&gt; AIC: 26.65 #&gt; #&gt; Number of Fisher Scoring iterations: 6 7.5.2.4 有交互项的多个预测变量 当有多个预测变量时我们可能需要检验交互项。交互项可以单独指定，像 a + b + c + a:b + b:c + a:b:c，或者它们可以使用 a * b *c 自动展开（这两种等效）。如果只是想指定部分可能的交互项，比如 a 与 c 有交互项，使用 a + b + c + a:c。 # 执行逻辑回归，下面两种方式等效 logr_vmai &lt;- glm(vs ~ mpg * am, data = dat, family = binomial) logr_vmai &lt;- glm(vs ~ mpg + am + mpg:am, data = dat, family = binomial) logr_vmai #&gt; #&gt; Call: glm(formula = vs ~ mpg + am + mpg:am, family = binomial, data = dat) #&gt; #&gt; Coefficients: #&gt; (Intercept) mpg am mpg:am #&gt; -20.478 1.108 10.106 -0.664 #&gt; #&gt; Degrees of Freedom: 31 Total (i.e. Null); 28 Residual #&gt; Null Deviance: 43.9 #&gt; Residual Deviance: 19.1 AIC: 27.1 summary(logr_vmai) #&gt; #&gt; Call: #&gt; glm(formula = vs ~ mpg + am + mpg:am, family = binomial, data = dat) #&gt; #&gt; Deviance Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -1.7057 -0.3112 -0.0482 0.2804 1.5560 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error z value Pr(&gt;|z|) #&gt; (Intercept) -20.478 10.553 -1.94 0.052 . #&gt; mpg 1.108 0.577 1.92 0.055 . #&gt; am 10.106 11.910 0.85 0.396 #&gt; mpg:am -0.664 0.624 -1.06 0.288 #&gt; --- #&gt; Signif. codes: #&gt; 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; (Dispersion parameter for binomial family taken to be 1) #&gt; #&gt; Null deviance: 43.860 on 31 degrees of freedom #&gt; Residual deviance: 19.125 on 28 degrees of freedom #&gt; AIC: 27.12 #&gt; #&gt; Number of Fisher Scoring iterations: 7 7.6 变量同质性 7.6.1 问题 你想要（精确）检验样本的方差同质性（同方差，方差齐性）。许多统计检验假设总体同方差。 7.6.2 方案 有许多检验方差同质性的方式，下面列出三种： Bartlett’s test - 如果数据服从正态分布，这是最好地检验方法。该方法对非正态数据非常敏感，如果数据不是正态的很可能返回假阳性的结果。 Levene’s test - 数据偏离正态性时比 Bartlett 检验更稳定（鲁棒性更好），内置于 car 包 Fligner-Killeen test - 这是一个非参数检验，数据偏离正态是非常稳定适用。 对于所有的检验，零假设为总体方差相同（同质；不是相等的意思）；备择假设是至少两组样本（总体方差）不同。 7.6.2.1 样例数据 这里的例子使用了 InsectSprays 和 ToothGrowth 数据集。InsectSprays 数据集有一个独立变量，而 ToothGrowth 数据集有两个独立变量。 head(InsectSprays) #&gt; count spray #&gt; 1 10 A #&gt; 2 7 A #&gt; 3 20 A #&gt; 4 14 A #&gt; 5 14 A #&gt; 6 12 A tg &lt;- ToothGrowth tg$dose &lt;- factor(tg$dose) # Treat this column as a factor, not numeric head(tg) #&gt; len supp dose #&gt; 1 4.2 VC 0.5 #&gt; 2 11.5 VC 0.5 #&gt; 3 7.3 VC 0.5 #&gt; 4 5.8 VC 0.5 #&gt; 5 6.4 VC 0.5 #&gt; 6 10.0 VC 0.5 快速绘制数据集的箱线图： plot(count ~ spray, data = InsectSprays) plot(len ~ interaction(dose, supp), data = ToothGrowth) 初一看好像数据集的方差都不同质，但这需要像下面一样进行合适的检验。 7.6.2.2 Bartlett 检验 有一个独立变量： bartlett.test(count ~ spray, data = InsectSprays) #&gt; #&gt; Bartlett test of homogeneity of variances #&gt; #&gt; data: count by spray #&gt; Bartlett&#39;s K-squared = 26, df = 5, p-value = #&gt; 9e-05 有多个独立变量，必须使用 interaction() 函数将这些独立变量包裹为含所有因子组合的单个变量。如果不适应，那么会得到错误的自由度，因而 p 值也将是错误的。 bartlett.test(len ~ interaction(supp, dose), data = ToothGrowth) #&gt; #&gt; Bartlett test of homogeneity of variances #&gt; #&gt; data: len by interaction(supp, dose) #&gt; Bartlett&#39;s K-squared = 6.9, df = 5, p-value = #&gt; 0.2 bartlett.test(len ~ dose, data = ToothGrowth) #&gt; #&gt; Bartlett test of homogeneity of variances #&gt; #&gt; data: len by dose #&gt; Bartlett&#39;s K-squared = 0.67, df = 2, p-value = #&gt; 0.7 7.6.2.3 Levene 检验 leveneTest() 函数是 car 包的一部分。 有一个独立变量： library(car) #&gt; Loading required package: carData leveneTest(count ~ spray, data = InsectSprays) #&gt; Levene&#39;s Test for Homogeneity of Variance (center = median) #&gt; Df F value Pr(&gt;F) #&gt; group 5 3.82 0.0042 ** #&gt; 66 #&gt; --- #&gt; Signif. codes: #&gt; 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 有两个独立变量。注意这里 interaction() 函数不需要，因为该函数用于其他两个检验。 leveneTest(len ~ supp * dose, data = tg) #&gt; Levene&#39;s Test for Homogeneity of Variance (center = median) #&gt; Df F value Pr(&gt;F) #&gt; group 5 1.71 0.15 #&gt; 54 7.6.2.4 Fligner-Killeen 检验 有一个独立变量： fligner.test(count ~ spray, data = InsectSprays) #&gt; #&gt; Fligner-Killeen test of homogeneity of #&gt; variances #&gt; #&gt; data: count by spray #&gt; Fligner-Killeen:med chi-squared = 14, df = 5, #&gt; p-value = 0.01 当处理多个独立变量时，这个 fligner.test() 函数有跟 bartlett.test() 相同的行为。必须使用 interaction() 函数。 fligner.test(len ~ interaction(supp, dose), data = ToothGrowth) #&gt; #&gt; Fligner-Killeen test of homogeneity of #&gt; variances #&gt; #&gt; data: len by interaction(supp, dose) #&gt; Fligner-Killeen:med chi-squared = 7.7, df = 5, #&gt; p-value = 0.2 fligner.test(len ~ dose, data = ToothGrowth) #&gt; #&gt; Fligner-Killeen test of homogeneity of #&gt; variances #&gt; #&gt; data: len by dose #&gt; Fligner-Killeen:med chi-squared = 1.4, df = 2, #&gt; p-value = 0.5 "],
["section-8.html", "第 8 章 标准绘图 8.1 直方图和密度图 8.2 散点图 8.3 箱线图 8.4 QQ 图", " 第 8 章 标准绘图 8.1 直方图和密度图 8.1.1 问题 你想要绘制一个直方图或密度图。 8.1.2 方案 样例数据：两个分别包含200个数据点的向量： set.seed(1234) rating &lt;- rnorm(200) head(rating) #&gt; [1] -1.2071 0.2774 1.0844 -2.3457 0.4291 0.5061 rating2 &lt;- rnorm(200, mean = 0.8) head(rating2) #&gt; [1] 1.2852 1.4968 0.9855 1.5007 1.1117 1.5605 当可视化含多个组别的数据时，一些绘图方法通常需要一个数据框：一列给分组变量，一列给测量值。 # 创建一列用于显示数据的组别 cond &lt;- factor(rep(c(&quot;A&quot;, &quot;B&quot;), each = 200)) data &lt;- data.frame(cond, rating = c(rating, rating2)) head(data) #&gt; cond rating #&gt; 1 A -1.2071 #&gt; 2 A 0.2774 #&gt; 3 A 1.0844 #&gt; 4 A -2.3457 #&gt; 5 A 0.4291 #&gt; 6 A 0.5061 # 直方图 hist(rating) # 使用8个箱子（这仅仅是近似 - # 它会把边界放在一个比较好的近似值上） 让箱子呈现淡蓝色 # #CCCCFF # 相比于计数，这里让面积为1，即显示比例(freq=FALSE) hist(rating, breaks = 8, col = &quot;#CCCCFF&quot;, freq = FALSE) # 每0.6一个刻度 boundaries &lt;- seq(-3, 3.6, by = 0.6) boundaries #&gt; [1] -3.0 -2.4 -1.8 -1.2 -0.6 0.0 0.6 1.2 1.8 2.4 #&gt; [11] 3.0 3.6 hist(rating, breaks = boundaries) # 核密度图 plot(density(rating)) 8.1.2.1 多个组别的核密度图 代码来自： http://onertipaday.blogspot.com/2007/09/plotting-two-or-more-overlapping.html plot.multi.dens &lt;- function(s) { junk.x = NULL junk.y = NULL for (i in 1:length(s)) { junk.x = c(junk.x, density(s[[i]])$x) junk.y = c(junk.y, density(s[[i]])$y) } xr &lt;- range(junk.x) yr &lt;- range(junk.y) plot(density(s[[1]]), xlim = xr, ylim = yr, main = &quot;&quot;) for (i in 1:length(s)) { lines(density(s[[i]]), xlim = xr, ylim = yr, col = i) } } # 下面函数的输入必须是一个数值列表 plot.multi.dens(list(rating, rating2)) sm 包也引入了一种绘制多个密度图的方式，输入数据必须是数据框。 library(sm) #&gt; Warning in fun(libname, pkgname): couldn&#39;t connect to #&gt; display &quot;/private/tmp/com.apple.launchd.aGFOp8QcsU/ #&gt; org.macosforge.xquartz:0&quot; #&gt; Package &#39;sm&#39;, version 2.2-5.6: type help(sm) for summary information sm.density.compare(data$rating, data$cond) # 添加一个图例 (颜色编号从2往上升) legend(&quot;topright&quot;, levels(data$cond), fill = 2 + (0:nlevels(data$cond))) 8.2 散点图 8.2.1 问题 你想要创建一个散点图。 8.2.2 方案 假设下面是你的数据： set.seed(955) # 给数据添加一些随机噪声 dat &lt;- data.frame(xvar = 1:20 + rnorm(20, sd = 3), yvar = 1:20 + rnorm(20, sd = 3), zvar = 1:20 + rnorm(20, sd = 3)) head(dat) #&gt; xvar yvar zvar #&gt; 1 -4.252 3.47316 -2.97807 #&gt; 2 1.702 0.00594 -1.16183 #&gt; 3 4.323 -0.09425 4.85517 #&gt; 4 1.781 2.07281 4.65079 #&gt; 5 11.537 1.21544 -0.06614 #&gt; 6 6.672 3.60811 6.24350 8.2.2.1 基本的散点图 # 使用向量 xvar 和 yvar 绘制点图 plot(dat$xvar, dat$yvar) # 跟上一句代码一致，但这里是用公式实现 plot(yvar ~ xvar, dat) # 添加一条回归线 fitline &lt;- lm(dat$yvar ~ dat$xvar) abline(fitline) 8.2.2.2 散点图矩阵 如果你想要比较多个变量，可以创建一个散点图矩阵。 # 一个散点图矩阵 plot(dat[, 1:3]) # 添加回归线 在对角添加histogram/boxplot/density/qqplot library(car) #&gt; Loading required package: carData scatterplotMatrix(dat[, 1:3], diagonal = &quot;histogram&quot;, smooth = FALSE) #&gt; Warning in applyDefaults(diagonal, defaults = #&gt; list(method = &quot;adaptiveDensity&quot;), : unnamed diag #&gt; arguments, will be ignored 想要查看对应的相关矩阵，查看回归和相关分析。 想要可视化相关矩阵，查看相关矩阵。 8.3 箱线图 8.3.1 问题 你想要绘制一个箱线图。 8.3.2 方案 该方案教你如何快速地使用标准绘图方法绘制简单的箱线图。 这里的例子使用 ToothGrowth 数据集，它有两个独立变量以及一个依赖变量。 head(ToothGrowth) #&gt; len supp dose #&gt; 1 4.2 VC 0.5 #&gt; 2 11.5 VC 0.5 #&gt; 3 7.3 VC 0.5 #&gt; 4 5.8 VC 0.5 #&gt; 5 6.4 VC 0.5 #&gt; 6 10.0 VC 0.5 在不同 supp 和 dose 条件下，变量 len 的箱线图: boxplot(len ~ supp, data = ToothGrowth) # 即使 `dose` 是一个数值型变量，`boxplot` # 也会将其转换为因子 boxplot(len ~ dose, data = ToothGrowth) 组合 supp 和 dose 不同水平（即交互项）下 len 的箱线图 boxplot(len ~ interaction(dose, supp), data = ToothGrowth) 注意 plot() 除了添加了横轴标签和不会自动将数值变量转换为因子变量，它与 boxplot() 有非常相似的输出。 plot(len ~ interaction(dose, supp), data = ToothGrowth) 8.4 QQ 图 8.4.1 问题 你想要对你自己的数据分布与其他的分布进行比较。这常用语检查是否一个样本是否服从正态分布，以及两个样本是抽取自同一分布。 8.4.2 方案 假设这是你的数据： set.seed(183) # 正态分布的数值 x &lt;- rnorm(80, mean = 50, sd = 5) # 均匀分布的数值 z &lt;- runif(80) # 比较用rnorm()抽样的数据分布与正态分布的差异 qqnorm(x) qqline(x) # 比较数据的4次幂分布与正态分布的差异 qqnorm(x^4) qqline(x^4) # 比较均匀分布抽取的数据与正态分布的差异 qqnorm(z) qqline(z) "],
["ggplot2.html", "第 9 章 ggplot2 9.1 条形图与线图 9.2 绘制均值和误差线 9.3 分布图 9.4 散点图 9.5 标题 9.6 坐标轴 9.7 图例 9.8 线条 9.9 分面 9.10 多图 9.11 颜色", " 第 9 章 ggplot2 9.1 条形图与线图 9.1.1 问题 你想要创建基本的条形图与线图 9.1.2 方案 想要使用 ggplot2 绘制图形，数据必须是一个数据框，而且必须是长格式。 9.1.2.1 基本图形，离散 x-axis 使用条形图，条形的高度通常代表这种不同的东西： 每一组事件的计数，通过 stat_bin() 指定，ggplot2 默认使用该选项 数据集中某一列的值，通过 stat_identity() 指定 x 轴 高度含义 名称 连续 计数 直方图 离散 计数 条形图 连续 数值 条形图 离散 数值 条形图 9.1.2.1.1 有值的条形图 这里有一些样例数据 (抽自 reshape2 包的 tips 数据集): dat &lt;- data.frame(time = factor(c(&quot;Lunch&quot;, &quot;Dinner&quot;), levels = c(&quot;Lunch&quot;, &quot;Dinner&quot;)), total_bill = c(14.89, 17.23)) dat #&gt; time total_bill #&gt; 1 Lunch 14.89 #&gt; 2 Dinner 17.23 # 导入 ggplot2 分析包 library(ggplot2) 在这些例子中，条形的高度代表数据框某一列的值，所以使用 stat=&quot;identity&quot; 而不是默认的 stat=&quot;bin&quot;。 这里使用的映射变量为： time: x-axis 和填充颜色 total_bill: y-axis # 非常基本的条形图 ggplot(data = dat, aes(x = time, y = total_bill)) + geom_bar(stat = &quot;identity&quot;) # 按时间填充颜色 ggplot(data = dat, aes(x = time, y = total_bill, fill = time)) + geom_bar(stat = &quot;identity&quot;) ## 这和上面是一样的结果 ggplot(data=dat, aes(x=time, ## y=total_bill)) + geom_bar(aes(fill=time), ## stat=&#39;identity&#39;) 添加黑色的边框线 ggplot(data = dat, aes(x = time, y = total_bill, fill = time)) + geom_bar(colour = &quot;black&quot;, stat = &quot;identity&quot;) # 没有图例，因为这个信息是多余的 ggplot(data = dat, aes(x = time, y = total_bill, fill = time)) + geom_bar(colour = &quot;black&quot;, stat = &quot;identity&quot;) + guides(fill = FALSE) 一个理想的条形图可能是下面这样的： # 添加题目，缩小箱宽，填充颜色，改变轴标签 ggplot(data = dat, aes(x = time, y = total_bill, fill = time)) + geom_bar(colour = &quot;black&quot;, fill = &quot;#DD8888&quot;, width = 0.8, stat = &quot;identity&quot;) + guides(fill = FALSE) + xlab(&quot;Time of day&quot;) + ylab(&quot;Total bill&quot;) + ggtitle(&quot;Average bill for 2 people&quot;) 查看颜色获取更多关于颜色的信息。 9.1.2.1.2 计数的条形图 在下面例子中，条形高度代表事件的计数。 我们直接使用 reshape2 的 tips 数据集。 library(reshape2) # 查看头几行 head(tips) #&gt; total_bill tip sex smoker day time size #&gt; 1 16.99 1.01 Female No Sun Dinner 2 #&gt; 2 10.34 1.66 Male No Sun Dinner 3 #&gt; 3 21.01 3.50 Male No Sun Dinner 3 #&gt; 4 23.68 3.31 Male No Sun Dinner 2 #&gt; 5 24.59 3.61 Female No Sun Dinner 4 #&gt; 6 25.29 4.71 Male No Sun Dinner 4 想要得到一个计数的条形图，不要映射变量到 y，使用 stat=&quot;bin&quot; (默认就是这个) 而不是 stat=&quot;identity&quot;: # 计数的条形图 ggplot(data = tips, aes(x = day)) + geom_bar(stat = &quot;count&quot;) ## 和上面等同, 因为 stat=&#39;bin&#39; 是默认 ggplot(data=tips, ## aes(x=day)) + geom_bar() 9.1.2.2 线图 对于线图，数据点必须分组从而 R 知道怎么连接这些点。如果只有一组的话，非常简单，设定 group=1 即可，如果是多组，需要设定分组变量。 下面是使用的映射变量： time: x 轴 total_bill: y 轴 # 基本的线图 ggplot(data = dat, aes(x = time, y = total_bill, group = 1)) + geom_line() ## 与上面结果一致 ggplot(data=dat, aes(x=time, ## y=total_bill)) + geom_line(aes(group=1)) 添加点 ggplot(data = dat, aes(x = time, y = total_bill, group = 1)) + geom_line() + geom_point() # 改变线和点的颜色 # 改变线的类型和点的类型，用更粗的线、更大的点 # 用红色填充点 ggplot(data = dat, aes(x = time, y = total_bill, group = 1)) + geom_line(colour = &quot;red&quot;, linetype = &quot;dashed&quot;, size = 1.5) + geom_point(colour = &quot;red&quot;, size = 4, shape = 21, fill = &quot;white&quot;) 理想的线图可能像下面这样： # 设定 y 轴的范围 改变轴标签 ggplot(data = dat, aes(x = time, y = total_bill, group = 1)) + geom_line() + geom_point() + expand_limits(y = 0) + xlab(&quot;Time of day&quot;) + ylab(&quot;Total bill&quot;) + ggtitle(&quot;Average bill for 2 people&quot;) 查看颜色获取更多关于颜色的信息。查看形状与线形 获取更多相关内容。 9.1.3 有更多变量的图 下面这个数据将用于接下来的例子 dat1 &lt;- data.frame(sex = factor(c(&quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;)), time = factor(c(&quot;Lunch&quot;, &quot;Dinner&quot;, &quot;Lunch&quot;, &quot;Dinner&quot;), levels = c(&quot;Lunch&quot;, &quot;Dinner&quot;)), total_bill = c(13.53, 16.81, 16.24, 17.42)) dat1 #&gt; sex time total_bill #&gt; 1 Female Lunch 13.53 #&gt; 2 Female Dinner 16.81 #&gt; 3 Male Lunch 16.24 #&gt; 4 Male Dinner 17.42 9.1.3.1 条形图 变量映射： time: x 轴 sex: 颜色填充 total_bill: y 轴 # 堆积条形图 -- 不常用 ggplot(data = dat1, aes(x = time, y = total_bill, fill = sex)) + geom_bar(stat = &quot;identity&quot;) # 条形图，x 轴是 time, 颜色填充是 sex ggplot(data = dat1, aes(x = time, y = total_bill, fill = sex)) + geom_bar(stat = &quot;identity&quot;, position = position_dodge()) ggplot(data = dat1, aes(x = time, y = total_bill, fill = sex)) + geom_bar(stat = &quot;identity&quot;, position = position_dodge(), colour = &quot;black&quot;) # 改变颜色 ggplot(data = dat1, aes(x = time, y = total_bill, fill = sex)) + geom_bar(stat = &quot;identity&quot;, position = position_dodge(), colour = &quot;black&quot;) + scale_fill_manual(values = c(&quot;#999999&quot;, &quot;#E69F00&quot;)) 改变映射是非常容易的： # 条形图，x 轴是性别，颜色是时间 ggplot(data = dat1, aes(x = sex, y = total_bill, fill = time)) + geom_bar(stat = &quot;identity&quot;, position = position_dodge(), colour = &quot;black&quot;) 查看颜色获取更多关于颜色的信息。 9.1.3.2 线图 变量映射： time: x 轴 sex: 线的颜色 total_bill: y 轴 想要绘制多条线，必须指定分组变量，否则所有点都将通过一条线进行连接。在这个例子中，我们希望通过性别来进行分组。 # 基本的带点线图 ggplot(data = dat1, aes(x = time, y = total_bill, group = sex)) + geom_line() + geom_point() # 将性别映射到颜色 ggplot(data = dat1, aes(x = time, y = total_bill, group = sex, colour = sex)) + geom_line() + geom_point() # 映射性别到不同的点类型 ggplot(data = dat1, aes(x = time, y = total_bill, group = sex, shape = sex)) + geom_line() + geom_point() # 使用更粗的线、更大的点 ggplot(data = dat1, aes(x = time, y = total_bill, group = sex, shape = sex)) + geom_line(size = 1.5) + geom_point(size = 3, fill = &quot;white&quot;) + scale_shape_manual(values = c(22, 21)) 更改颜色和线型变量的映射非常容易： ggplot(data = dat1, aes(x = sex, y = total_bill, group = time, shape = time, color = time)) + geom_line() + geom_point() 查看颜色获取更多关于颜色的信息。查看形状与线形获取更多相关内容。 9.1.3.3 完成的例子 完成的例子可能像下面这样： # 一个条形图 ggplot(data=dat1, aes(x=time, y=total_bill, fill=sex)) + geom_bar(colour=&quot;black&quot;, stat=&quot;identity&quot;, position=position_dodge(), size=.3) + # 更粗的线 scale_fill_hue(name=&quot;Sex of payer&quot;) + # 设定图例标题 xlab(&quot;Time of day&quot;) + ylab(&quot;Total bill&quot;) + # 设定轴标签 ggtitle(&quot;Average bill for 2 people&quot;) + # 设定题目 theme_bw() # 一个线图 ggplot(data=dat1, aes(x=time, y=total_bill, group=sex, shape=sex, colour=sex)) + geom_line(aes(linetype=sex), size=1) + # 按性别设定线型 geom_point(size=3, fill=&quot;white&quot;) + # 使用更大的点，并用颜色填充 expand_limits(y=0) + # 将 0 包含仅 y 轴 scale_colour_hue(name=&quot;Sex of payer&quot;, # 设定图例标题 l=30) + # 使用更深的颜色 (lightness=30) scale_shape_manual(name=&quot;Sex of payer&quot;, values=c(22,21)) + # scale_linetype_discrete(name=&quot;Sex of payer&quot;) + xlab(&quot;Time of day&quot;) + ylab(&quot;Total bill&quot;) + # 设定轴标签 ggtitle(&quot;Average bill for 2 people&quot;) + # 设定标题 theme_bw() + theme(legend.position=c(.7, .4)) # 图例的位置 为了保证上图的图例一致，必须指定 3 次。至于为何如此，查看图例。 9.1.4 使用数值 x-axis 当 x 轴上的变量是数字时，有时需要将其视为连续变量，有时需要将其视为分类变量。在该数据集中，剂量应该是值为 0.5, 1.0 和 2.0 的数值变量。作图时，将这些值视为相同类别可能很有用。 datn &lt;- read.table(header = TRUE, text = &quot; supp dose length OJ 0.5 13.23 OJ 1.0 22.70 OJ 2.0 26.06 VC 0.5 7.98 VC 1.0 16.77 VC 2.0 26.14 &quot;) 来自 ToothGrowth 数据集。 9.1.4.1 x-axis 作为连续变量 一个简单的图形可能会将剂量放在 x 轴，这种方式可以绘制一个线图。 ggplot(data = datn, aes(x = dose, y = length, group = supp, colour = supp)) + geom_line() + geom_point() 9.1.4.2 x-axis 作为分类变量 首先，我们要将该变量转换为因子。 # 拷贝数据框并将它转换为因子 datn2 &lt;- datn datn2$dose &lt;- factor(datn2$dose) ggplot(data = datn2, aes(x = dose, y = length, group = supp, colour = supp)) + geom_line() + geom_point() # 使用原始的数据框，但使用 factor 函数在绘图时转换 ggplot(data = datn, aes(x = factor(dose), y = length, group = supp, colour = supp)) + geom_line() + geom_point() 当连续值作为分类变量使用时，也可以绘制条形图。 ggplot(data = datn2, aes(x = dose, y = length, fill = supp)) + geom_bar(stat = &quot;identity&quot;, position = position_dodge()) ggplot(data = datn, aes(x = factor(dose), y = length, fill = supp)) + geom_bar(stat = &quot;identity&quot;, position = position_dodge()) 9.2 绘制均值和误差线 9.2.1 问题 你想要为一个数据集绘制均值的误差线。 9.2.2 方案 想要用 ggplot2 绘制图形，数据必须是数据框形式，而且是长格式（相对于宽格式）。如果你的数据需要重构，请参考长宽格式转换获取更多信息。 9.2.2.1 助手函数 如果你处理的仅仅是组间变量，那么 summarySE() 是你代码中唯一需要使用的函数。如果你的数据里有组内变量，并且你想要矫正误差线使得组间的变异被移除，就像 Loftus and Masson (1994) 里的那样，那么 normDataWithin() 和 summarySEwithin() 这两个函数必须加入你的代码中，然后调用 summarySEwithin() 函数进行计算。 ## Gives count, mean, standard deviation, standard error ## of the mean, and confidence interval (default 95%). ## data: a data frame. measurevar: the name of a column ## that contains the variable to be summariezed ## groupvars: a vector containing names of columns that ## contain grouping variables na.rm: a boolean that ## indicates whether to ignore NA&#39;s conf.interval: the ## percent range of the confidence interval (default is ## 95%) summarySE &lt;- function(data = NULL, measurevar, groupvars = NULL, na.rm = FALSE, conf.interval = 0.95, .drop = TRUE) { library(plyr) # New version of length which can handle NA&#39;s: if # na.rm==T, don&#39;t count them length2 &lt;- function(x, na.rm = FALSE) { if (na.rm) sum(!is.na(x)) else length(x) } # This does the summary. For each group&#39;s data frame, # return a vector with N, mean, and sd datac &lt;- ddply(data, groupvars, .drop = .drop, .fun = function(xx, col) { c(N = length2(xx[[col]], na.rm = na.rm), mean = mean(xx[[col]], na.rm = na.rm), sd = sd(xx[[col]], na.rm = na.rm)) }, measurevar) # Rename the &#39;mean&#39; column datac &lt;- rename(datac, c(mean = measurevar)) datac$se &lt;- datac$sd/sqrt(datac$N) # Calculate standard error of the mean # Confidence interval multiplier for standard error # Calculate t-statistic for confidence interval: e.g., # if conf.interval is .95, use .975 (above/below), and # use df=N-1 ciMult &lt;- qt(conf.interval/2 + 0.5, datac$N - 1) datac$ci &lt;- datac$se * ciMult return(datac) } ## Norms the data within specified groups in a data ## frame; it normalizes each subject (identified by ## idvar) so that they have the same mean, within each ## group specified by betweenvars. data: a data frame. ## idvar: the name of a column that identifies each ## subject (or matched subjects) measurevar: the name of ## a column that contains the variable to be summariezed ## betweenvars: a vector containing names of columns that ## are between-subjects variables na.rm: a boolean that ## indicates whether to ignore NA&#39;s normDataWithin &lt;- function(data = NULL, idvar, measurevar, betweenvars = NULL, na.rm = FALSE, .drop = TRUE) { library(plyr) # Measure var on left, idvar + between vars on right of # formula. data.subjMean &lt;- ddply(data, c(idvar, betweenvars), .drop = .drop, .fun = function(xx, col, na.rm) { c(subjMean = mean(xx[, col], na.rm = na.rm)) }, measurevar, na.rm) # Put the subject means with original data data &lt;- merge(data, data.subjMean) # Get the normalized data in a new column measureNormedVar &lt;- paste(measurevar, &quot;_norm&quot;, sep = &quot;&quot;) data[, measureNormedVar] &lt;- data[, measurevar] - data[, &quot;subjMean&quot;] + mean(data[, measurevar], na.rm = na.rm) # Remove this subject mean column data$subjMean &lt;- NULL return(data) } ## Summarizes data, handling within-subjects variables by ## removing inter-subject variability. It will still ## work if there are no within-S variables. Gives count, ## un-normed mean, normed mean (with same between-group ## mean), standard deviation, standard error of the mean, ## and confidence interval. If there are within-subject ## variables, calculate adjusted values using method from ## Morey (2008). data: a data frame. measurevar: the ## name of a column that contains the variable to be ## summariezed betweenvars: a vector containing names of ## columns that are between-subjects variables ## withinvars: a vector containing names of columns that ## are within-subjects variables idvar: the name of a ## column that identifies each subject (or matched ## subjects) na.rm: a boolean that indicates whether to ## ignore NA&#39;s conf.interval: the percent range of the ## confidence interval (default is 95%) summarySEwithin &lt;- function(data = NULL, measurevar, betweenvars = NULL, withinvars = NULL, idvar = NULL, na.rm = FALSE, conf.interval = 0.95, .drop = TRUE) { # Ensure that the betweenvars and withinvars are factors factorvars &lt;- vapply(data[, c(betweenvars, withinvars), drop = FALSE], FUN = is.factor, FUN.VALUE = logical(1)) if (!all(factorvars)) { nonfactorvars &lt;- names(factorvars)[!factorvars] message(&quot;Automatically converting the following non-factors to factors: &quot;, paste(nonfactorvars, collapse = &quot;, &quot;)) data[nonfactorvars] &lt;- lapply(data[nonfactorvars], factor) } # Get the means from the un-normed data datac &lt;- summarySE(data, measurevar, groupvars = c(betweenvars, withinvars), na.rm = na.rm, conf.interval = conf.interval, .drop = .drop) # Drop all the unused columns (these will be calculated # with normed data) datac$sd &lt;- NULL datac$se &lt;- NULL datac$ci &lt;- NULL # Norm each subject&#39;s data ndata &lt;- normDataWithin(data, idvar, measurevar, betweenvars, na.rm, .drop = .drop) # This is the name of the new column measurevar_n &lt;- paste(measurevar, &quot;_norm&quot;, sep = &quot;&quot;) # Collapse the normed data - now we can treat between # and within vars the same ndatac &lt;- summarySE(ndata, measurevar_n, groupvars = c(betweenvars, withinvars), na.rm = na.rm, conf.interval = conf.interval, .drop = .drop) # Apply correction from Morey (2008) to the standard # error and confidence interval Get the product of the # number of conditions of within-S variables nWithinGroups &lt;- prod(vapply(ndatac[, withinvars, drop = FALSE], FUN = nlevels, FUN.VALUE = numeric(1))) correctionFactor &lt;- sqrt(nWithinGroups/(nWithinGroups - 1)) # Apply the correction factor ndatac$sd &lt;- ndatac$sd * correctionFactor ndatac$se &lt;- ndatac$se * correctionFactor ndatac$ci &lt;- ndatac$ci * correctionFactor # Combine the un-normed means with the normed results merge(datac, ndatac) } 9.2.2.2 示例数据 下面的示例将使用 ToothGrowth 数据集。注意 dose 在这里是一个数值列，一些情况下我们将它转换为因子变量将会更加有用。 tg &lt;- ToothGrowth head(tg) #&gt; len supp dose #&gt; 1 4.2 VC 0.5 #&gt; 2 11.5 VC 0.5 #&gt; 3 7.3 VC 0.5 #&gt; 4 5.8 VC 0.5 #&gt; 5 6.4 VC 0.5 #&gt; 6 10.0 VC 0.5 library(ggplot2) 首先，我们必须对数据进行统计汇总。 这可以通过多种方式实现，参阅汇总数据。在这个案例中，我们将使用 summarySE() 函数( 确保summarySE() 函数的代码在使用前已经键入)。 # install.packages(&#39;Rmisc&#39;) library(Rmisc) #&gt; Loading required package: lattice #&gt; Loading required package: plyr #&gt; #&gt; Attaching package: &#39;Rmisc&#39; #&gt; The following objects are masked _by_ &#39;.GlobalEnv&#39;: #&gt; #&gt; normDataWithin, summarySE, summarySEwithin # summarySE 函数提供了标准差、标准误以及 95% 的置信区间 tgc &lt;- summarySE(tg, measurevar = &quot;len&quot;, groupvars = c(&quot;supp&quot;, &quot;dose&quot;)) tgc #&gt; supp dose N len sd se ci #&gt; 1 OJ 0.5 10 13.23 4.460 1.4103 3.190 #&gt; 2 OJ 1.0 10 22.70 3.911 1.2368 2.798 #&gt; 3 OJ 2.0 10 26.06 2.655 0.8396 1.899 #&gt; 4 VC 0.5 10 7.98 2.747 0.8686 1.965 #&gt; 5 VC 1.0 10 16.77 2.515 0.7954 1.799 #&gt; 6 VC 2.0 10 26.14 4.798 1.5172 3.432 9.2.2.3 线图 数据统计总结后，我们就可以开始绘制图形了。这里是一些带误差线的线图和点图，误差线代表标准差、标准误或者是 95% 的置信区间。 # 均值的标准误 ggplot(tgc, aes(x = dose, y = len, colour = supp)) + geom_errorbar(aes(ymin = len - se, ymax = len + se), width = 0.1) + geom_line() + geom_point() # 发现误差线重叠（dose=2.0），我们使用 position_dodge # 将它们进行水平移动 pd &lt;- position_dodge(0.1) # move them .05 to the left and right ggplot(tgc, aes(x = dose, y = len, colour = supp)) + geom_errorbar(aes(ymin = len - se, ymax = len + se), width = 0.1, position = pd) + geom_line(position = pd) + geom_point(position = pd) # 使用 95% 置信区间替换标准误 ggplot(tgc, aes(x = dose, y = len, colour = supp)) + geom_errorbar(aes(ymin = len - ci, ymax = len + ci), width = 0.1, position = pd) + geom_line(position = pd) + geom_point(position = pd) # 黑色的误差线 - 注意 &#39;group=supp&#39; 的映射 -- # 没有它，误差线将不会避开（就是会重叠）。 ggplot(tgc, aes(x = dose, y = len, colour = supp, group = supp)) + geom_errorbar(aes(ymin = len - ci, ymax = len + ci), colour = &quot;black&quot;, width = 0.1, position = pd) + geom_line(position = pd) + geom_point(position = pd, size = 3) 一张完成的带误差线（代表均值的标准误）的图形可能像下面显示的那样。最后画点，这样白色将会在线和误差线的上面（这个需要理解图层概念，顺序不同展示的效果是不一样的）。 ggplot(tgc, aes(x=dose, y=len, colour=supp, group=supp)) + geom_errorbar(aes(ymin=len-se, ymax=len+se), colour=&quot;black&quot;, width=.1, position=pd) + geom_line(position=pd) + geom_point(position=pd, size=3, shape=21, fill=&quot;white&quot;) + # 21的填充的圆 xlab(&quot;Dose (mg)&quot;) + ylab(&quot;Tooth length&quot;) + scale_colour_hue(name=&quot;Supplement type&quot;, # 图例标签使用暗色 breaks=c(&quot;OJ&quot;, &quot;VC&quot;), labels=c(&quot;Orange juice&quot;, &quot;Ascorbic acid&quot;), l=40) + # 使用暗色，亮度为40 ggtitle(&quot;The Effect of Vitamin C on\\nTooth Growth in Guinea Pigs&quot;) + expand_limits(y=0) + # 扩展范围 scale_y_continuous(breaks=0:20*4) + # 每4个单位设置标记（y轴） theme_bw() + theme(legend.justification=c(1,0), legend.position=c(1,0)) # 右下方放置图例 9.2.2.4 条形图 条形图绘制误差线也非常相似。 注意 tgc$dose 必须是一个因子。如果它是一个数值向量，将会不起作用。 # 将dose转换为因子变量 tgc2 &lt;- tgc tgc2$dose &lt;- factor(tgc2$dose) # 误差线代表了均值的标准误 ggplot(tgc2, aes(x=dose, y=len, fill=supp)) + geom_bar(position=position_dodge(), stat=&quot;identity&quot;) + geom_errorbar(aes(ymin=len-se, ymax=len+se), width=.2, # 误差线的宽度 position=position_dodge(.9)) # 使用95%的置信区间替换标准误 ggplot(tgc2, aes(x=dose, y=len, fill=supp)) + geom_bar(position=position_dodge(), stat=&quot;identity&quot;) + geom_errorbar(aes(ymin=len-ci, ymax=len+ci), width=.2, # 误差线的宽度 position=position_dodge(.9)) 一张绘制完成的图片像下面这样： ggplot(tgc2, aes(x=dose, y=len, fill=supp)) + geom_bar(position=position_dodge(), stat=&quot;identity&quot;, colour=&quot;black&quot;, # 使用黑色边框, size=.3) + # 将线变细 geom_errorbar(aes(ymin=len-se, ymax=len+se), size=.3, # 将线变细 width=.2, position=position_dodge(.9)) + xlab(&quot;Dose (mg)&quot;) + ylab(&quot;Tooth length&quot;) + scale_fill_hue(name=&quot;Supplement type&quot;, # Legend label, use darker colors breaks=c(&quot;OJ&quot;, &quot;VC&quot;), labels=c(&quot;Orange juice&quot;, &quot;Ascorbic acid&quot;)) + ggtitle(&quot;The Effect of Vitamin C on\\nTooth Growth in Guinea Pigs&quot;) + scale_y_continuous(breaks=0:20*4) + theme_bw() 9.2.2.5 为组内变量添加误差线 当所有的变量都属于不同组别时，我们画标准误或者置信区间会显得非常简单直观。然而，当我们描绘的是组内变量（重复测量），那么添加标准误或者通常的置信区间可能会对不同条件下差异的推断产生误导作用。 下面的方法来自 Morey (2008)，它是对 Cousineau (2005)的矫正，而它所做的就是 提供比 Loftus and Masson (1994)更简单的方法。 你可以查看这些文章，以获得更多对组内变量误差线问题的详细探讨和方案。 这里有一个组内变量的数据集 (来自 Morey 2008)，包含 pre/post-test。 dfw &lt;- read.table(header = TRUE, text = &quot; subject pretest posttest 1 59.4 64.5 2 46.4 52.4 3 46.0 49.7 4 49.0 48.7 5 32.5 37.4 6 45.2 49.5 7 60.3 59.9 8 54.3 54.1 9 45.4 49.6 10 38.9 48.5 &quot;) # 将物体的 ID 作为因子变量对待 dfw$subject &lt;- factor(dfw$subject) 第一步是将该数据集转换为长格式，参见长宽格式数据互换获取更多信息。 # 转换为长格式 library(reshape2) dfw_long &lt;- melt(dfw, id.vars = &quot;subject&quot;, measure.vars = c(&quot;pretest&quot;, &quot;posttest&quot;), variable.name = &quot;condition&quot;) dfw_long #&gt; subject condition value #&gt; 1 1 pretest 59.4 #&gt; 2 2 pretest 46.4 #&gt; 3 3 pretest 46.0 #&gt; 4 4 pretest 49.0 #&gt; 5 5 pretest 32.5 #&gt; 6 6 pretest 45.2 #&gt; 7 7 pretest 60.3 #&gt; 8 8 pretest 54.3 #&gt; 9 9 pretest 45.4 #&gt; 10 10 pretest 38.9 #&gt; 11 1 posttest 64.5 #&gt; 12 2 posttest 52.4 #&gt; 13 3 posttest 49.7 #&gt; 14 4 posttest 48.7 #&gt; 15 5 posttest 37.4 #&gt; 16 6 posttest 49.5 #&gt; 17 7 posttest 59.9 #&gt; 18 8 posttest 54.1 #&gt; 19 9 posttest 49.6 #&gt; 20 10 posttest 48.5 使用 summarySEwithin() 函数拆解数据。 dfwc &lt;- summarySEwithin(dfw_long, measurevar = &quot;value&quot;, withinvars = &quot;condition&quot;, idvar = &quot;subject&quot;, na.rm = FALSE, conf.interval = 0.95) dfwc #&gt; condition N value value_norm sd se ci #&gt; 1 posttest 10 51.43 51.43 2.262 0.7154 1.618 #&gt; 2 pretest 10 47.74 47.74 2.262 0.7154 1.618 library(ggplot2) # 创建带 95% 置信区间的图形 ggplot(dfwc, aes(x = condition, y = value, group = 1)) + geom_line() + geom_errorbar(width = 0.1, aes(ymin = value - ci, ymax = value + ci)) + geom_point(shape = 21, size = 3, fill = &quot;white&quot;) + ylim(40, 60) value 和 value_norm 列代表了未标准化和标准化后的值。 9.2.2.6 理解组内变量的误差线 这部分解释组内的误差线值是如何计算出来的。这些步骤仅作解释目的；它们对于绘制误差线是非必需的。 下面独立数据的图形结果展示了组内变量 condition 存在连续一致的趋势，但使用常规的标准误（或者置信区间）则不能充分地展示这一点。Morey (2008) 和Cousineau (2005) 的方法本质是标准化数据去移除组间的变化，计算出这个标准化数据的变异程度。 # 使用一致的 y 轴范围 ymax &lt;- max(dfw_long$value) ymin &lt;- min(dfw_long$value) # 绘制个体数据 ggplot(dfw_long, aes(x = condition, y = value, colour = subject, group = subject)) + geom_line() + geom_point(shape = 21, fill = &quot;white&quot;) + ylim(ymin, ymax) # 创造标准化的版本 dfwNorm.long &lt;- normDataWithin(data = dfw_long, idvar = &quot;subject&quot;, measurevar = &quot;value&quot;) # 绘制标准化的个体数据 ggplot(dfwNorm.long, aes(x = condition, y = value_norm, colour = subject, group = subject)) + geom_line() + geom_point(shape = 21, fill = &quot;white&quot;) + ylim(ymin, ymax) 针对正常（组间）方法和组内方法的误差线差异在下面呈现。正常的方法计算出的误差线用红色表示，组内方法的误差线用黑色表示。 # Instead of summarySEwithin, use summarySE, which # treats condition as though it were a between-subjects # variable dfwc_between &lt;- summarySE(data = dfw_long, measurevar = &quot;value&quot;, groupvars = &quot;condition&quot;, na.rm = FALSE, conf.interval = 0.95) dfwc_between #&gt; condition N value sd se ci #&gt; 1 pretest 10 47.74 8.599 2.719 6.151 #&gt; 2 posttest 10 51.43 7.254 2.294 5.189 # 用红色显示组间的置信区间，用黑色展示组内的置信区间 ggplot(dfwc_between, aes(x = condition, y = value, group = 1)) + geom_line() + geom_errorbar(width = 0.1, aes(ymin = value - ci, ymax = value + ci), colour = &quot;red&quot;) + geom_errorbar(width = 0.1, aes(ymin = value - ci, ymax = value + ci), data = dfwc) + geom_point(shape = 21, size = 3, fill = &quot;white&quot;) + ylim(ymin, ymax) 9.2.2.7 两个组内变量 如果存在超过一个的组内变量，我们可以使用相同的函数 summarySEwithin。下面的数据集来自 Hays (1994)，在 Rouder and Morey (2005) 中用来绘制这类的组内误差线。 data &lt;- read.table(header = TRUE, text = &quot; Subject RoundMono SquareMono RoundColor SquareColor 1 41 40 41 37 2 57 56 56 53 3 52 53 53 50 4 49 47 47 47 5 47 48 48 47 6 37 34 35 36 7 47 50 47 46 8 41 40 38 40 9 48 47 49 45 10 37 35 36 35 11 32 31 31 33 12 47 42 42 42 &quot;) 数据集首先必须转换为长格式，列名显示了两个变量： 形状 (圆形/方形) 和配色方案 (黑白/有色)。 # 转换为长格式 library(reshape2) data_long &lt;- melt(data = data, id.var = &quot;Subject&quot;, measure.vars = c(&quot;RoundMono&quot;, &quot;SquareMono&quot;, &quot;RoundColor&quot;, &quot;SquareColor&quot;), variable.name = &quot;Condition&quot;) names(data_long)[names(data_long) == &quot;value&quot;] &lt;- &quot;Time&quot; # 拆分 Condition 列为 Shape 和 ColorScheme data_long$Shape &lt;- NA data_long$Shape[grepl(&quot;^Round&quot;, data_long$Condition)] &lt;- &quot;Round&quot; data_long$Shape[grepl(&quot;^Square&quot;, data_long$Condition)] &lt;- &quot;Square&quot; data_long$Shape &lt;- factor(data_long$Shape) data_long$ColorScheme &lt;- NA data_long$ColorScheme[grepl(&quot;Mono$&quot;, data_long$Condition)] &lt;- &quot;Monochromatic&quot; data_long$ColorScheme[grepl(&quot;Color$&quot;, data_long$Condition)] &lt;- &quot;Colored&quot; data_long$ColorScheme &lt;- factor(data_long$ColorScheme, levels = c(&quot;Monochromatic&quot;, &quot;Colored&quot;)) # 删除 Condition 列 data_long$Condition &lt;- NULL # 检查数据 head(data_long) #&gt; Subject Time Shape ColorScheme #&gt; 1 1 41 Round Monochromatic #&gt; 2 2 57 Round Monochromatic #&gt; 3 3 52 Round Monochromatic #&gt; 4 4 49 Round Monochromatic #&gt; 5 5 47 Round Monochromatic #&gt; 6 6 37 Round Monochromatic 现在可以进行统计汇总和绘图了。 datac &lt;- summarySEwithin(data_long, measurevar = &quot;Time&quot;, withinvars = c(&quot;Shape&quot;, &quot;ColorScheme&quot;), idvar = &quot;Subject&quot;) datac #&gt; Shape ColorScheme N Time Time_norm sd se #&gt; 1 Round Colored 12 43.58 43.58 1.212 0.3500 #&gt; 2 Round Monochromatic 12 44.58 44.58 1.331 0.3844 #&gt; 3 Square Colored 12 42.58 42.58 1.462 0.4219 #&gt; 4 Square Monochromatic 12 43.58 43.58 1.261 0.3641 #&gt; ci #&gt; 1 0.7703 #&gt; 2 0.8460 #&gt; 3 0.9287 #&gt; 4 0.8014 library(ggplot2) ggplot(datac, aes(x = Shape, y = Time, fill = ColorScheme)) + geom_bar(position = position_dodge(0.9), colour = &quot;black&quot;, stat = &quot;identity&quot;) + geom_errorbar(position = position_dodge(0.9), width = 0.25, aes(ymin = Time - ci, ymax = Time + ci)) + coord_cartesian(ylim = c(40, 46)) + scale_fill_manual(values = c(&quot;#CCCCCC&quot;, &quot;#FFFFFF&quot;)) + scale_y_continuous(breaks = seq(1:100)) + theme_bw() + geom_hline(yintercept = 38) 9.2.2.8 注意标准化的均值 函数 summarySEWithin() 返回标准化和未标准化的均值。未标准化的均值只是简单地表示每组的均值。标准化的均值计算出来保证组间的均值是一样的。 比如： dat &lt;- read.table(header = TRUE, text = &quot; id trial gender dv A 0 male 2 A 1 male 4 B 0 male 6 B 1 male 8 C 0 female 22 C 1 female 24 D 0 female 26 D 1 female 28 &quot;) # 标准化和未标准化的均值是不同的 summarySEwithin(dat, measurevar = &quot;dv&quot;, withinvars = &quot;trial&quot;, betweenvars = &quot;gender&quot;, idvar = &quot;id&quot;) #&gt; Automatically converting the following non-factors to factors: trial #&gt; gender trial N dv dv_norm sd se ci #&gt; 1 female 0 2 24 14 0 0 0 #&gt; 2 female 1 2 26 16 0 0 0 #&gt; 3 male 0 2 4 14 0 0 0 #&gt; 4 male 1 2 6 16 0 0 0 9.2.3 其他 解决问题的方法不止作者提供的这一种，为了理解 ggplot2 是如何进行误差线的计算和添加，我在 stackoverflow 上提交了一个关于 ggplot2 使用 SE 还是 SD 作为默认误差线的问题。有人就给出了快速简易的解答。回答者的共同观点是必须先进行数据的统计计算。我之前在其他博客上看到使用 stat_boxplot(geom=&quot;errorbar&quot;, width=.3) 直接计算误差线可能就有问题（难以解释它算的是 SD 还是 SE）。 9.3 分布图 9.3.1 问题 你想要绘制一组数据的分布图。 9.3.2 方案 后面的例子中会使用以下这组简单的数据： set.seed(1234) dat &lt;- data.frame(cond = factor(rep(c(&quot;A&quot;, &quot;B&quot;), each = 200)), rating = c(rnorm(200), rnorm(200, mean = 0.8))) # 查看数据 head(dat) #&gt; cond rating #&gt; 1 A -1.2071 #&gt; 2 A 0.2774 #&gt; 3 A 1.0844 #&gt; 4 A -2.3457 #&gt; 5 A 0.4291 #&gt; 6 A 0.5061 library(ggplot2) 9.3.2.1 直方图和概率密度图 qplot() 函数能够用更简单的语法绘制出与 ggplot() 相同的图像。然而，在实践过程中你会发现 ggplot() 是更好的选择，因为 qplot() 中很多参数的选项都会让人感到困惑。 # 以 rating 为横轴绘制直方图，组距设为 0.5 # 两种函数都可以绘制出相同的图: ggplot(dat, aes(x=rating)) + geom_histogram(binwidth=.5) # qplot(dat$rating, binwidth=.5) # 绘制黑色边线，白色填充的图 ggplot(dat, aes(x=rating)) + geom_histogram(binwidth=.5, colour=&quot;black&quot;, fill=&quot;white&quot;) # 密度曲线 ggplot(dat, aes(x=rating)) + geom_density() # 直方图与核密度曲线重叠 ggplot(dat, aes(x=rating)) + geom_histogram(aes(y=..density..), # 这里直方图以 density (密度)为y轴 binwidth=.5, colour=&quot;black&quot;, fill=&quot;white&quot;) + geom_density(alpha=.2, fill=&quot;#FF6666&quot;) # 重合部分透明填充 添加一条均值线： ggplot(dat, aes(x=rating)) + geom_histogram(binwidth=.5, colour=&quot;black&quot;, fill=&quot;white&quot;) + geom_vline(aes(xintercept=mean(rating, na.rm=T)), # 忽略缺失值 color=&quot;red&quot;, linetype=&quot;dashed&quot;, size=1) 9.3.2.2 多组数据的直方图和概率密度图 # 重叠直方图 ggplot(dat, aes(x = rating, fill = cond)) + geom_histogram(binwidth = 0.5, alpha = 0.5, position = &quot;identity&quot;) # identity 表示将每个对象直接显示在图中，条形会彼此重叠。 # 间隔直方图 ggplot(dat, aes(x = rating, fill = cond)) + geom_histogram(binwidth = 0.5, position = &quot;dodge&quot;) # dodge 表示将每组的条形依次并列放置。 # 密度图 ggplot(dat, aes(x = rating, colour = cond)) + geom_density() # 半透明填充的密度图 ggplot(dat, aes(x = rating, fill = cond)) + geom_density(alpha = 0.3) 在给每组数据添加均值线前，需要将每组数据的平均值赋值到一个新的数据框。 # 求均值 library(plyr) cdat &lt;- ddply(dat, &quot;cond&quot;, summarise, rating.mean = mean(rating)) cdat #&gt; cond rating.mean #&gt; 1 A -0.05776 #&gt; 2 B 0.87325 # 给重叠直方图添加均值线 ggplot(dat, aes(x = rating, fill = cond)) + geom_histogram(binwidth = 0.5, alpha = 0.5, position = &quot;identity&quot;) + geom_vline(data = cdat, aes(xintercept = rating.mean, colour = cond), linetype = &quot;dashed&quot;, size = 1) # 给密度图添加均值线 ggplot(dat, aes(x = rating, colour = cond)) + geom_density() + geom_vline(data = cdat, aes(xintercept = rating.mean, colour = cond), linetype = &quot;dashed&quot;, size = 1) 使用分面： ggplot(dat, aes(x = rating)) + geom_histogram(binwidth = 0.5, colour = &quot;black&quot;, fill = &quot;white&quot;) + facet_grid(cond ~ .) # 使用之前的 cdat 添加均值线 ggplot(dat, aes(x = rating)) + geom_histogram(binwidth = 0.5, colour = &quot;black&quot;, fill = &quot;white&quot;) + facet_grid(cond ~ .) + geom_vline(data = cdat, aes(xintercept = rating.mean), linetype = &quot;dashed&quot;, size = 1, colour = &quot;red&quot;) 更多关于分面的细节可查看分面 9.3.2.3 箱型图 # 绘制箱型图 ggplot(dat, aes(x = cond, y = rating)) + geom_boxplot() # 对分组填充颜色 ggplot(dat, aes(x = cond, y = rating, fill = cond)) + geom_boxplot() # 将上图中冗余的图例删除掉： ggplot(dat, aes(x = cond, y = rating, fill = cond)) + geom_boxplot() + guides(fill = FALSE) # 坐标轴翻转 ggplot(dat, aes(x = cond, y = rating, fill = cond)) + geom_boxplot() + guides(fill = FALSE) + coord_flip() 同时可以通过 stat_summary() 来添加平均值。 # 用菱形图标指征平均值，并调整参数使该图标变更大。 ggplot(dat, aes(x = cond, y = rating)) + geom_boxplot() + stat_summary(fun.y = mean, geom = &quot;point&quot;, shape = 5, size = 4) 9.4 散点图 9.4.1 问题 你想要绘制一幅散点图。 9.4.2 方案 假设这是你的数据： set.seed(955) # 创建一些噪声数据 dat &lt;- data.frame(cond = rep(c(&quot;A&quot;, &quot;B&quot;), each = 10), xvar = 1:20 + rnorm(20, sd = 3), yvar = 1:20 + rnorm(20, sd = 3)) head(dat) #&gt; cond xvar yvar #&gt; 1 A -4.252 3.47316 #&gt; 2 A 1.702 0.00594 #&gt; 3 A 4.323 -0.09425 #&gt; 4 A 1.781 2.07281 #&gt; 5 A 11.537 1.21544 #&gt; 6 A 6.672 3.60811 library(ggplot2) 9.4.2.1 带回归线的基本散点图 ggplot(dat, aes(x=xvar, y=yvar)) + geom_point(shape=1) # 使用空心圆 ggplot(dat, aes(x=xvar, y=yvar)) + geom_point(shape=1) + # 使用空心圆 geom_smooth(method=lm) # 添加回归线 # (默认包含 95% 置信区间) ggplot(dat, aes(x=xvar, y=yvar)) + geom_point(shape=1) + # 使用空心圆 geom_smooth(method=lm, # 添加回归线 se=FALSE) # 不加置信区域 ggplot(dat, aes(x=xvar, y=yvar)) + geom_point(shape=1) + # 使用空心圆 geom_smooth() # 添加带置信区间的平滑拟合曲线 #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 9.4.2.2 通过其他变量设置颜色和形状 # 根据 cond 设置颜色 ggplot(dat, aes(x=xvar, y=yvar, color=cond)) + geom_point(shape=1) # 同上，但这里带了回归线 ggplot(dat, aes(x=xvar, y=yvar, color=cond)) + geom_point(shape=1) + scale_colour_hue(l=50) + # 使用稍暗的调色板 geom_smooth(method=lm, se=FALSE) # 拓展回归线到数据区域之外（带预测效果） ggplot(dat, aes(x=xvar, y=yvar, color=cond)) + geom_point(shape=1) + scale_colour_hue(l=50) + geom_smooth(method=lm, se=FALSE, fullrange=TRUE) # 根据 cond 设置形状 ggplot(dat, aes(x=xvar, y=yvar, shape=cond)) + geom_point() # 同上，但形状不同 ggplot(dat, aes(x=xvar, y=yvar, shape=cond)) + geom_point() + scale_shape_manual(values=c(1,2)) # 使用圆和三角形 查看颜色获取更多关于颜色的信息。查看形状与线形获取更多相关内容。 9.4.2.3 处理图像元素叠加 如果你有很多数据点，或者你的数据是离散的，那么数据可能会覆盖到一起，这样就看不清楚同一个位置有多少数据了。 # 取近似值 dat$xrnd &lt;- round(dat$xvar/5) * 5 dat$yrnd &lt;- round(dat$yvar/5) * 5 # 让每个点都部分透明 如果情况严重，可以使用更小的值 ggplot(dat, aes(x = xrnd, y = yrnd)) + geom_point(shape = 19, alpha = 1/4) # 抖动点 抖动范围在 x 轴上是 1，y 轴上是 0.5 ggplot(dat, aes(x = xrnd, y = yrnd)) + geom_point(shape = 1, position = position_jitter(width = 1, height = 0.5)) 9.5 标题 9.5.1 问题 你想给图形设定一个标题。 9.5.2 方案 一个不带标题的图形例子： library(ggplot2) bp &lt;- ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() bp 添加标题： bp + ggtitle(&quot;Plant growth&quot;) ## 等同于 bp + labs(title=&#39;Plant growth&#39;) ## 如果标题比较长，可以用 \\n 将它分成多行来显示 bp + ggtitle(&quot;Plant growth with\\ndifferent treatments&quot;) # 缩少行距并使用粗体 bp + ggtitle(&quot;Plant growth with\\ndifferent treatments&quot;) + theme(plot.title = element_text(lineheight = 0.8, face = &quot;bold&quot;)) 9.6 坐标轴 9.6.1 问题 你想要改变轴的顺序或方向。 9.6.2 方案 注意：下面的例子中提到的 scale_y_continuous()、ylim() 等函数名中，y 都可以替换为 x。 下面使用内置的 PlantGrowth 数据集绘制一个基本的箱线图。 library(ggplot2) bp &lt;- ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() bp 9.6.2.1 交换 x 和 y 轴 交换 x 和 y 轴（让 x 垂直、y 水平）。 bp + coord_flip() 9.6.2.2 离散轴 9.6.2.2.1 改变条目的顺序 # 手动设定离散轴条目的顺序 bp + scale_x_discrete(limits = c(&quot;trt1&quot;, &quot;trt2&quot;, &quot;ctrl&quot;)) ## 逆转轴条目顺序 获取因子水平 flevels &lt;- levels(PlantGrowth$group) flevels #&gt; [1] &quot;ctrl&quot; &quot;trt1&quot; &quot;trt2&quot; # 逆转顺序 flevels &lt;- rev(flevels) flevels #&gt; [1] &quot;trt2&quot; &quot;trt1&quot; &quot;ctrl&quot; bp + scale_x_discrete(limits = flevels) # 或者一行搞定 bp + scale_x_discrete(limits = rev(levels(PlantGrowth$group))) 9.6.2.2.2 设定标签 对于离散变量，标签来自于因子水平。然而，有时候短的因子水平名字并不适合展示。 bp + scale_x_discrete(breaks = c(&quot;ctrl&quot;, &quot;trt1&quot;, &quot;trt2&quot;), labels = c(&quot;Control&quot;, &quot;Treat 1&quot;, &quot;Treat 2&quot;)) # 隐藏 x 刻度、标签和网格线 bp + scale_x_discrete(breaks = NULL) # 隐藏所有的刻度和标签（X 轴），保留网格线 bp + theme(axis.ticks = element_blank(), axis.text.x = element_blank()) 9.6.2.3 连续轴 9.6.2.3.1 设定范围和反转轴方向 如果你仅想简单地让轴包含某个值，可以使用 expand_limits()，它会进行拓展而不是拉伸。 # 确保 y 轴包含 0 bp + expand_limits(y = 0) # 确保 y 轴包含 0 和 8 bp + expand_limits(y = c(0, 8)) 当然你也可以通过 y 刻度显式地指定。注意如果使用任何 scale_y_continuous 命令，它会覆盖任何 ylim 命令，而且 ylim 会被忽略。 # 设定连续值轴的范围 下面是相同的操作 bp + ylim(0, 8) # bp + scale_y_continuous(limits=c(0, 8)) 如果使用上述方法让 y 轴的范围变小，任何超出范围的数据都会被忽略。有时候这会产生一些问题，读者需要注意。 为了避免产生问题，你可以使用 coord_cartesian()，相比于设定轴的范围，它设定数据可视化的区域。 # 这两个操作一致，超出范围的数据被删除了，导致产生一个误导的箱线图 bp + ylim(5, 7.5) #&gt; Warning: Removed 13 rows containing non-finite values #&gt; (stat_boxplot). # bp + scale_y_continuous(limits=c(5, 7.5)) # 使用 coord_cartesian &#39;zooms&#39; 区域 bp + coord_cartesian(ylim = c(5, 7.5)) # 直接指定刻度 bp + coord_cartesian(ylim = c(5, 7.5)) + scale_y_continuous(breaks = seq(0, 10, 0.25)) # Ticks from 0-10, every .25 9.6.2.3.2 反转轴方向 # 反转一个连续值轴的方向 bp + scale_y_reverse() 9.6.2.3.3 设置和隐藏刻度标记 # Setting the tick marks on an axis This will show tick # marks on every 0.25 from 1 to 10 The scale will show # only the ones that are within range (3.50-6.25 in this # case) bp + scale_y_continuous(breaks = seq(1, 10, 1/4)) # 刻度不平等变化 bp + scale_y_continuous(breaks = c(4, 4.25, 4.5, 5, 6, 8)) # 抑制标签和网格线 bp + scale_y_continuous(breaks = NULL) # Hide tick marks and labels (on Y axis), but keep the # gridlines bp + theme(axis.ticks = element_blank(), axis.text.y = element_blank()) 9.6.2.3.4 轴刻度 log、sqrt 等转换 默认轴是线性坐标，我们也可以将它转换为 log、幂、根等等。 有两种办法可以转换一个轴，一是使用 scale 进行转换，另外是使用 coordinate 进行转换。使用前者需要在先弄好刻度和轴的范围之前转换，而使用后者则相反，需要在弄好刻度和轴范围之后转换。这将产生不太一样的显示效果，如下所示。 # 创建指数分布数据 set.seed(201) n &lt;- 100 dat &lt;- data.frame(xval = (1:n + rnorm(n, sd = 5))/20, yval = 2 * 2^((1:n + rnorm(n, sd = 5))/20)) # 创建常规的散点图 sp &lt;- ggplot(dat, aes(xval, yval)) + geom_point() sp # log2 比例化（间隔相等） library(scales) # 需要 scales 包 sp + scale_y_continuous(trans = log2_trans()) # log2 坐标转换，空间间隔不同 sp + coord_trans(y = &quot;log2&quot;) 在标度转换中，我们还可以指定刻度值，让它们显示指数。 sp + scale_y_continuous(trans = log2_trans(), breaks = trans_breaks(&quot;log2&quot;, function(x) 2^x), labels = trans_format(&quot;log2&quot;, math_format(2^.x))) 可以使用非常多的转换，参见 ?trans_new 查看所有可用转换的列表。如果你所需要的转换不在该列表上，可以自己写一个转换函数。 有一些非常便捷的函数：scale_y_log10() 和 scale_y_sqrt() （有对应的 x 版本）。 set.seed(205) n &lt;- 100 dat10 &lt;- data.frame(xval = (1:n + rnorm(n, sd = 5))/20, yval = 10 * 10^((1:n + rnorm(n, sd = 5))/20)) sp10 &lt;- ggplot(dat10, aes(xval, yval)) + geom_point() # log10 sp10 + scale_y_log10() # log10 转换，并设定指数标签 sp10 + scale_y_log10(breaks = trans_breaks(&quot;log10&quot;, function(x) 10^x), labels = trans_format(&quot;log10&quot;, math_format(10^.x))) 9.6.2.3.5 x 与 y 轴固定的比例 设置 x 与 y 轴比例宽度也是可以的。 # x 范围 0-10, y 范围 0-30 set.seed(202) dat &lt;- data.frame(xval = runif(40, 0, 10), yval = runif(40, 0, 30)) sp &lt;- ggplot(dat, aes(xval, yval)) + geom_point() # 强制比例相等 sp + coord_fixed() # 相等的标度变化，让 x 的 1 个单位等同 y 的 3 个单位 sp + coord_fixed(ratio = 1/3) 9.6.2.4 轴标签和文字格式化 设置和隐藏轴标签： bp + theme(axis.title.x = element_blank()) + # 移除 x 轴标签 ylab(&quot;Weight (Kg)&quot;) # 设置 y 轴标签 # 也可以通过标度设置 # 注意这里 x 轴标签的空间仍然保留 bp + scale_x_discrete(name=&quot;&quot;) + scale_y_continuous(name=&quot;Weight (Kg)&quot;) 改变字体、颜色、旋转刻度标签： # 改变字体选项： X-axis label: bold, red, and 20 points # X-axis tick marks: rotate 90 degrees CCW, move to the # left a bit (using vjust, since the labels are # rotated), and 16 points bp + theme(axis.title.x = element_text(face = &quot;bold&quot;, colour = &quot;#990000&quot;, size = 20), axis.text.x = element_text(angle = 90, vjust = 0.5, size = 16)) 9.6.2.5 刻度标签 你可能想将值显示为百分比、或美元、或科学计数法。这里可以使用格式器，它是一个可以改变文本的函数。 # 标签格式器 library(scales) # 需要 scales 包 bp + scale_y_continuous(labels = percent) + scale_x_discrete(labels = abbreviate) # 在这个例子中它没作用 连续标度格式器有 comma、percent、dollar 以及 scientific。离散标度格式器有 abbreviate、date_format 等。 有时你需要自己创建格式化函数。下面的函数可以显示时间格式为 HH:MM:SS。 # 自定义时间格式化函数 timeHMS_formatter &lt;- function(x) { h &lt;- floor(x/60) m &lt;- floor(x%%60) s &lt;- round(60 * (x%%1)) # Round to nearest second lab &lt;- sprintf(&quot;%02d:%02d:%02d&quot;, h, m, s) # Format the strings as HH:MM:SS lab &lt;- gsub(&quot;^00:&quot;, &quot;&quot;, lab) # Remove leading 00: if present lab &lt;- gsub(&quot;^0&quot;, &quot;&quot;, lab) # Remove leading 0 if present } bp + scale_y_continuous(label = timeHMS_formatter) 9.6.2.6 隐藏网格线 隐藏网格线： # 隐藏所有网格线 bp + theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank()) # 仅隐藏次级网格线 bp + theme(panel.grid.minor = element_blank()) 也可以仅隐藏水平或垂直网格线： # 隐藏所有垂直网格线 bp + theme(panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank()) # 隐藏所有水平网格线 bp + theme(panel.grid.minor.y = element_blank(), panel.grid.major.y = element_blank()) 9.7 图例 9.7.1 问题 你想用 ggplot2 修改图表中的图例。 9.7.2 方案 从带有默认选项的示例图开始： library(ggplot2) bp &lt;- ggplot(data = PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot() bp 9.7.2.1 去除图例 使用 guides(fill=FALSE), 用想要的颜色替代填充色. 你也可以用 theme() 移除图表中所有的图例。 # 删除特定美学的图例（填充） bp + guides(fill = FALSE) # 在指定比例时也可以这样做 bp + scale_fill_discrete(guide = FALSE) # 这将移除所有的图例 bp + theme(legend.position = &quot;none&quot;) 9.7.2.2 在图例中改变变量的顺序 这会将变量的顺序更改为 trt1，ctrl，trt2: bp + scale_fill_discrete(breaks = c(&quot;trt1&quot;, &quot;ctrl&quot;, &quot;trt2&quot;)) 根据指定颜色的方式，你可能必须使用不同的比例，如 scale_fill_manual(), scale_colour_hue(), scale_colour_manual(), scale_shape_discrete(), scale_linetype_discrete() 等。 9.7.2.3 反转图例中的条目顺序 反转图例顺序: # 这两种方式等同: bp + guides(fill = guide_legend(reverse = TRUE)) bp + scale_fill_discrete(guide = guide_legend(reverse = TRUE)) # 你也可以直接修改比例尺： bp + scale_fill_discrete(breaks = rev(levels(PlantGrowth$group))) 你可以使用不同的比例尺，如 scale_fill_manual(), scale_colour_hue(), scale_colour_manual(), scale_shape_discrete(), scale_linetype_discrete() 等，而不是 scale_fill_discrete()。 9.7.2.4 隐藏图例标题 这将隐藏图例标题: # 为了填充的图例移除标题 bp + guides(fill = guide_legend(title = NULL)) # 为了所有的图例移除标题 bp + theme(legend.title = element_blank()) 9.7.2.5 修改图例标题和标签的文字 有两种方法可以更改图例标题和标签。 第一种方法是告诉 scale 使用具有不同的标题和标签。 第二种方法是更改数据框，使因子具有所需的形式。 9.7.2.5.1 使用比例尺 图例可能由 fill, colour, linetype, shape 或其他因素所介导. 9.7.2.5.2 使用填充和颜色 因为图例中的变量 group 被映射到颜色 fill，所以必须使用 scale_fill_xxx，其中 xxx 是将 group 的每个因子级别映射到不同颜色的方法。 默认设置是在每个因子级别的色轮上使用不同的色调，但也可以手动指定每个级别的颜色。 bp + scale_fill_discrete(name = &quot;Experimental\\nCondition&quot;) bp + scale_fill_discrete(name = &quot;Experimental\\nCondition&quot;, breaks = c(&quot;ctrl&quot;, &quot;trt1&quot;, &quot;trt2&quot;), labels = c(&quot;Control&quot;, &quot;Treatment 1&quot;, &quot;Treatment 2&quot;)) # 使用手动刻度而不是色调 bp + scale_fill_manual(values = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;), name = &quot;Experimental\\nCondition&quot;, breaks = c(&quot;ctrl&quot;, &quot;trt1&quot;, &quot;trt2&quot;), labels = c(&quot;Control&quot;, &quot;Treatment 1&quot;, &quot;Treatment 2&quot;)) 请注意，这并未更改 x 轴标签。 有关如何修改轴标签的信息，请参见坐标轴。 如果使用折线图，则可能需要使用 scale_colour_xxx() 或 scale_shape_xxx() 而不是 scale_fill_xxx()。 颜色映射到线条和点的颜色，而填充映射到区域填充的颜色。 形状映射到点的形状。 我们将在这里为线图使用不同的数据集，因为 PlantGrowth 数据集不适用于折线图。 # 一个不同的数据集 df1 &lt;- data.frame(sex = factor(c(&quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;)), time = factor(c(&quot;Lunch&quot;, &quot;Dinner&quot;, &quot;Lunch&quot;, &quot;Dinner&quot;), levels = c(&quot;Lunch&quot;, &quot;Dinner&quot;)), total_bill = c(13.53, 16.81, 16.24, 17.42)) # 基本的图表 lp &lt;- ggplot(data = df1, aes(x = time, y = total_bill, group = sex, shape = sex)) + geom_line() + geom_point() lp # 更改图例 lp + scale_shape_discrete(name = &quot;Payer&quot;, breaks = c(&quot;Female&quot;, &quot;Male&quot;), labels = c(&quot;Woman&quot;, &quot;Man&quot;)) 如果你同时使用 colour 和 shape，它们都需要给出比例规格。 否则会有两个独立的图例。 # 指定颜色和形状 lp1 &lt;- ggplot(data = df1, aes(x = time, y = total_bill, group = sex, shape = sex, colour = sex)) + geom_line() + geom_point() lp1 # 如果你仅仅指定颜色，将会发生 lp1 + scale_colour_discrete(name = &quot;Payer&quot;, breaks = c(&quot;Female&quot;, &quot;Male&quot;), labels = c(&quot;Woman&quot;, &quot;Man&quot;)) # 指定的颜色和形状 lp1 + scale_colour_discrete(name = &quot;Payer&quot;, breaks = c(&quot;Female&quot;, &quot;Male&quot;), labels = c(&quot;Woman&quot;, &quot;Man&quot;)) + scale_shape_discrete(name = &quot;Payer&quot;, breaks = c(&quot;Female&quot;, &quot;Male&quot;), labels = c(&quot;Woman&quot;, &quot;Man&quot;)) 9.7.2.5.3 比例尺的种类 比例尺有很多种。 它们采用「scale_xxx_yyy」的形式。 以下是一些常用的 xxx 和 yyy 值： xxx 描述 colour 线和点的颜色 fill 填充区域的颜色 (比如：柱状图) 线条类型 Solid/dashed/dotted lines 形状 点的形状 大小 Size of points alpha 不透明度/透明度 yyy 描述 hue 色轮的颜色相同 manual 手动指定的值（例如，颜色，点形状，线型） gradient 颜色渐变 grey Shades of grey discrete 不连续的值 (比如颜色，点的形状，线条类型，点的大小 continuous 连续的值（透明度，颜色，点的大小） 9.7.2.6 更改数据框中的因子 更改图例标题和标签的另一种方法是直接修改数据框。 pg &lt;- PlantGrowth # 把数据复制到新的数据框 # 重命名列中的列和值 levels(pg$group)[levels(pg$group) == &quot;ctrl&quot;] &lt;- &quot;Control&quot; levels(pg$group)[levels(pg$group) == &quot;trt1&quot;] &lt;- &quot;Treatment 1&quot; levels(pg$group)[levels(pg$group) == &quot;trt2&quot;] &lt;- &quot;Treatment 2&quot; names(pg)[names(pg) == &quot;group&quot;] &lt;- &quot;Experimental Condition&quot; # 查看最终结果的几行 head(pg) #&gt; weight Experimental Condition #&gt; 1 4.17 Control #&gt; 2 5.58 Control #&gt; 3 5.18 Control #&gt; 4 6.11 Control #&gt; 5 4.50 Control #&gt; 6 4.61 Control # 画图 ggplot(data = pg, aes(x = `Experimental Condition`, y = weight, fill = `Experimental Condition`)) + geom_boxplot() 图例标题“实验条件”很长，如果它被分成两行可能看起来更好，但是这种方法效果不好，因为你必须在列的名称中加上一个换行符。另一种方法，有尺度，通常是更好的方法。 另请注意使用反引号而不是引号。由于变量名中的空格，它们是必需的。 9.7.2.7 修改图例标题和标签的外观 # 题目外观 bp + theme(legend.title = element_text(colour = &quot;blue&quot;, size = 16, face = &quot;bold&quot;)) # 标签外观 bp + theme(legend.text = element_text(colour = &quot;blue&quot;, size = 16, face = &quot;bold&quot;)) 9.7.2.8 修改图例框 默认情况下，图例周围没有框。 添加框并修改其属性: bp + theme(legend.background = element_rect()) bp + theme(legend.background = element_rect(fill = &quot;gray90&quot;, size = 0.5, linetype = &quot;dotted&quot;)) 9.7.2.9 改变图例位置 将图例位置放在绘图区域外（左/右/上/下）: bp + theme(legend.position = &quot;top&quot;) 也可以将图例定位在绘图区域内。 请注意，下面的数字位置是相对于整个区域的，包括标题和标签，而不仅仅是绘图区域。 # 将图例放在图表中，其中 x，y 为 0, 0（左下角）到 1, # 1（右上角） bp + theme(legend.position = c(0.5, 0.5)) # 设置图例的「锚点」（左下角为 0, 0; 右上角为 1, 1） # 将图例框的左下角放在图的左下角 bp + theme(legend.justification = c(0, 0), legend.position = c(0, 0)) # 将图例框的右下角放在图表的右下角 bp + theme(legend.justification = c(1, 0), legend.position = c(1, 0)) 9.7.2.10 隐藏在图例中的斜线 如果使用轮廓制作条形图（通过设置 color = “black”），它将通过图例中的颜色绘制斜线。 没有内置的方法来删除斜杠，但可以覆盖它们。 # 没有边缘线 ggplot(data = PlantGrowth, aes(x = group, fill = group)) + geom_bar() # 添加轮廓，但图例中会出现斜线 ggplot(data = PlantGrowth, aes(x = group, fill = group)) + geom_bar(colour = &quot;black&quot;) # 隐藏斜线：首先绘制没有轮廓的条形图并添加图例, # 然后用轮廓再次绘制条形图，但带有空白图例. ggplot(data = PlantGrowth, aes(x = group, fill = group)) + geom_bar() + geom_bar(colour = &quot;black&quot;, show.legend = FALSE) 9.7.3 注意 更多信息，请阅读 ggplot2-图例属性。 9.8 线条 9.8.1 问题 你想要把线条加到图上。 9.8.2 方案 9.8.2.1 使用一个连续轴和一个分类轴 # 一些样本数据 dat &lt;- read.table(header = TRUE, text = &quot; cond result control 10 treatment 11.5 &quot;) library(ggplot2) 9.8.2.1.1 一条线段 这些使用 geom_hline()，因为y轴是连续的，但如果x轴是连续的，也可以使用 geom_vline()（带有 xintercept）。 # 基本柱状条 bp &lt;- ggplot(dat, aes(x = cond, y = result)) + geom_bar(position = position_dodge(), stat = &quot;identity&quot;) bp # 添加水平线 bp + geom_hline(aes(yintercept = 12)) # 使线条变红并变为虚线 bp + geom_hline(aes(yintercept = 12), colour = &quot;#990000&quot;, linetype = &quot;dashed&quot;) 9.8.2.1.2 每个分类值的单独行 要为每个条形成单独的行，请使用 geom_errorbar()。 # 为每个条形绘制单独的线条。 首先添加另一列到目前为止 dat$hline &lt;- c(9, 12) dat #&gt; cond result hline #&gt; 1 control 10.0 9 #&gt; 2 treatment 11.5 12 # 需要重新指定 bp，因为数据已经改变 bp &lt;- ggplot(dat, aes(x = cond, y = result)) + geom_bar(position = position_dodge(), stat = &quot;identity&quot;) # 为每个柱状图画分开的线条 bp + geom_errorbar(aes(ymax = hline, ymin = hline), colour = &quot;#AA0000&quot;) # 让线条更细一点 bp + geom_errorbar(width = 0.5, aes(ymax = hline, ymin = hline), colour = &quot;#AA0000&quot;) # 即使我们从第二个数据框获得 hline # 值，也可以得到相同的结果 使用 hline 定义数据框 dat_hlines &lt;- data.frame(cond = c(&quot;control&quot;, &quot;treatment&quot;), hline = c(9, 12)) dat_hlines #&gt; cond hline #&gt; 1 control 9 #&gt; 2 treatment 12 # 柱状图形来自 dat，但是线条来自 dat_hlines bp + geom_errorbar(data = dat_hlines, aes(y = NULL, ymax = hline, ymin = hline), colour = &quot;#AA0000&quot;) 9.8.2.1.3 分组栏上的线条 可以在分组条上添加线条。 在这个例子中，实际上有四行（hline 的每个条目一行），但它看起来像两个，因为它们是相互重叠的。 我不认为可以避免这种情况，但它不会导致任何问题。 dat &lt;- read.table(header = TRUE, text = &quot; cond group result hline control A 10 9 treatment A 11.5 12 control B 12 9 treatment B 14 12 &quot;) dat #&gt; cond group result hline #&gt; 1 control A 10.0 9 #&gt; 2 treatment A 11.5 12 #&gt; 3 control B 12.0 9 #&gt; 4 treatment B 14.0 12 # 定义基本柱状图 bp &lt;- ggplot(dat, aes(x = cond, y = result, fill = group)) + geom_bar(position = position_dodge(), stat = &quot;identity&quot;) bp # 误差线相互绘制 - 有四个但看起来像两个 bp + geom_errorbar(aes(ymax = hline, ymin = hline), linetype = &quot;dashed&quot;) 9.8.2.2 各个组合柱状图上的线条 即使在分组时，也可以在每个单独的条上划线。 dat &lt;- read.table(header = TRUE, text = &quot; cond group result hline control A 10 11 treatment A 11.5 12 control B 12 12.5 treatment B 14 15 &quot;) # 定义基本条形图 bp &lt;- ggplot(dat, aes(x = cond, y = result, fill = group)) + geom_bar(position = position_dodge(), stat = &quot;identity&quot;) bp bp + geom_errorbar(aes(ymax = hline, ymin = hline), linetype = &quot;dashed&quot;, position = position_dodge()) 9.8.2.3 有两个连续轴 样本数据如下： dat &lt;- read.table(header = TRUE, text = &quot; cond xval yval control 11.5 10.8 control 9.3 12.9 control 8.0 9.9 control 11.5 10.1 control 8.6 8.3 control 9.9 9.5 control 8.8 8.7 control 11.7 10.1 control 9.7 9.3 control 9.8 12.0 treatment 10.4 10.6 treatment 12.1 8.6 treatment 11.2 11.0 treatment 10.0 8.8 treatment 12.9 9.5 treatment 9.1 10.0 treatment 13.4 9.6 treatment 11.6 9.8 treatment 11.5 9.8 treatment 12.0 10.6 &quot;) library(ggplot2) 9.8.2.3.1 基础线条 # 基本的散点图 sp &lt;- ggplot(dat, aes(x = xval, y = yval, colour = cond)) + geom_point() # 添加一个水平线条 sp + geom_hline(aes(yintercept = 10)) # 添加红色虚线垂直线 sp + geom_hline(aes(yintercept = 10)) + geom_vline(aes(xintercept = 11.5), colour = &quot;#BB0000&quot;, linetype = &quot;dashed&quot;) 9.8.2.3.2 画线为平均值 还可以按一些变量分组计算每个数据子集的平均值。 组别必须计算并存储在单独的列中，最简单的方法是使用 dplyr 包。请注意，该行的 y 范围由数据确定。 library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:plyr&#39;: #&gt; #&gt; arrange, count, desc, failwith, id, mutate, #&gt; rename, summarise, summarize #&gt; The following object is masked from &#39;package:car&#39;: #&gt; #&gt; recode #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union lines &lt;- dat %&gt;% group_by(cond) %&gt;% summarise(x = mean(xval), ymin = min(yval), ymax = max(yval)) # 为每组的平均 xval 添加彩色线条 sp &lt;- sp + geom_hline(aes(yintercept = 10)) + geom_linerange(aes(x = x, y = NULL, ymin = ymin, ymax = ymax), data = lines) sp 9.8.2.3.3 在分面使用线条 一般来说，如果你加一条线，它将出现在所有的分面上。 # 分面，基于cond spf &lt;- sp + facet_grid(. ~ cond) spf # 用相同的值在所有的分面上画水平线 spf + geom_hline(aes(yintercept = 10)) 如果你希望不同的线条出现在不同的方面，有两个选项。 一种是创建具有所需线条值的新数据框。 另一种选择（控制更有限）是在 geom_line() 中设定 stat 和 xintercept。 dat_vlines &lt;- data.frame(cond = levels(dat$cond), xval = c(10, 11.5)) dat_vlines #&gt; cond xval #&gt; 1 control 10.0 #&gt; 2 treatment 11.5 spf + geom_hline(aes(yintercept = 10)) + geom_vline(aes(xintercept = xval), data = dat_vlines, colour = &quot;#990000&quot;, linetype = &quot;dashed&quot;) spf + geom_hline(aes(yintercept = 10)) + geom_linerange(aes(x = x, y = NULL, ymin = ymin, ymax = ymax), data = lines) 9.9 分面 9.9.1 问题 你想要根据一个或多个变量对数据进行分割并且绘制出该数据所有的子图。 9.9.2 方案 9.9.2.1 样本数据 以下例子将使用 reshape2 包中的 tips 数据集 library(reshape2) # 查看头几行数据 head(tips) #&gt; total_bill tip sex smoker day time size #&gt; 1 16.99 1.01 Female No Sun Dinner 2 #&gt; 2 10.34 1.66 Male No Sun Dinner 3 #&gt; 3 21.01 3.50 Male No Sun Dinner 3 #&gt; 4 23.68 3.31 Male No Sun Dinner 2 #&gt; 5 24.59 3.61 Female No Sun Dinner 4 #&gt; 6 25.29 4.71 Male No Sun Dinner 4 根据小费 (tip) 占总账单 (total_bill) 的百分比绘制散点图 library(ggplot2) sp &lt;- ggplot(tips, aes(x = total_bill, y = tip/total_bill)) + geom_point(shape = 1) sp 9.9.2.2 facet_grid 根据一个或多个变量对数据进行分割，生成的子图按照水平或垂直的方向进行排列。这一功能是通过赋予 facet_grid() 函数一个 vertical ~ horizontal 公式来实现的（这里所说的「公式」是 R 中的一种数据结构，而不是数学意义上的公式）。 # 根据 &#39;sex&#39; 按垂直方向分割 sp + facet_grid(sex ~ .) # 根据 &#39;sex&#39; 按水平方向分割。 sp + facet_grid(. ~ sex) # 垂直方向以 &#39;sex&#39; 分割，水平方向以 &#39;day&#39; 分割。 sp + facet_grid(sex ~ day) 9.9.2.3 facet_wrap 除了能够根据单个变量在水平或垂直方向上对图进行分面，facet_wrap() 函数可以通过设置特定的行数或列数，让子图排列到一起。此时每个图像的上方都会有标签。 # 以变量 `day` 进行水平分面，分面的行数为2。 sp + facet_wrap(~day, ncol = 2) 9.9.2.4 修改分面标签的外观 sp + facet_grid(sex ~ day) + theme(strip.text.x = element_text(size = 8, angle = 75), strip.text.y = element_text(size = 12, face = &quot;bold&quot;), strip.background = element_rect(colour = &quot;red&quot;, fill = &quot;#CCCCFF&quot;)) 9.9.2.5 修改分面标签的文本 修改分面标签内容有两种方法。最简单的方法是为原来的名字匹配一个新的名字向量。例如，对数据中 sex 的类别进行重新定义 Female==&gt;Women 和 Male==&gt;Men： labels &lt;- c(Female = &quot;Women&quot;, Male = &quot;Men&quot;) sp + facet_grid(. ~ sex, labeller = labeller(sex = labels)) 另一个方法就是直接在数据框中修改，将你想要显示的标签赋值给相应的数据: tips2 &lt;- tips levels(tips2$sex)[levels(tips2$sex) == &quot;Female&quot;] &lt;- &quot;Women&quot; levels(tips2$sex)[levels(tips2$sex) == &quot;Male&quot;] &lt;- &quot;Men&quot; head(tips2, 3) #&gt; total_bill tip sex smoker day time size #&gt; 1 16.99 1.01 Women No Sun Dinner 2 #&gt; 2 10.34 1.66 Men No Sun Dinner 3 #&gt; 3 21.01 3.50 Men No Sun Dinner 3 sp2 &lt;- ggplot(tips2, aes(x = total_bill, y = tip/total_bill)) + geom_point(shape = 1) sp2 + facet_grid(. ~ sex) 两种方法都能得到相同的结果。 labeller() 可以通过设定不同的 函数 来处理输入的字符向量。比方说 Hmisc 包里的 capitalize 函数可以将字符串的首字母变成大写。我们也可以这样来自定义函数，如下所示，将字符串中的字母倒序： # 对每个字符向量进行倒序： reverse &lt;- function(strings) { strings &lt;- strsplit(strings, &quot;&quot;) vapply(strings, function(x) { paste(rev(x), collapse = &quot;&quot;) }, FUN.VALUE = character(1)) } sp + facet_grid(. ~ sex, labeller = labeller(sex = reverse)) 9.9.2.6 设置标度 一般而言，每幅图的坐标轴范围都是固定不变的，也就是说每幅图都拥有相同的尺寸和范围。你可以通过将 scales 设置为 free，free_x 或 free_y 来改变坐标轴范围。 # 描绘一个 total_bill 的柱状图 hp &lt;- ggplot(tips, aes(x = total_bill)) + geom_histogram(binwidth = 2, colour = &quot;white&quot;) # 根据性别和是否吸烟进行分面 hp + facet_grid(sex ~ smoker) # 在同样的情况下设定 scales=&#39;free_y&#39; (y 轴自由标度） hp + facet_grid(sex ~ smoker, scales = &quot;free_y&quot;) # 画布的缩放比例不变，但各分面的范围有所改变，因此每个分面的物理大小都不一致 hp + facet_grid(sex ~ smoker, scales = &quot;free&quot;, space = &quot;free&quot;) 9.10 多图 9.10.1 问题 你想把多个图形放到同一个页面中。 9.10.2 方案 最简单的方法就是使用 multiplot() 函数。 multiplot() 函数可以将任意数量的图像对象作为参数，或者可以构建一个图像对象列表传递到该函数的 plotlist 参数中。 # 多图功能 ggplot 对象可以直接放入 `…` 中，也可以传递到 # `plotlist` 里（这里的 ggplot 对象以列表形式存在） - # cols: 图像的列数 - layout: # 用来指定布局的一组矩阵。当其存在时，可以忽略 `cols` # 参数。 假设 layout 参数是 matrix(c(1,2,3,3), nrow=2, # byrow = TRUE), # 那么第一幅图像会位于左上方，第二幅图会在右上方，而 # 第三幅图会占据整个下方。 multiplot &lt;- function(..., plotlist = NULL, file, cols = 1, layout = NULL) { library(grid) # 从参数 `…`中建立一个列表然后 plotlist plots &lt;- c(list(...), plotlist) numPlots = length(plots) # 假如 layout 是 NULL, 那么可以用 `cols` 来定义布局 if (is.null(layout)) { # 创建面板 ncol: 图像的列数 nrow: # 根据上述给定的列数，计算所需要的行数 layout &lt;- matrix(seq(1, cols * ceiling(numPlots/cols)), ncol = cols, nrow = ceiling(numPlots/cols)) } if (numPlots == 1) { print(plots[[1]]) } else { # 创建页面 grid.newpage() pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout)))) # 让每一幅图像排列在正确的位置 for (i in 1:numPlots) { # 获取包含这一子图所在区域的坐标 matrix i,j matchidx &lt;- as.data.frame(which(layout == i, arr.ind = TRUE)) print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row, layout.pos.col = matchidx$col)) } } } 如果它不能满足你的需求，你可以将其复制下来然后作出适当的修改。 首先，构建并保存图像但不需要对它们进行渲染，这些图像的细节并不重要。你只需要将这些图像对象储存为变量。 # 以下例子使用的是 ggplot2 包中自带的 Chickweight 数据集 # 第一幅图像 p1 &lt;- ggplot(ChickWeight, aes(x = Time, y = weight, colour = Diet, group = Chick)) + geom_line() + ggtitle(&quot;Growth curve for individual chicks&quot;) # 第二幅图像 p2 &lt;- ggplot(ChickWeight, aes(x = Time, y = weight, colour = Diet)) + geom_point(alpha = 0.3) + geom_smooth(alpha = 0.2, size = 1) + ggtitle(&quot;Fitted growth curve per diet&quot;) # 第三幅图像 p3 &lt;- ggplot(subset(ChickWeight, Time == 21), aes(x = weight, colour = Diet)) + geom_density() + ggtitle(&quot;Final weight, by diet&quot;) # 第四幅图像 p4 &lt;- ggplot(subset(ChickWeight, Time == 21), aes(x = weight, fill = Diet)) + geom_histogram(colour = &quot;black&quot;, binwidth = 50) + facet_grid(Diet ~ .) + ggtitle(&quot;Final weight, by diet&quot;) + theme(legend.position = &quot;none&quot;) #为了避免冗余，这里不添加图例 这些图像都构建好了后，我们可以用 multiplot() 对它们进行渲染。下面将这些图形分成两列进行展示： multiplot(p1, p2, p3, p4, cols = 2) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 9.11 颜色 9.11.1 问题 你想在图表中用 ggplot2 添加颜色。 9.11.2 方案 在 ggplot2 中设置颜色，对相互区分不同变量会有些困难，因为这些颜色有一样的亮度，且对色盲者不太友好。一个比较好的通用解决方案是使用对色盲友好的颜色。 9.11.2.1 样本数据 这两个数据集将用来产生下面的图表： # 两个变量 df &lt;- read.table(header = TRUE, text = &quot; cond yval A 2 B 2.5 C 1.6 &quot;) # 三个变量 df2 &lt;- read.table(header = TRUE, text = &quot; cond1 cond2 yval A I 2 A J 2.5 A K 1.6 B I 2.2 B J 2.4 B K 1.2 C I 1.7 C J 2.3 C K 1.9 &quot;) 9.11.2.2 简单的颜色设置 有颜色的线条和点可以直接用 colour = &quot;red&quot;, 用颜色名称代替 &quot;red&quot;。填充的对象的颜色，如柱状条，可以用 fill=&quot;red&quot; 来进行设置。 如果你想用任何其他非常规颜色，用十六进位码来设置颜色更容易，比如 #FF6699。 library(ggplot2) # 设置：黑色柱状条 ggplot(df, aes(x=cond, y=yval)) + geom_bar(stat=&quot;identity&quot;) # 柱状条外用红色边线 ggplot(df, aes(x=cond, y=yval)) + geom_bar(stat=&quot;identity&quot;, colour=&quot;#FF9999&quot;) # 红色填充，黑色边线 ggplot(df, aes(x=cond, y=yval)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;#FF9999&quot;, colour=&quot;black&quot;) # 标准黑色线条和点 ggplot(df, aes(x=cond, y=yval)) + geom_line(aes(group=1)) + geom_point(size=3) # 蓝黑色线条，红色点 ggplot(df, aes(x=cond, y=yval)) + geom_line(aes(group=1), colour=&quot;#000099&quot;) + # 蓝线 geom_point(size=3, colour=&quot;#CC0000&quot;) # 红点 9.11.2.3 将变量值映射到颜色 不用全局改变颜色，你可以将变量映射到颜色——换言之，通过把颜色放到 aes() 函数中，可以设置条件性变量。 # 柱状条: x 和填充都依赖于cond2 ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) # 其他数据集的柱状条；填充依赖于cond2 ggplot(df2, aes(x=cond1, y=yval)) + geom_bar(aes(fill=cond2), # 填充依赖于cond2 stat=&quot;identity&quot;, colour=&quot;black&quot;, # 所有都是黑色轮廓线 position=position_dodge()) # 把线条并排放置而非堆叠 # 线和点；颜色依赖于cond2 ggplot(df2, aes(x=cond1, y=yval)) + geom_line(aes(colour=cond2, group=cond2)) + # 颜色分组都依赖于cond2 geom_point(aes(colour=cond2), # 颜色依赖于cond2 size=3) # 更大的点，不同的形状 # 以上操作等价; 但把 &quot;colour=cond2&quot; 移到全局的映射用aes() # ggplot(df2, aes(x=cond1, y=yval, colour=cond2)) + # geom_line(aes(group=cond2)) + # geom_point(size=3) 9.11.2.4 对色盲友好的颜色 下面这些是对色盲友好的颜色色板，一个用灰色，一个用黑色： 为了用 ggplot2, 我们在一个变量里储存颜色色板，然后之后调用。 # 灰色的颜色色板: cbPalette &lt;- c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;) # 黑色的颜色色板k: cbbPalette &lt;- c(&quot;#000000&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;) # 为了填充颜色，加 scale_fill_manual(values = cbPalette) #&gt; &lt;ggproto object: Class ScaleDiscrete, Scale, gg&gt; #&gt; aesthetics: fill #&gt; axis_order: function #&gt; break_info: function #&gt; break_positions: function #&gt; breaks: waiver #&gt; call: call #&gt; clone: function #&gt; dimension: function #&gt; drop: TRUE #&gt; expand: waiver #&gt; get_breaks: function #&gt; get_breaks_minor: function #&gt; get_labels: function #&gt; get_limits: function #&gt; guide: legend #&gt; is_discrete: function #&gt; is_empty: function #&gt; labels: waiver #&gt; limits: NULL #&gt; make_sec_title: function #&gt; make_title: function #&gt; map: function #&gt; map_df: function #&gt; n.breaks.cache: NULL #&gt; na.translate: TRUE #&gt; na.value: NA #&gt; name: waiver #&gt; palette: function #&gt; palette.cache: NULL #&gt; position: left #&gt; range: &lt;ggproto object: Class RangeDiscrete, Range, gg&gt; #&gt; range: NULL #&gt; reset: function #&gt; train: function #&gt; super: &lt;ggproto object: Class RangeDiscrete, Range, gg&gt; #&gt; reset: function #&gt; scale_name: manual #&gt; train: function #&gt; train_df: function #&gt; transform: function #&gt; transform_df: function #&gt; super: &lt;ggproto object: Class ScaleDiscrete, Scale, gg&gt; # 为了在点线中使用颜色，加 scale_colour_manual(values = cbPalette) #&gt; &lt;ggproto object: Class ScaleDiscrete, Scale, gg&gt; #&gt; aesthetics: colour #&gt; axis_order: function #&gt; break_info: function #&gt; break_positions: function #&gt; breaks: waiver #&gt; call: call #&gt; clone: function #&gt; dimension: function #&gt; drop: TRUE #&gt; expand: waiver #&gt; get_breaks: function #&gt; get_breaks_minor: function #&gt; get_labels: function #&gt; get_limits: function #&gt; guide: legend #&gt; is_discrete: function #&gt; is_empty: function #&gt; labels: waiver #&gt; limits: NULL #&gt; make_sec_title: function #&gt; make_title: function #&gt; map: function #&gt; map_df: function #&gt; n.breaks.cache: NULL #&gt; na.translate: TRUE #&gt; na.value: NA #&gt; name: waiver #&gt; palette: function #&gt; palette.cache: NULL #&gt; position: left #&gt; range: &lt;ggproto object: Class RangeDiscrete, Range, gg&gt; #&gt; range: NULL #&gt; reset: function #&gt; train: function #&gt; super: &lt;ggproto object: Class RangeDiscrete, Range, gg&gt; #&gt; reset: function #&gt; scale_name: manual #&gt; train: function #&gt; train_df: function #&gt; transform: function #&gt; transform_df: function #&gt; super: &lt;ggproto object: Class ScaleDiscrete, Scale, gg&gt; 这个颜色集来源于网站： http://jfly.iam.u-tokyo.ac.jp/color/。 图 9.1: 色盲友好调色板 9.11.2.5 颜色选择 默认情况下，离散比例的颜色围绕 HSL 色环均匀分布。例如，如果有两种颜色，那么它们将从圆圈上的相对点中选择; 如果有三种颜色，它们在色环上将相隔 120° 等等。用于不同级别的颜色如下所示： 图 9.2: 均匀色环 默认颜色选择使用 scale_fill_hue() 和 scale_colour_hue()。 例如，在以下情况下添加这些命令是多余的： # 这两个是等价的; 默认使用scale_fill_hue() ggplot(df, aes(x = cond, y = yval, fill = cond)) + geom_bar(stat = &quot;identity&quot;) # ggplot(df, aes(x=cond, y=yval, fill=cond)) + # geom_bar(stat=&#39;identity&#39;) + scale_fill_hue() # 这两个是等价的; 默认使用scale_colour_hue() ggplot(df, aes(x = cond, y = yval, colour = cond)) + geom_point(size = 2) # ggplot(df, aes(x=cond, y=yval, colour=cond)) + # geom_point(size=2) + scale_colour_hue() 9.11.2.6 设置亮度和饱和度（色度） 虽然 scale_fill_hue() 和 scale_colour_hue() 在上面是多余的，但是当你想要改变默认值时，可以使用它们，比如改变亮度或色度。 # 使用 luminance = 45, 而不是默认 65 ggplot(df, aes(x = cond, y = yval, fill = cond)) + geom_bar(stat = &quot;identity&quot;) + scale_fill_hue(l = 40) # 从 100 到 50 减少饱和度（亮度）, 增加亮度 ggplot(df, aes(x = cond, y = yval, fill = cond)) + geom_bar(stat = &quot;identity&quot;) + scale_fill_hue(c = 45, l = 80) # 注意：使用 scale_colour_hue() 设置线和点 亮度为 45 时的颜色图表: 9.11.2.7 调色板：Color Brewer 你还可以使用其他颜色标度，例如从 RColorBrewer 包中获取。 请参阅下面的 RColorBrewers 调色板图表。 ggplot(df, aes(x = cond, y = yval, fill = cond)) + geom_bar(stat = &quot;identity&quot;) + scale_fill_brewer() ggplot(df, aes(x = cond, y = yval, fill = cond)) + geom_bar(stat = &quot;identity&quot;) + scale_fill_brewer(palette = &quot;Set1&quot;) ggplot(df, aes(x = cond, y = yval, fill = cond)) + geom_bar(stat = &quot;identity&quot;) + scale_fill_brewer(palette = &quot;Spectral&quot;) # 注意: 使用 scale_colour_brewer() 设置点和线条 9.11.2.8 调色板：手动定义 最后，你可以使用 scale_fill_manual() 定义自己的颜色集。 有关选择特定颜色的帮助，请参阅下面的十六进制代码表。 ggplot(df, aes(x = cond, y = yval, fill = cond)) + geom_bar(stat = &quot;identity&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) ggplot(df, aes(x = cond, y = yval, fill = cond)) + geom_bar(stat = &quot;identity&quot;) + scale_fill_manual(values = c(&quot;#CC6666&quot;, &quot;#9999CC&quot;, &quot;#66CC99&quot;)) # 注意：使用 scale_colour_manual() 设置线条和点 9.11.2.9 连续颜色 # 产生一些数据 set.seed(133) df &lt;- data.frame(xval = rnorm(50), yval = rnorm(50)) # 依赖 yval设置颜色 ggplot(df, aes(x = xval, y = yval, colour = yval)) + geom_point() # 使用不同的渐变 ggplot(df, aes(x = xval, y = yval, colour = yval)) + geom_point() + scale_colour_gradientn(colours = rainbow(4)) 9.11.2.10 比色图表 9.11.2.11 十六进制色码图 颜色可以指定为十六进制 RGB 三元组合，例如 #0066CC。 前两位数字是红色，接下来的两位是绿色，最后两位是蓝色。 每个值的范围从 00 到 FF，以十六进制（base-16）表示，在 base-10 中等于 0 和 255。 例如，在下表中，#FFFFFF 为白色，#990000 为深红色。 图 9.3: 色码图 色码图来源于 http://www.visibone.com 9.11.2.12 RColorBrewer 调色板图表 图 9.4: 调色板图表 "],
["section-10.html", "第 10 章 图形混杂 10.1 输出到文件 PDF-PNG-TIFF-SVG 10.2 形状和线形 10.3 字体 10.4 抗混淆位图输出", " 第 10 章 图形混杂 10.1 输出到文件 PDF-PNG-TIFF-SVG 10.1.1 问题 你想将图形保存到文件。 10.1.2 方案 R 中有好几种命令可以直接将图形导出为文件而不是打印到屏幕上。另外，你必须通过 dev.off() 命令告诉 R 你已经完成作图了，否则你的图形是不会显示出来的。 10.1.2.1 PDF格式 PDF 是一种矢量文件格式。一般我们都更倾向于将图形输出为矢量图文件，因为这样的图无论怎样缩放都不会出现像素点。矢量图文件的大小通常要比位图文件要小，除非该文件里包含了过多的内容（比如说一张散点图内包含了上千个点，这时候就会造成矢量图大而位图小）。 pdf(&quot;plots.pdf&quot;) dev.off() PDF 默认是 7x7 英寸，并且每个图形都单独占一页。这个尺寸是可以更改的： # 6x3 英寸 pdf(&quot;plots.pdf&quot;, width = 6, height = 3) # 10x6 厘米 pdf(&quot;plots.pdf&quot;, width = 10/2.54, height = 6/2.54) 如果你想在 Inkscape 或者 Illustrator 这样的矢量图编辑器中修改你的文件，图形中的一些绘制点有可能看上去更像是字母而并非原来的圆形或方形等。为了防止这种情况的发生可以输入： pdf(&quot;plots.pdf&quot;, useDingbats = FALSE) 10.1.2.2 SVG 格式 SVG 是另一种矢量图。默认的 svg() 命令无法将多页图形输出到一个文件中，因为大部分的 SVG 浏览软件无法处理多页的 SVG 文件。后面的 PNG 内容中将涉及如何输出到多个文件。 svg(&quot;plots.svg&quot;) dev.off() SVG 文件比 PDF 文件更适合矢量图编辑器。 10.1.2.3 PNG/TIFF格式 PNG 和 TIFF 是位图（栅格图像），对它们进行缩放时可能会出现像素点。 png(&quot;plot.png&quot;) # 或者 tiff(&#39;plot.tiff&#39;) dev.off() 输出的图像默认尺寸为 480x480 像素，分辨率为 72dpi （即 6.66x6.66 英寸） 当分辨率增加时文本与图像元素的大小也会（以像素为单位）增加。这是因为这些元素的大小只与图像的物理大小有关（比如 4x4 英寸），而与图像的像素大小无关。例如，一个 12 磅的字符高度为 12/72 = 1/6 英寸，在分辨率为 72dpi 的情况下，它共包含 12 个像素点；而在分辨率放大到 120dpi 时，它就含有 20 个像素点了。 以下创建一个大小为 480x240 像素，分辨率为 120dpi 的图像,其实际大小相当于 4x2 英寸。 png(&quot;plot.png&quot;, width = 480, height = 240, res = 120) dev.off() 如果你要创建不止一张图像，必须对每张图像执行一个新的 png() 命令，或者将 %d 放置到文件名中: png(&quot;plot-%d.png&quot;) dev.off() 上述代码会生成 plot-1.png, plot-2.png 等系列文件。 10.1.2.4 对于不支持 PDF 格式的程序 （MS Office） 有些不支持 PDF 文件导入的程序一般都需要高分辨率的 PNG 或 TIFF 文件。比如说微软 Office 无法导入 PDF 格式文件。而对于印刷出版物，则需要使用 300dpi 的图像。 # 绘制一幅 6x6 英寸，300dpi 的图像 ppi &lt;- 300 png(&quot;plot.png&quot;, width = 6 * ppi, height = 6 * ppi, res = ppi) plot(...) dev.off() 10.1.2.5 ggplot2 如果你在脚本或函数中使用 ggplot2 进行绘图，必须使用 print() 命令确保图像得到渲染。 # 无效命令 pdf(&quot;plots.pdf&quot;) qplot(...) dev.off() # 正确的做法 pdf(&quot;plots.pdf&quot;) print(qplot(...)) dev.off() 从屏幕中保存一个 ggplot 图像为文件，你可以使用 ggsave()。 ggsave(&quot;plot.pdf&quot;) ggsave(&quot;plot.pdf&quot;, width = 4, height = 4) # 将图形保存为 400x400，100 ppi的文件 ggsave(&quot;plot.png&quot;, width = 4, height = 4, dpi = 100) 10.1.2.6 保存屏幕中的图像 如果你的屏幕中已经有一张图像了，可以将其保存为位图。 这是一种将屏幕中的对象作出从像素到像素的拷贝，不过这种操作很大概率只能在 Linux 和 Mac 的 X11 系统下得以实现： # 在屏幕中绘制一张图形 plot(...) savePlot(&quot;myplot.png&quot;) 这一步是保存屏幕当前图像，并且根据不同的设备对图像进行重新渲染，图像大小可能会因此发生变化。如果你需要图形大小固定，则需要以像素为单位对尺寸进行指定。 # 在屏幕中绘制图像 plot(...) dev.copy(pdf, &quot;myplot.pdf&quot;, width = 4, height = 4) dev.off() # 等同于： pdf(&#39;myplot.pdf&#39;, width=4, height=4) # plot(...) dev.off() dev.copy(png, &quot;myplot.png&quot;, width = 400, height = 400) dev.off() 10.2 形状和线形 10.2.1 问题 你想在图形中使用不同的形状和线条。 10.2.2 方案 在输出位图时，对符号 15-18 的渲染可能不具抗锯齿性，即无论这些图形的绘制是否来自同一个平台，这些符号都有可能会被拉伸变形，出现像素点，或者无法居中。符号 19 和 21-25 在填充部分外周会有边框线，在大部分情况下这种边线在渲染时其边缘都是平滑的。另外，要使符号 21-25 显示实心填充，需要指定与边线颜色 (col) 一致的填充 (bg) 颜色，否则这些符号将会是空心的。 10.2.2.1 标准图形 通过 pch 选项来设置符号形状, 并且通过 lty 和 lwd 来设定线条的类型和粗细。线条的类型可以通过名字或数字来指定。 set.seed(331) # 绘制一些点线 # 设定绘画范围 par(mar=c(3,3,2,2)) plot(NA, xlim=c(1,4), ylim=c(0,1)) # 绘制实心圆和实线 points(1:4, runif(4), type=&quot;b&quot;, pch=19) # 添加空心方框和粗虚线 points(1:4, runif(4), type=&quot;b&quot;, pch=0, lty=2, lwd=3) points(1:4, runif(4), type=&quot;b&quot;, pch=23, # 菱形符号 lty=&quot;dotted&quot;, cex=2, # 点状线, 符号形状放大一倍 col=&quot;#000099&quot;, bg=&quot;#FF6666&quot;) # 线条蓝色，符号形状红色填充 10.2.2.2 ggplot2 在调用 ggplot2 的情况下，可以对图中的符号形状和线条类型进行全局的部署（比方说你想让所有数据点都是方形，所有的线条都为虚线），或者通过一个变量来调整它们。 # 示例数据 df &lt;- read.table(header=T, text=&#39; cond xval yval A 1 2.0 A 2 2.5 B 1 3.0 B 2 2.0 &#39;) library(ggplot2) # 使用标准的线条和符号形状作图 # 用 group = cond 表示点线之间的对应关系 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line() + geom_point() # 设置全局的符号形状和线条类型 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line(linetype=&quot;dashed&quot;, # 虚线 size = 1.5) + # 加粗 geom_point(shape = 0, # 空心方块 size = 4) # 放大形状 # 通过变量 cond 调整符号图形和线类型 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line(aes(linetype=cond), # cond 决定线条类型 size = 1.5) + # 线条加粗 geom_point(aes(shape=cond), # cond 决定形状 size = 4) # 放大形状 # 在上述的基础上同时改变所使用的线条和形状 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line(aes(linetype=cond), # cond 决定线条类型 size = 1.5) + # 线条加粗 geom_point(aes(shape=cond), # cond 决定形状 size = 4) + # 放大形状 scale_shape_manual(values=c(6,5)) + # 更改形状 scale_linetype_manual(values=c(&quot;dotdash&quot;, &quot;dotted&quot;)) # 更改线条类型 一般来说 ggplot2 使用的是实心形状。如果你想要空心的形状又不想手动地对每个形状进行定义，可以设定 scale_shape(solid=FALSE)。注意，这个时候形状空心部分中的线条是可见的。为了避免这种情况，你可以使用符号形状 21-25 并且指定白色填充。 # 空心形状 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line(aes(linetype=cond), # cond 决定线条类型 size = 1.5) + # 线条加粗 geom_point(aes(shape=cond), # cond 决定符号形状 size = 4) + # 放大形状 scale_shape(solid=FALSE) # 白色填充形状 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line(aes(linetype=cond), # cond 决定线条类型 size = 1.5) + # 线条加粗 geom_point(aes(shape=cond), # cond 决定符号形状 fill = &quot;white&quot;, # 白色填充 size = 4) + # 放大形状 scale_shape_manual(values=c(21,24)) # 形状：实心圆和三角形 10.2.2.3 附录 以下代码会生成本章节开头所示的图表。 par(mar = c(0, 0, 0, 0)) # 设定绘图区域 plot(NA, xlim = c(0, 1), ylim = c(6.5, -0.5), xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, xlab = NA, ylab = NA) # 画线条 for (i in 0:6) { points(c(0.25, 1), c(i, i), lty = i, lwd = 2, type = &quot;l&quot;) } # 添加标签 text(0, 0, &quot;0. &#39;blank&#39;&quot;, adj = c(0, 0.5)) text(0, 1, &quot;1. &#39;solid&#39;&quot;, adj = c(0, 0.5)) text(0, 2, &quot;2. &#39;dashed&#39;&quot;, adj = c(0, 0.5)) text(0, 3, &quot;3. &#39;dotted&#39;&quot;, adj = c(0, 0.5)) text(0, 4, &quot;4. &#39;dotdash&#39;&quot;, adj = c(0, 0.5)) text(0, 5, &quot;5. &#39;longdash&#39;&quot;, adj = c(0, 0.5)) text(0, 6, &quot;6. &#39;twodash&#39;&quot;, adj = c(0, 0.5)) 10.3 字体 10.3.1 问题 你想在图像中使用不同的字体。 10.3.2 方案 更新: 查看 extrafont 包相关内容，该包能更好地支持 PDF 和 Windows 位图中的字体设定。 R 在一般情况下都不能很好地支持字体的显示。在不同的操作系统和不同的输出格式中都会出现不一样的结果。 10.3.2.1 geom_text 通过 ggplot2 中的 geom_text() or annotate() , 你可以对图形文本中的一系列属性进行设置。 geom_text() 用于将数据框中的文本加入到图表中，而 annotate() 则用于往图表中添加单个文本元素。 Name Default value size 5 family &quot;&quot; (sans) fontface plain lineheight 1.2 angle 0 hjust 0.5 vjust 0.5 注意这里 size 的单位是毫米, 而非磅。 dat &lt;- data.frame(y = 1:3, text = c(&quot;This is text&quot;, &quot;Text with\\nmultiple lines&quot;, &quot;Some more text&quot;)) library(ggplot2) p &lt;- ggplot(dat, aes(x = 1, y = y)) + scale_y_continuous(limits = c(0.5, 3.5), breaks = NULL) + scale_x_continuous(breaks = NULL) p + geom_text(aes(label = text)) p + geom_text(aes(label = text), family = &quot;Times&quot;, fontface = &quot;italic&quot;, lineheight = 0.8) + annotate(geom = &quot;text&quot;, x = 1, y = 1.5, label = &quot;Annotation text&quot;, colour = &quot;red&quot;, size = 7, family = &quot;Courier&quot;, fontface = &quot;bold&quot;, angle = 30) 10.3.2.2 theme() 和 element_text() 在管理类似标题，图注，坐标轴标签等元素时，可以使用 element_text(), 其参数设置跟 geom_text() 基本一致, 除了 size 的单位是 points (而非 mm), 还有就是它用的是 face 而不是 fontface 。默认情况下，size 取决于元素，比如图形标题的字体总是比刻度标签的大。 p + geom_point() + ggtitle(&quot;This is a Title&quot;) + theme(plot.title = element_text(family = &quot;Times&quot;, face = &quot;bold&quot;, size = 20)) 10.3.2.3 字体表格 你可以运行下列代码来生成一张不同字体的图形表。 每种字体都有简称和字体标准家族名称，定义字体时使用其中一种即可。 fonttable &lt;- read.table(header = TRUE, sep = &quot;,&quot;, stringsAsFactors = FALSE, text = &quot; Short,Canonical mono,Courier sans,Helvetica serif,Times ,AvantGarde ,Bookman ,Helvetica-Narrow ,NewCenturySchoolbook ,Palatino ,URWGothic ,URWBookman ,NimbusMon URWHelvetica,NimbusSan ,NimbusSanCond ,CenturySch ,URWPalladio URWTimes,NimbusRom &quot;) fonttable$pos &lt;- 1:nrow(fonttable) library(reshape2) fonttable &lt;- melt(fonttable, id.vars = &quot;pos&quot;, measure.vars = c(&quot;Short&quot;, &quot;Canonical&quot;), variable.name = &quot;NameType&quot;, value.name = &quot;Font&quot;) # 创建一个分面形式的图表。确保因子的顺序是正确的 facetable &lt;- data.frame(Face = factor(c(&quot;plain&quot;, &quot;bold&quot;, &quot;italic&quot;, &quot;bold.italic&quot;), levels = c(&quot;plain&quot;, &quot;bold&quot;, &quot;italic&quot;, &quot;bold.italic&quot;))) fullfonts &lt;- merge(fonttable, facetable) library(ggplot2) pf &lt;- ggplot(fullfonts, aes(x = NameType, y = pos)) + geom_text(aes(label = Font, family = Font, fontface = Face)) + facet_wrap(~Face, ncol = 2) 在屏幕中查看: pf 你在屏幕中所看见的不一定跟你输出为 PNG 或 PDF 格式后的结果完全一样。查看 PNG 格式的输出结果： png(&quot;fonttable.png&quot;, width = 720, height = 720, res = 72) print(pf) dev.off() #&gt; quartz_off_screen #&gt; 2 需要注意的是，对于生成这张图片的操作系统来说，大部分的字体（位于顶部）是不兼容的，只有一些基础字体（位于底部）是可以使用的。 PDF 格式输出结果(以下示例图已从 PDF 格式转化为 PNG 格式）: pdf(&quot;fonttable.pdf&quot;, width = 10, height = 10) print(pf) dev.off() # 用 GraphicsMagick 将 PDF 转化为PNG格式: system(&#39;gm # convert -resize 720x720 -background white # fonttable.pdf fonttable-pdf.png&#39;) PDF 设备对于不同字体的支持比 PNG 设备更好。基本所有的字体都能兼容（虽然这些字体并不一定很好看）。 10.4 抗混淆位图输出 10.4.1 问题 你想要在 windows 操作环境下保存抗锯齿的位图结果（抗锯齿位图介绍）。 10.4.2 方案 类似于 png 和 jpeg 的标准图形设备可以将图形保存成 cairo、Xlib、 quartz 三种不同的文件格式。当使用 cairo，我们便可以获得抗锯齿化的图形结果。在 MacOS 和 linux 系统下，自动将图片保存为 cairo 格式，但是在 windows 系统下的相应参数是 NULL。 绘图示例： # 设置伪随机数种子 set.seed(1) # 生成符合正态分布的100个随机数 x = rnorm(100) png(&quot;antialiasing_1.png&quot;, type = &quot;cairo&quot;) plot(x) dev.off() #&gt; quartz_off_screen #&gt; 2 在 windows 系统环境下不可强行使用 type=&quot;cairo&quot;，需要借助 Cairo 工具包获取抗锯齿化结果。 # 安装Cairo包 install.packages(&#39;Cairo&#39;) library(&quot;Cairo&quot;) # 设置伪随机数种子 set.seed(1) # 生成符合正态分布的100个随机数 x = rnorm(100) Cairo(width = 540, height = 380, file = &quot;antialiasing_2.png&quot;, type = &quot;png&quot;, bg = &quot;white&quot;) plot(x) dev.off() #&gt; quartz_off_screen #&gt; 2 10.4.2.1 提示 有关该部分的更多相关信息，参阅 Efficient R programming。 "],
["section-11.html", "第 11 章 其他有趣图形 11.1 相关矩阵", " 第 11 章 其他有趣图形 11.1 相关矩阵 11.1.1 问题 你想要可视化多元变量间的相关性强度。 11.1.2 方案 假设所要分析的数据（如下）： # 设置伪随机数种子 set.seed(955) # 生成符合正态分布的20个随机数 vvar &lt;- 1:20 + rnorm(20, sd = 3) wvar &lt;- 1:20 + rnorm(20, sd = 5) xvar &lt;- 20:1 + rnorm(20, sd = 3) yvar &lt;- (1:20)/2 + rnorm(20, sd = 10) zvar &lt;- rnorm(20, sd = 6) # 使用向量生成数据框（向量名为列名） data &lt;- data.frame(vvar, wvar, xvar, yvar, zvar) head(data) #&gt; vvar wvar xvar yvar zvar #&gt; 1 -4.252 5.122 16.02 -15.156 -4.087 #&gt; 2 1.702 -1.323 15.84 -24.064 3.468 #&gt; 3 4.323 -2.157 19.86 2.307 -3.045 #&gt; 4 1.781 0.788 17.65 2.565 1.449 #&gt; 5 11.537 -1.308 10.93 9.601 2.762 #&gt; 6 6.672 2.014 15.24 -3.466 5.750 可视化上述数据： # 导入以椭圆表征相关性强度的分析包 library(ellipse) #&gt; #&gt; Attaching package: &#39;ellipse&#39; #&gt; The following object is masked from &#39;package:car&#39;: #&gt; #&gt; ellipse #&gt; The following object is masked from &#39;package:graphics&#39;: #&gt; #&gt; pairs # 生成相关矩阵表 ctab &lt;- cor(data) # 表中数据保留两位小数 round(ctab, 2) #&gt; vvar wvar xvar yvar zvar #&gt; vvar 1.00 0.61 -0.85 0.75 -0.21 #&gt; wvar 0.61 1.00 -0.81 0.54 -0.31 #&gt; xvar -0.85 -0.81 1.00 -0.63 0.24 #&gt; yvar 0.75 0.54 -0.63 1.00 -0.30 #&gt; zvar -0.21 -0.31 0.24 -0.30 1.00 # 设置简化边幅并绘制相关性图 plotcorr(ctab, mar = c(0.1, 0.1, 0.1, 0.1)) # 使用颜色表征相关性强度 colorfun &lt;- colorRamp(c(&quot;#CC0000&quot;, &quot;white&quot;, &quot;#3366CC&quot;), space = &quot;Lab&quot;) plotcorr(ctab, col = rgb(colorfun((ctab + 1)/2), maxColorValue = 255), mar = c(0.1, 0.1, 0.1, 0.1)) 11.1.2.1 提示 有关生成数值关联表的更多信息，查看回归和相关分析。 "],
["section-12.html", "第 12 章 脚本与函数 12.1 创建和运行一个脚本 12.2 调试脚本或函数 12.3 测量运行的时间 12.4 获取包中的函数和对象列表", " 第 12 章 脚本与函数 12.1 创建和运行一个脚本 12.1.1 问题 你想要创建和运行一个脚本。 12.1.2 方案 R 脚本通常是以 .R 为文件拓展名的纯文本文件。因此创建R脚本可以是任意的文本编辑器，R 最佳的集成开发环境是 RStudio，它开源并有免费的桌面版本和服务器版本发布，推荐读者下载、安装和使用。 在类 Unix 系统中，除了编辑器，我们还可以使用终端命令。例如，创建一个输出 Hello world! 的 R 脚本。 echo &#39;cat(&quot;Hello world!&quot;)&#39; &gt; test.R 运行 R 脚本可以在 R 控制台使用 source()函数。 source(&quot;test.R&quot;, print.eval = TRUE) #&gt; Hello world! 也可以在终端中使用 RScript 执行。 RScript test.R #&gt; Using library: /Users/wsx/R_library #&gt; 载入需要的程辑包：pacman #&gt; Hello world! 12.1.3 案例：计算细菌基因组核心蛋白相似性 应用场景 细菌分类学研究中，需要借助基因组水平的相似度来界定是否属于新物种，是否是一个未发现的新属水平或者新科水平，乃至更高的分类学单元（界/门/纲/目/科/属/种）。 在基因组的核酸水平研究中，有诸如 dDDH（数字化 DNA 分子杂交）、核苷酸平均相似度（Average Nucleotide Identity，ANI）等指标来界定是否属于新物种；而在基因组蛋白质水平相类似的指标较少，比如氨基酸平均相似度（Average Amino acid Identity，AAI）和保守蛋白比率（percentage of conserved proteins，POCP）等。 简要过程 两两比对细菌基因组的蛋白序列，互为参考数据库进行 blastp 比对（A 作数据库，B 查询；B 作数据库，A 查询），数据筛选的标准是：一致度大于 40%，查询片段的长度大于原片段长度的 50%，e 值小于 1e-5。 参考文献 Qin, Q. L., Xie, B. B., Zhang, X. Y., Chen, X. L., Zhou, B. C., Zhou, J., … &amp; Zhang, Y. Z. (2014). A proposed genus boundary for the prokaryotes based on genomic insights. Journal of bacteriology, 196(12), 2210-2215. 以下 R 脚本都是在 windows 操作平台上进行的。 # 下载所分析的基因组数据（蛋白序列） # 存放于 Rawdata 文件夹中 if (!dir.exists(&#39;Rawdata&#39;)) { dir.create(&#39;Rawdata&#39;) } # 示例-1: Pseudomonas aeruginosa # ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/006/765/GCF_000006765.1_ASM676v1/GCF_000006765.1_ASM676v1_protein.faa.gz # 示例-2: Acinetobacter baumannii # ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/746/645/GCF_000746645.1_ASM74664v1/GCF_000746645.1_ASM74664v1_protein.faa.gz # 使用 R.utils 中的 gunzip 解压缩 library(R.utils) download.file(&quot;ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/006/765/GCF_000006765.1_ASM676v1/GCF_000006765.1_ASM676v1_protein.faa.gz&quot;, destfile = &quot;Rawdata/Pseudomonas_aeruginosa.faa.gz&quot;) gunzip(&quot;Rawdata/Pseudomonas_aeruginosa.faa.gz&quot;) download.file(&quot;ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/746/645/GCF_000746645.1_ASM74664v1/GCF_000746645.1_ASM74664v1_protein.faa.gz&quot;, destfile = &quot;Rawdata/Acinetobacter_baumannii.faa.gz&quot;) gunzip(&quot;Rawdata/Acinetobacter_baumannii.faa.gz&quot;) # 使用 dbplyr 对数据框中的某列去重复 library(dbplyr) # 使用 seqinr 格式化 fasta 格式的序列 library(seqinr) # 检查存放中间过程文件的文件夹是否存在 if (!dir.exists(&#39;Database&#39;)) { dir.create(&#39;Database&#39;) } if (!dir.exists(&#39;Result&#39;)) { dir.create(&#39;Result&#39;) } # 获取所有待分析基因组文件名 genome.files &lt;- list.files(&#39;Rawdata&#39;) # 对所有的待分析基因组建库 for (gn in genome.files) { header.file &lt;- strsplit(gn,&#39;.&#39;,fixed = T)[[1]][1] commond.makedb &lt;- paste0(&#39;diamond.exe makedb --in Rawdata/&#39;, gn, &#39; --db Database/&#39;, header.file) system(commond.makedb) } # 获取多基因组的两两比对的组合数据集 genome.comn &lt;- combn(genome.files,2) # 计算核心蛋白相似性的骨架命令 blast.comm1 &lt;- &#39;diamond.exe blastp -q Rawdata/&#39; blast.comm2 &lt;- &#39; -d Database/&#39; blast.comm3 &lt;- &#39; -e 1e-5 --id 40 -o Result/&#39; # 建立新变量，保存运算结果 pocp.vector &lt;- c() for (i in (1:dim(genome.comn)[2]) ) { a.genome &lt;- genome.comn[,i][1] b.genome &lt;- genome.comn[,i][2] a.header &lt;- strsplit(a.genome,&#39;.&#39;,fixed = T)[[1]][1] b.header &lt;- strsplit(b.genome,&#39;.&#39;,fixed = T)[[1]][1] a.genome.seq &lt;- read.fasta(paste0(&#39;Rawdata/&#39;, a.genome),&#39;AA&#39;) b.genome.seq &lt;- read.fasta(paste0(&#39;Rawdata/&#39;, b.genome),&#39;AA&#39;) a.total &lt;- length(a.genome.seq) b.total &lt;- length(b.genome.seq) str(a.genome.seq) str(b.genome.seq) a.seq.list &lt;- names(a.genome.seq) b.seq.list &lt;- names(b.genome.seq) a.seq.length &lt;- c() for (nm in a.seq.list) { tmp.len &lt;- length(a.genome.seq[[which(a.seq.list == nm)]]) a.seq.length &lt;- append(a.seq.length, tmp.len) } b.seq.length &lt;- c() for (nm in b.seq.list) { tmp.len &lt;- length(b.genome.seq[[which(b.seq.list == nm)]]) b.seq.length &lt;- append(b.seq.length, tmp.len) } a.seq.df &lt;- data.frame(a.seq.list, a.seq.length) colnames(a.seq.df) &lt;- c(&#39;V1&#39;,&#39;length&#39;) b.seq.df &lt;- data.frame(b.seq.list, b.seq.length) colnames(b.seq.df) &lt;- c(&#39;V1&#39;,&#39;length&#39;) print(paste0(&#39;-- Blasting: &#39;,a.header,&#39; - VS - &#39;,b.header)) # 「正向」-- A 为查询，B 为参考数据库 result.forward &lt;- paste0(a.header,&#39;_VS_&#39;,b.header,&#39;.tab&#39;) system(paste0(blast.comm1, a.genome, blast.comm2, b.header, blast.comm3, result.forward)) df.forward &lt;- read.table(paste0(&#39;Result/&#39;,result.forward), header = F,sep = &#39;\\t&#39;, stringsAsFactors = F) df.forward &lt;- df.forward %&gt;% distinct(V1,.keep_all = T) df.forward &lt;- merge(df.forward, a.seq.df, by = &#39;V1&#39;, all.x = T) df.forward$align &lt;- df.forward$V4 / df.forward$length df.forward &lt;- df.forward[which(df.forward$V3 &gt; 40 &amp; df.forward$align &gt; 0.5 &amp; df.forward$V11 &lt; 1e-5),] C1 &lt;- dim(df.forward)[1] # 「反向」-- B 为查询，A 为参考数据库 result.backward &lt;- paste0(b.header,&#39;_VS_&#39;,a.header,&#39;.tab&#39;) system(paste0(blast.comm1, b.genome, blast.comm2, a.header, blast.comm3, result.backward)) df.backward &lt;- read.table(paste0(&#39;Result/&#39;,result.backward), header = F,sep = &#39;\\t&#39;, stringsAsFactors = F) df.backward &lt;- df.backward %&gt;% distinct(V1,.keep_all = T) df.backward &lt;- merge(df.backward, b.seq.df, by = &#39;V1&#39;, all.x = T) df.backward$align &lt;- df.backward$V4 / df.backward$length df.backward &lt;- df.backward[which(df.backward$V3 &gt; 40 &amp; df.backward$align &gt; 0.5 &amp; df.backward$V11 &lt; 1e-5),] C2 &lt;- dim(df.backward)[1] pocp &lt;- (C1 + C2)/(a.total + b.total) pocp.vector &lt;- append(pocp.vector, paste0(a.header,&#39;\\t&#39;,b.header,&#39;\\t&#39;,pocp)) print(paste0(&#39;-- Pair blast done: &#39;,a.header,&#39; - VS - &#39;,b.header)) print(paste0(&#39;-- The POCP : &#39;, pocp)) print(&#39;----------------------------------&#39;) } write(pocp.vector, &#39;resultPOCP.txt&#39;) # 删除分析过程中的冗余文件 unlink(&quot;Database&quot;, recursive = TRUE) unlink(&quot;Result&quot;, recursive = TRUE) # 重新创建新文件夹 dir.create(&#39;Database&#39;) dir.create(&#39;Result&#39;) 12.1.3.1 提示 更多关于 POCP 计算的相关技巧，请点击这里阅读。 12.2 调试脚本或函数 12.2.1 问题 您想要调试脚本或函数。 12.2.2 方案 将其插入您要开始调试的位置的代码中： browser() 当 R 解释器到达该行时，它将暂停你的代码，您将能够查看和更改变量。 在控制台中，键入这些字母将执行以下操作 c 继续 n (or Return) 下一步 Q 放弃 Ctrl-C 回到顶级 在控制台中，你可以看到当前范围中的变量。 ls() 要为函数中的每一行暂停和启动浏览器 debug(myfunction) myfunction(x) 12.2.3 有用的选项 默认情况下，每次在提示符下按 Enter 键，它都会运行下一步。这相当于按 n，然后按 Enter 键。这可能很烦人。要禁用它，请使用： options(browserNLdisabled=TRUE) 要在抛出错误时开始调试，请在抛出错误的函数之前运行此命令 options(error=recover) 如果你希望每次启动R时都设置这些选项，则可以将它们放在 ~/.Rprofile 文件中。 12.3 测量运行的时间 12.3.1 问题 您想要测量运行特定代码块所需的时间。 12.3.2 方案 system.time() 函数将测量在 R 中运行某些东西所需的时间。 tm &lt;- system.time({ # 做一些消耗时间的事情 x &lt;- 1:1e+05 for (i in seq_along(x)) x[i] &lt;- x[i] + 1 }) tm #&gt; user system elapsed #&gt; 0.010 0.001 0.011 输出显示运行代码块需要 0.01 秒。 12.4 获取包中的函数和对象列表 12.4.1 问题 你想知道包里有什么。 12.4.2 方案 在一个新的 R 会话中使用 search() 可以查看默认加载的包。 search() #&gt; [1] &quot;.GlobalEnv&quot; &quot;package:ellipse&quot; #&gt; [3] &quot;package:Cairo&quot; &quot;package:grid&quot; #&gt; [5] &quot;package:dplyr&quot; &quot;package:scales&quot; #&gt; [7] &quot;package:Rmisc&quot; &quot;package:plyr&quot; #&gt; [9] &quot;package:lattice&quot; &quot;package:reshape2&quot; #&gt; [11] &quot;package:ggplot2&quot; &quot;package:car&quot; #&gt; [13] &quot;package:carData&quot; &quot;package:sm&quot; #&gt; [15] &quot;package:stats&quot; &quot;package:graphics&quot; #&gt; [17] &quot;package:grDevices&quot; &quot;package:utils&quot; #&gt; [19] &quot;package:datasets&quot; &quot;package:methods&quot; #&gt; [21] &quot;Autoloads&quot; &quot;package:base&quot; 以下提供的函数能够列出包中的函数和对象。 showPackageContents &lt;- function(packageName) { # 获取特定包所有内容的列表 funlist &lt;- objects(packageName) # 移除不以字母开头的东西 idx &lt;- grep(&quot;^[a-zA-Z][a-zA-Z0-9._]*&quot;, funlist) funlist &lt;- funlist[idx] # 移除包含箭头 &lt;- 的东西 idx &lt;- grep(&quot;&lt;-&quot;, funlist) if (length(idx) != 0) funlist &lt;- funlist[-idx] # 创建一个数据框保存数据 objectlist &lt;- data.frame(name = funlist, primitive = FALSE, func = FALSE, object = FALSE, constant = FALSE, stringsAsFactors = F) for (i in 1:nrow(objectlist)) { fname &lt;- objectlist$name[i] if (exists(fname)) { obj &lt;- get(fname) if (is.primitive(obj)) { objectlist$primitive[i] &lt;- TRUE } if (is.function(obj)) { objectlist$func[i] &lt;- TRUE } if (is.object(obj)) { objectlist$object[i] &lt;- TRUE } # 我认为这些基本是常量 if (is.vector(obj)) { objectlist$constant[i] &lt;- TRUE } } } cat(packageName) cat(&quot;\\n================================================\\n&quot;) cat(&quot;Primitive functions: \\n&quot;) cat(objectlist$name[objectlist$primitive]) cat(&quot;\\n&quot;) cat(&quot;\\n================================================\\n&quot;) cat(&quot;Non-primitive functions: \\n&quot;) cat(objectlist$name[objectlist$func &amp; !objectlist$primitive]) cat(&quot;\\n&quot;) cat(&quot;\\n================================================\\n&quot;) cat(&quot;Constants: \\n&quot;) cat(objectlist$name[objectlist$constant]) cat(&quot;\\n&quot;) cat(&quot;\\n================================================\\n&quot;) cat(&quot;Objects: \\n&quot;) cat(objectlist$name[objectlist$object]) cat(&quot;\\n&quot;) } 以 base 包作为示例测试： showPackageContents(&quot;package:base&quot;) #&gt; package:base #&gt; ================================================ #&gt; Primitive functions: #&gt; abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.numeric as.raw asin asinh atan atanh attr attributes baseenv break browser call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv enc2native enc2utf8 exp expm1 expression floor for forceAndCall function gamma gc.time globalenv if Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol isS4 lazyLoadDBfetch length lgamma list log log10 log1p log2 max min missing Mod names nargs next nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep repeat retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod while xtfrm #&gt; #&gt; ================================================ #&gt; Non-primitive functions: #&gt; abbreviate addNA addTaskCallback agrep agrepl alist all.equal all.equal.character all.equal.default all.equal.environment all.equal.envRefClass all.equal.factor all.equal.formula all.equal.language all.equal.list all.equal.numeric all.equal.POSIXt all.equal.raw all.names all.vars allowInterrupts anyDuplicated anyDuplicated.array anyDuplicated.data.frame anyDuplicated.default anyDuplicated.matrix anyNA.numeric_version anyNA.POSIXlt aperm aperm.default aperm.table append apply args array arrayInd as.array as.array.default as.character.condition as.character.Date as.character.default as.character.error as.character.factor as.character.hexmode as.character.numeric_version as.character.octmode as.character.POSIXt as.character.srcref as.data.frame as.data.frame.array as.data.frame.AsIs as.data.frame.character as.data.frame.complex as.data.frame.data.frame as.data.frame.Date as.data.frame.default as.data.frame.difftime as.data.frame.factor as.data.frame.integer as.data.frame.list as.data.frame.logical as.data.frame.matrix as.data.frame.model.matrix as.data.frame.noquote as.data.frame.numeric as.data.frame.numeric_version as.data.frame.ordered as.data.frame.POSIXct as.data.frame.POSIXlt as.data.frame.raw as.data.frame.table as.data.frame.ts as.data.frame.vector as.Date as.Date.character as.Date.default as.Date.factor as.Date.numeric as.Date.POSIXct as.Date.POSIXlt as.difftime as.double.difftime as.double.POSIXlt as.expression as.expression.default as.factor as.function as.function.default as.hexmode as.list as.list.data.frame as.list.Date as.list.default as.list.environment as.list.factor as.list.function as.list.numeric_version as.list.POSIXct as.list.POSIXlt as.logical.factor as.matrix as.matrix.data.frame as.matrix.default as.matrix.noquote as.matrix.POSIXlt as.name as.null as.null.default as.numeric_version as.octmode as.ordered as.package_version as.pairlist as.POSIXct as.POSIXct.Date as.POSIXct.default as.POSIXct.numeric as.POSIXct.POSIXlt as.POSIXlt as.POSIXlt.character as.POSIXlt.Date as.POSIXlt.default as.POSIXlt.factor as.POSIXlt.numeric as.POSIXlt.POSIXct as.qr as.single as.single.default as.symbol as.table as.table.default as.vector as.vector.factor asNamespace asplit asS3 asS4 assign atan2 attach attachNamespace attr.all.equal autoload autoloader backsolve basename besselI besselJ besselK besselY beta bindingIsActive bindingIsLocked bindtextdomain bitwAnd bitwNot bitwOr bitwShiftL bitwShiftR bitwXor body bquote browserCondition browserSetDebug browserText builtins by by.data.frame by.default bzfile c.Date c.difftime c.noquote c.numeric_version c.POSIXct c.POSIXlt c.warnings callCC capabilities casefold cat cbind cbind.data.frame char.expand character charmatch charToRaw chartr check_tzones chkDots chol chol.default chol2inv choose clearPushBack close close.connection close.srcfile close.srcfilealias closeAllConnections col colMeans colnames colSums commandArgs comment complex computeRestarts conditionCall conditionCall.condition conditionMessage conditionMessage.condition conflictRules conflicts contributors crossprod Cstack_info curlGetHeaders cut cut.Date cut.default cut.POSIXt data.class data.frame data.matrix date debug debuggingState debugonce default.stringsAsFactors delayedAssign deparse det detach determinant determinant.matrix dget diag diff diff.Date diff.default diff.difftime diff.POSIXt difftime dim.data.frame dimnames.data.frame dir dir.create dir.exists dirname do.call dontCheck double dput dQuote drop droplevels droplevels.data.frame droplevels.factor dump duplicated duplicated.array duplicated.data.frame duplicated.default duplicated.matrix duplicated.numeric_version duplicated.POSIXlt duplicated.warnings dyn.load dyn.unload dynGet eapply eigen encodeString Encoding endsWith enquote env.profile environment environmentIsLocked environmentName errorCondition eval eval.parent evalq exists expand.grid extSoftVersion factor factorial fifo file file.access file.append file.choose file.copy file.create file.exists file.info file.link file.mode file.mtime file.path file.remove file.rename file.show file.size file.symlink Filter Find find.package findInterval findPackageEnv findRestart flush flush.connection force formals format format.AsIs format.data.frame format.Date format.default format.difftime format.factor format.hexmode format.info format.libraryIQR format.numeric_version format.octmode format.packageInfo format.POSIXct format.POSIXlt format.pval format.summaryDefault formatC formatDL forwardsolve gc gcinfo gctorture gctorture2 get get0 getAllConnections getCallingDLL getCallingDLLe getConnection getDLLRegisteredRoutines getDLLRegisteredRoutines.character getDLLRegisteredRoutines.DLLInfo getElement geterrmessage getExportedValue getHook getLoadedDLLs getNamespace getNamespaceExports getNamespaceImports getNamespaceInfo getNamespaceName getNamespaceUsers getNamespaceVersion getNativeSymbolInfo getOption getRversion getSrcLines getTaskCallbackNames gettext gettextf getwd gl gregexpr grep grepl grepRaw grouping gsub gzcon gzfile I iconv iconvlist icuGetCollate icuSetCollate identical identity ifelse importIntoEnv inherits integer interaction intersect intToBits intToUtf8 inverse.rle invokeRestart invokeRestartInteractively is.data.frame is.element is.factor is.loaded is.na.data.frame is.na.numeric_version is.na.POSIXlt is.numeric_version is.numeric.Date is.numeric.difftime is.numeric.POSIXt is.ordered is.package_version is.primitive is.qr is.R is.table is.unsorted is.vector isatty isBaseNamespace isdebugged isFALSE isIncomplete isNamespace isNamespaceLoaded ISOdate ISOdatetime isOpen isRestart isSeekable isSymmetric isSymmetric.matrix isTRUE jitter julian julian.Date julian.POSIXt kappa kappa.default kappa.lm kappa.qr kronecker l10n_info La_library La_version La.svd labels.default lapply lazyLoad lazyLoadDBexec lbeta lchoose length.POSIXlt lengths levels levels.default lfactorial libcurlVersion library library.dynam library.dynam.unload licence license list.dirs list.files list2env load loadedNamespaces loadingNamespaceInfo loadNamespace local lockBinding lockEnvironment logb logical lower.tri ls make.names make.unique makeActiveBinding Map mapply margin.table mat.or.vec match match.arg match.call match.fun Math.data.frame Math.Date Math.difftime Math.factor Math.POSIXt matrix max.col mean mean.Date mean.default mean.difftime mean.POSIXct mean.POSIXlt mem.limits mem.maxNSize mem.maxVSize memCompress memDecompress memory.profile merge merge.data.frame merge.default message mget mode months months.Date months.POSIXt names.POSIXlt namespaceExport namespaceImport namespaceImportClasses namespaceImportFrom namespaceImportMethods nchar ncol NCOL Negate new.env NextMethod ngettext nlevels noquote norm normalizePath nrow NROW nullfile numeric numeric_version objects OlsonNames open open.connection open.srcfile open.srcfilealias open.srcfilecopy Ops.data.frame Ops.Date Ops.difftime Ops.factor Ops.numeric_version Ops.ordered Ops.POSIXt options order ordered outer package_version packageEvent packageHasNamespace packageNotFoundError packageStartupMessage packBits pairlist parent.env parent.frame parse parseNamespaceFile paste paste0 path.expand path.package pcre_config pipe pmatch pmax pmax.int pmin pmin.int polyroot pretty pretty.default prettyNum print print.AsIs print.by print.condition print.connection print.data.frame print.Date print.default print.difftime print.Dlist print.DLLInfo print.DLLInfoList print.DLLRegisteredRoutines print.eigen print.factor print.function print.hexmode print.libraryIQR print.listof print.NativeRoutineList print.noquote print.numeric_version print.octmode print.packageInfo print.POSIXct print.POSIXlt print.proc_time print.restart print.rle print.simple.list print.srcfile print.srcref print.summary.table print.summary.warnings print.summaryDefault print.table print.warnings prmatrix prop.table provideDimnames psigamma pushBack pushBackLength q qr qr.coef qr.default qr.fitted qr.Q qr.qty qr.qy qr.R qr.resid qr.solve qr.X quarters quarters.Date quarters.POSIXt quit R_system_version R.home R.Version range.default rank rapply raw rawConnection rawConnectionValue rawShift rawToBits rawToChar rbind rbind.data.frame rcond read.dcf readBin readChar readline readLines readRDS readRenviron Recall Reduce reg.finalizer regexec regexpr registerS3method registerS3methods regmatches remove removeTaskCallback rep_len rep.Date rep.factor rep.int rep.numeric_version rep.POSIXct rep.POSIXlt replace replicate require requireNamespace restartDescription restartFormals returnValue rev rev.default rle rm RNGkind RNGversion round.Date round.POSIXt row row.names row.names.data.frame row.names.default rowMeans rownames rowsum rowsum.data.frame rowsum.default rowSums sample sample.int sapply save save.image saveRDS scale scale.default scan search searchpaths seek seek.connection seq seq.Date seq.default seq.POSIXt sequence serialize set.seed setdiff setequal setHook setNamespaceInfo setSessionTimeLimit setTimeLimit setwd showConnections shQuote signalCondition simpleCondition simpleError simpleMessage simpleWarning simplify2array single sink sink.number slice.index socketConnection socketSelect solve solve.default solve.qr sort sort.default sort.int sort.list sort.POSIXlt source split split.data.frame split.Date split.default split.POSIXct sprintf sQuote srcfile srcfilealias srcfilecopy srcref startsWith stderr stdin stdout stop stopifnot storage.mode str2expression str2lang strftime strptime strrep strsplit strtoi strtrim structure strwrap sub subset subset.data.frame subset.default subset.matrix substr substring summary summary.connection summary.data.frame Summary.data.frame summary.Date Summary.Date summary.default Summary.difftime summary.factor Summary.factor summary.matrix Summary.numeric_version Summary.ordered summary.POSIXct Summary.POSIXct summary.POSIXlt Summary.POSIXlt summary.proc_time summary.srcfile summary.srcref summary.table summary.warnings suppressMessages suppressPackageStartupMessages suppressWarnings suspendInterrupts svd sweep sys.call sys.calls Sys.chmod Sys.Date sys.frame sys.frames sys.function Sys.getenv Sys.getlocale Sys.getpid Sys.glob Sys.info sys.load.image Sys.localeconv sys.nframe sys.on.exit sys.parent sys.parents Sys.readlink sys.save.image Sys.setenv Sys.setFileTime Sys.setlocale Sys.sleep sys.source sys.status Sys.time Sys.timezone Sys.umask Sys.unsetenv Sys.which system system.file system.time system2 t.data.frame t.default table tabulate tapply taskCallbackManager tcrossprod tempdir tempfile textConnection textConnectionValue tolower topenv toString toString.default toupper trace traceback tracingState transform transform.data.frame transform.default trimws trunc.Date trunc.POSIXt truncate truncate.connection try tryCatch typeof undebug union unique unique.array unique.data.frame unique.default unique.matrix unique.numeric_version unique.POSIXlt unique.warnings units units.difftime unix.time unlink unlist unloadNamespace unlockBinding unname unserialize unsplit untrace unz upper.tri url utf8ToInt validEnc validUTF8 vapply vector Vectorize warning warningCondition warnings weekdays weekdays.Date weekdays.POSIXt which which.max which.min with with.default withAutoprint withCallingHandlers within within.data.frame within.list withRestarts withVisible write write.dcf writeBin writeChar writeLines xor xpdrows.data.frame xtfrm.AsIs xtfrm.Date xtfrm.default xtfrm.difftime xtfrm.factor xtfrm.numeric_version xtfrm.POSIXct xtfrm.POSIXlt xzfile zapsmall #&gt; #&gt; ================================================ #&gt; Constants: #&gt; c F labels letters LETTERS month.abb month.name pi R.version.string t T #&gt; #&gt; ================================================ #&gt; Objects: #&gt; kronecker Position R.version version "],
["section-13.html", "第 13 章 工具 13.1 生成拉丁方", " 第 13 章 工具 13.1 生成拉丁方 13.1.1 问题 你想要生成平衡序列用于实验。 13.1.2 方案 函数 latinsquare() (在下方定义) 可以被用来生成拉丁方。 latinsquare(4) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 4 3 #&gt; [2,] 2 1 3 4 #&gt; [3,] 3 4 1 2 #&gt; [4,] 4 3 2 1 # 生成两个大小为 4 的拉丁方(按顺序排列) latinsquare(4, reps=2) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 3 4 1 2 #&gt; [2,] 4 3 2 1 #&gt; [3,] 1 2 4 3 #&gt; [4,] 2 1 3 4 #&gt; [5,] 4 2 1 3 #&gt; [6,] 2 3 4 1 #&gt; [7,] 1 4 3 2 #&gt; [8,] 3 1 2 4 # 在调用该函数时最好加入一个随机种子 (random seed)，这样可以使得生成的拉丁方具有可重复性。 # 如下所示，这样做每次都会得到同一序列的拉丁方。 latinsquare(4, reps=2, seed=5873) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 2 3 #&gt; [2,] 4 1 3 2 #&gt; [3,] 2 3 4 1 #&gt; [4,] 3 2 1 4 #&gt; [5,] 3 2 4 1 #&gt; [6,] 1 4 2 3 #&gt; [7,] 4 3 1 2 #&gt; [8,] 2 1 3 4 存在大小为 4 的 拉丁方 576 个。函数 latinsquare 会随机选择其中 n 个并以序列形式返回它们。这被称为重复拉丁方设计 。 一旦你生成了自己的拉丁方，你需要进行检查确保不存在许多重复的序列，因为这中情况在小型拉丁方中非常普遍 (3x3 or 4x4)。 13.1.2.1 生成拉丁方的函数 这个函数一定程度上使用了暴力算法来生成每个拉丁方，有时候它会因为没有可用的数字放入给定的位置而失败。这种情况下，它会再做尝试。可能存在一种更好的办法吧，但我并不清楚。 ## - len 指定的是拉丁方的大小 - reps ## 是拉丁方的重复数-即给出多少个拉丁方 - seed ## 给定一个随机种子，这样可以保证生成的拉丁方是可重复的。 ## - returnstrings ## 告诉函数为每个拉丁方返回一个字符串向量而不是返回一个巨大的矩阵，这个参数可以用来检查生成拉丁方的随机性。 latinsquare &lt;- function(len, reps = 1, seed = NA, returnstrings = FALSE) { # 保存旧的随机种子并使用新的（如果有） if (!is.na(seed)) { if (exists(&quot;.Random.seed&quot;)) { saved.seed &lt;- .Random.seed } else { saved.seed &lt;- NA } set.seed(seed) } # 这个矩阵包含了全部独立的拉丁方 allsq &lt;- matrix(nrow = reps * len, ncol = len) # 如果需要，为每个拉丁方阵储存一个字符串 id if (returnstrings) { squareid &lt;- vector(mode = &quot;character&quot;, length = reps) } # 从向量中获取一个随机元素。(如果 x # 里只有一个元素，那么内置的示例函数会很诡异地发生不一样的运行） sample1 &lt;- function(x) { if (length(x) == 1) { return(x) } else { return(sample(x, 1)) } } # 生成 n 个独立的拉丁方阵 for (n in 1:reps) { # 生成一个空的方阵 sq &lt;- matrix(nrow = len, ncol = len) # 如果我们从左上角开始依次填满这个方阵，那么某些拉丁方阵出现的概率就会比其他的大 # 因此我们需要在方阵中随机地序列填充 步骤大概如下： - # 随机选择一个 NA 的单元格 (可以称之为目标单元格) - # 找出与目标单元格同行或同列的所有 NA 单元格 - # 填充目标单元格 - 填充同行/同列的其他单元格 - # 如果因为所有的数字都已被使用而无法继续填充单元格，那么就退出并重新开始填充一个新的方阵。 # 简言之就是选择一个空单元格，填充它。然后以随机顺序填充与其“交叉”的其他空单元格。 # 如果只是完全地随机填充（而没有沿着交叉方向），那么失败的概率非常高。 while (any(is.na(sq))) { # 随机选择一个当前值为 NA 的单元格 k &lt;- sample1(which(is.na(sq))) i &lt;- (k - 1)%%len + 1 # 获取行号 j &lt;- floor((k - 1)/len) + 1 # 获取列号 # 在以 i,j 为中心的“交叉点”中找到其他为 NA 的单元格 sqrow &lt;- sq[i, ] sqcol &lt;- sq[, j] # 一个包含了所有 NA 单元格坐标的矩阵 openCell &lt;- rbind(cbind(which(is.na(sqcol)), j), cbind(i, which(is.na(sqrow)))) # 随机化填充顺序 openCell &lt;- openCell[sample(nrow(openCell)), ] # 将中心单元格放到列表的最上面，这样保证从它开始填充方阵 openCell &lt;- rbind(c(i, j), openCell) # There will now be three entries for the center cell, # so remove duplicated entries # 要确保它是一个矩阵--否则，如果只是一行数据，它将会返回成一个向量并引起错误。 openCell &lt;- matrix(openCell[!duplicated(openCell), ], ncol = 2) # 填充中心位置，然后填充交叉方向上的其他空格 for (c in 1:nrow(openCell)) { # The current cell to fill ci &lt;- openCell[c, 1] cj &lt;- openCell[c, 2] # 获取以 i,j 为中心的“交叉”方向上中未使用的数字 freeNum &lt;- which(!(1:len %in% c(sq[ci, ], sq[, cj]))) # 填充这些位置 if (length(freeNum) &gt; 0) { sq[ci, cj] &lt;- sample1(freeNum) } else { # 错误的尝试 - 没有可获取的数值 重新生成空方阵 sq &lt;- matrix(nrow = len, ncol = len) # 跳出循环 break } } } # 将这单个拉丁方储存到包含所有拉丁方的矩阵中 allsqrows &lt;- ((n - 1) * len) + 1:len allsq[allsqrows, ] &lt;- sq # 如果有需要，储存一个代表这个拉丁方的字符串。 # 每个拉丁方都有一个唯一的字符串代号 if (returnstrings) { squareid[n] &lt;- paste(sq, collapse = &quot;&quot;) } } # 恢复旧的随机种子（如果有） if (!is.na(seed) &amp;&amp; !is.na(saved.seed)) { .Random.seed &lt;- saved.seed } if (returnstrings) { return(squareid) } else { return(allsq) } } 13.1.2.2 检查函数的随机性 一些生成拉丁方的算法并不是非常的随机。4x4 的拉丁方有 576 种，它们每一种都应该有相等的概率被生成，但有一些算法没法做到这一点。我们也许没有必要去检查上面函的随机性数，但如果要做这里确实可以通过一些代码来实现。我们运行下面的代码可以发现前面使用的算法其随机分布并不是很好。 这个代码创建 10,000 个 4x4 的拉丁方，然后计算这 576 个唯一拉丁方出现的频数。计数结果应该形成一个不是特别宽的正态分布；否则这个分布就不是很随机了。我相信期望的标准差是根号（10000/576）（假设随机生成拉丁方）。 # 设置要生成拉丁方的大小和数量 squaresize &lt;- 4 numsquares &lt;- 10000 # 获取指定大小的拉丁方的数量 (唯一方阵) 没有寻找到唯一的 # nxn 方阵的通用解法 因此我们这里直接硬编码值 (来自 # http://oeis.org/A002860) uniquesquares &lt;- c(1, 2, 12, 576, 161280, 812851200)[squaresize] # 生成拉丁方 s &lt;- latinsquare(squaresize, numsquares, seed = 122, returnstrings = TRUE) # 获取所有拉丁方阵的列表，并且进行计数 slist &lt;- rle(sort(s)) scounts &lt;- slist[[1]] hist(scounts, breaks = (min(scounts):(max(scounts) + 1) - 0.5)) cat(sprintf(&quot;Expected and actual standard deviation: %.4f, %.4f\\n&quot;, sqrt(numsquares/uniquesquares), sd(scounts))) #&gt; Expected and actual standard deviation: 4.1667, 4.2087 "],
["materials.html", "A 资料推荐 A.1 书籍 A.2 R 包 A.3 网站 A.4 列表", " A 资料推荐 A.1 书籍 《R for Data Science》 《Advanced R》 《R Markdown: The Definitive Guide》 A.2 R 包 bookdown - 使用 R Markdown 创建技术文档。 A.3 网站 bookdown - 包含一系列由 bookdown 创建的书籍，大部分与 R 语言相关，有非常高的学习和参考价值。 A.4 列表 "],
["references.html", "参考文献", " 参考文献 "]
]
