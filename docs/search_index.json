[
["index.html", "Cookbook for R 中文版 欢迎", " Cookbook for R 中文版 Winston Chang（著） 王诗翔 等（译） 2019-04-14 欢迎 这是“Cookbook for R 中文版”的网站。这本书以直观明了的问题/需求和方案为基本内容向读者介绍R的基础和如何解决常见的分析问题：读者将会学习安装和使用三方包、操作基础的数据类型，学习数据的导入、操作和可视化，学习统计分析和编写脚本，以及其他工具。这本书是R问题方案参考手册，建议读者配合系统的R语言读物使用，如《R for Data Science》。 这个网站是（永久）免费的，它以署名-非商业使用-禁止演绎CC许可协议发布。如果你想要该书的实体版本，请期待它的出版。 非常感谢以下成员的参与，如果不是他们，这本中文书再过两年也不会跟大家见面。 陈颖珊 梁其云 王慧美 熊逸 杨芮 张浩浩 赵飞 王诗翔 于 上海科技大学 "],
["author.html", "作者简介", " 作者简介 Winston Chang "],
["section-1.html", "第 1 章 基础 1.1 安装和使用R包 1.2 数据结构的索引 1.3 获取数据结构的子集 1.4 创建填满值的向量 1.5 获取变量信息 1.6 NULL-NA-NaN的处理", " 第 1 章 基础 1.1 安装和使用R包 1.1.1 问题 你想要安装和使用一个R包。 1.1.2 方案 如果你正在使用支持R的图形界面软件，应该存在通过菜单栏方式安装R包的选项（比如，常用的Rstudio中，可以点击菜单栏Tools中的Install Packages进行R包的安装）。 这里主要介绍如何用命令行来安装R包。 install.packages(&quot;reshape2&quot;) # reshap2为包名 在一个新R线程中使用该包之前，你必须先导入它。 library(reshape2) 如果你在一个脚本中使用该包，把这一行输入脚本中。 如果想要更新包，使用 update.packages() 如果你在Linux系统上使用R，管理员可能已经在系统上安装了一些R包，你将不能以上述方式对R包更新（因为你没有权限）。 1.1.3 其他 导入包也可以使用require()函数。 常见的包安装命令 命令 描述 installed.packages 返回一个矩阵，包含所有已安装的包信息 available.packages 返回一个矩阵，包含资源库上所有可用的R包 old.packages 返回一个矩阵，显示所有已安装的包中具有新版本的包 new.packages 返回一个矩阵，显示所有可从资源库上获得而当前尚未安装的包 download.packages 下载一系列R包到本地目录 install.packages 从资源库下载安装一系列R包 remove.packages 移除一系列已安装的R包 update.packages 将已经安装的R包更新到最新版本 setRepositories 设定当前的R包的资源库列表 通过命令行安装R包 R CMD INSTALL aplpack_1.1.1.tgz # 安装aplpack包 从其他资源库安装R包 devtools库提供了从其他流行的Git资源库或其他URL上安装R包的工具。 比如我们想安装开发版本的ggplot2包，可以使用下面命令： # 如果没有安装devtools，需要先安装 install.packages(&quot;devtools&quot;) library(devtools) install_github(&quot;ggplot2&quot;) 1.2 数据结构的索引 1.2.1 问题 你想获得数据结构的一部分。 1.2.2 解决 可以使用数字索引或通过使用适当长度的布尔向量来提取向量，矩阵或数据框中的元素。 以下这些例子中有多种方式来解决这一问题。 1.2.2.1 用数字和名称进行索引 对于向量 # 样本向量 v &lt;- c(1,4,4,3,2,2,3) v[c(2,3,4)] #&gt; [1] 4 4 3 v[2:4] #&gt; [1] 4 4 3 v[c(2,4,3)] #&gt; [1] 4 3 4 对于数据框 # 创建样本数据框 data &lt;- read.table(header=T, text=&#39; subject sex size 1 M 7 2 F 6 3 F 9 4 M 11 &#39;) # 获取位于第一行第三列的元素 data[1,3] #&gt; [1] 7 data[1,&quot;size&quot;] #&gt; [1] 7 # 获取第1行和第2行所有列上的元素 data[1:2, ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 data[c(1,2), ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 # 获取一，二两行第二列上的元素 data[1:2, 2] #&gt; [1] M F #&gt; Levels: F M data[c(1,2), 2] #&gt; [1] M F #&gt; Levels: F M # 获取行1和2，名为“sex”和 &quot;size&quot;的列 data[1:2, c(&quot;sex&quot;,&quot;size&quot;)] #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 data[c(1,2), c(2,3)] #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 1.2.2.2 使用布尔向量进行索引 向量V同上 v &gt; 2 #&gt; [1] FALSE TRUE TRUE TRUE FALSE FALSE TRUE v[v&gt;2] #&gt; [1] 4 4 3 3 v[ c(F,T,T,T,F,F,T)] #&gt; [1] 4 4 3 3 数据框同上 # 一个布尔向量 data$subject &lt; 3 #&gt; [1] TRUE TRUE FALSE FALSE data[data$subject &lt; 3, ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 data[c(TRUE,TRUE,FALSE,FALSE), ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 # 也可以获取TRUE的数字索引 which(data$subject &lt; 3) #&gt; [1] 1 2 1.2.2.3 负索引 与其他一些编程语言不同，当您在R中使用负数进行索引时，并不意味着从后向前索引。 相反，它意味着按照通常的从前往后顺序删除索引中的元素。 # 还是这个向量 v #&gt; [1] 1 4 4 3 2 2 3 # 删除第一个 v[-1] #&gt; [1] 4 4 3 2 2 3 #删除前三个 v[-1:-3] #&gt; [1] 3 2 2 3 # 只删除最后一个 v[-length(v)] #&gt; [1] 1 4 4 3 2 2 1.2.2.4 注意 也可参考获取数据结构的子集 1.3 获取数据结构的子集 1.3.1 问题 你想得到一个由向量，矩阵或数据框里元素组成的子集。 1.3.2 方案 为了基于一些条件准则获得子集，可以使用subset()函数或者是方括号索引。 在这里的例子中，显示了两种方式。 v &lt;- c(1,4,4,3,2,2,3) subset(v, v&lt;3) #&gt; [1] 1 2 2 v[v&lt;3] #&gt; [1] 1 2 2 # 另一个向量 t &lt;- c(&quot;small&quot;, &quot;small&quot;, &quot;large&quot;, &quot;medium&quot;) # 删除 &quot;small&quot; 这一项 subset(t, t!=&quot;small&quot;) #&gt; [1] &quot;large&quot; &quot;medium&quot; t[t!=&quot;small&quot;] #&gt; [1] &quot;large&quot; &quot;medium&quot; 这两种方法之间的一个重要区别在于方括号索引可以为元素赋值，而subset（）不可以。 v[v&lt;3] &lt;- 9 subset(v, v&lt;3) &lt;- 9 #&gt; Error in subset(v, v &lt; 3) &lt;- 9: could not find function &quot;subset&lt;-&quot; 1.3.3 数据框 # 样本数据框 data &lt;- read.table(header=T, text=&#39; subject sex size 1 M 7 2 F 6 3 F 9 4 M 11 &#39;) subset(data, subject &lt; 3) #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 data[data$subject &lt; 3, ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 # 特定行和列的子集 subset(data, subject &lt; 3, select = -subject) #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 subset(data, subject &lt; 3, select = c(sex,size)) #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 subset(data, subject &lt; 3, select = sex:size) #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 data[data$subject &lt; 3, c(&quot;sex&quot;,&quot;size&quot;)] #&gt; sex size #&gt; 1 M 7 #&gt; 2 F 6 # 逻辑AND的两个条件 subset(data, subject &lt; 3 &amp; sex==&quot;M&quot;) #&gt; subject sex size #&gt; 1 1 M 7 data[data$subject &lt; 3 &amp; data$sex==&quot;M&quot;, ] #&gt; subject sex size #&gt; 1 1 M 7 # 逻辑或的两个条件 subset(data, subject &lt; 3 | sex==&quot;M&quot;) #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 #&gt; 4 4 M 11 data[data$subject &lt; 3 | data$sex==&quot;M&quot;, ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 2 2 F 6 #&gt; 4 4 M 11 # 基于转换数据的条件 subset(data, log2(size) &gt; 3 ) #&gt; subject sex size #&gt; 3 3 F 9 #&gt; 4 4 M 11 data[log2(data$size) &gt; 3, ] #&gt; subject sex size #&gt; 3 3 F 9 #&gt; 4 4 M 11 # 当元素在另一个向量里时的子集 subset(data, subject %in% c(1,3)) #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 3 3 F 9 data[data$subject %in% c(1,3), ] #&gt; subject sex size #&gt; 1 1 M 7 #&gt; 3 3 F 9 1.3.3.1 注意 也可参考数据结构索引。 1.4 创建填满值的向量 1.4.1 问题 你想要创建一个填满值的列表。 1.4.2 方案 rep(1, 50) # [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 # [39] 1 1 1 1 1 1 1 1 1 1 1 1 rep(F, 20) # [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE # [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE rep(1:5, 4) # 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 rep(1:5, each=4) # 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 # 用在因子变量上 rep(factor(LETTERS[1:3]), 5) # A B C A B C A B C A B C A B C # Levels: A B C 1.5 获取变量信息 1.5.1 问题 你想找到关于变量的信息。 1.5.2 方案 以下为关于样本变量的一些例子 x &lt;- 6 n &lt;- 1:4 let &lt;- LETTERS[1:4] df &lt;- data.frame(n, let) 1.5.2.1 关于存在 # 列出当前所定义的变量 ls() #&gt; [1] &quot;df&quot; &quot;filename&quot; &quot;let&quot; &quot;n&quot; &quot;old_dir&quot; &quot;x&quot; # 检查名为“x”的变量是否存在 exists(&quot;x&quot;) #&gt; [1] TRUE # 检查名为“y”的变量是否存在 exists(&quot;y&quot;) #&gt; [1] FALSE # 删除变量“x” rm(x) x #&gt; Error in eval(expr, envir, enclos): object &#39;x&#39; not found # eval(expr, envir, enclos)错误：找不到对象“x” 1.5.2.2 关于大小/结构 # 获得关于结构的信息 str(n) #&gt; int [1:4] 1 2 3 4 str(df) #&gt; &#39;data.frame&#39;: 4 obs. of 2 variables: #&gt; $ n : int 1 2 3 4 #&gt; $ let: Factor w/ 4 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;: 1 2 3 4 # 得到一个向量的长度 length(n) #&gt; [1] 4 # 可能会得不到我们想要的长度 length(df) #&gt; [1] 2 # 行数 nrow(df) #&gt; [1] 4 # 列数 ncol(df) #&gt; [1] 2 # 得到行数和列数 dim(df) #&gt; [1] 4 2 1.6 NULL-NA-NaN的处理 1.6.1 问题 你想正确处理NULL、NA （Not Available）、NaN（Not a Number）。 1.6.2 方案 你的数据有时将会存在NULL、NA 、NaN。处理这些数据有些不同于”正常”值，并可能需要确定性测试。 以下是这些值相比较的例子： x &lt;- NULL x &gt; 5 # logical(0) y &lt;- NA y &gt; 5 # NA z &lt;- NaN z &gt; 5 # NA 如何测试某个变量是否是其中的一个值： is.null(x) # TRUE is.na(y) # TRUE is.nan(z) # TRUE 注意，NULL不同于其他两个。NULL意味着没有值，而NA和NaN表示有价，尽管也许是不可用的。下面有一个例子区分： # Is y null? is.null(y) # FALSE # Is x NA? is.na(x) # logical(0) # Warning message: # In is.na(x) : is.na() applied to non-(list or vector) of type &#39;NULL&#39; 第一个例子，检查y是否是NULL，结果y并不是；第二个例子，试图检查x是否是NA，但并没有值被检测。 1.6.2.1 忽视向量汇总函数中的“坏”值 如果你对包含NA或NaN的向量使用诸如mean()或sum()之类的函数，结果将返回NA和NaN，这通常没有任何意义，虽然这样的结果会提醒你有“坏”值的存在。许多函数都有na.rm可以将这些值忽略。 vy &lt;- c(1, 2, 3, NA, 5) # 1 2 3 NA 5 mean(vy) # NA mean(vy, na.rm=TRUE) # 2.75 vz &lt;- c(1, 2, 3, NaN, 5) # 1 2 3 NaN 5 sum(vz) # NaN sum(vz, na.rm=TRUE) # 11 # NULL不是问题，因为它不存在 vx &lt;- c(1, 2, 3, NULL, 5) # 1 2 3 5 sum(vx) # 11 1.6.2.2 从向量中移除”坏值“ 使用is.na()或is.nan()的反向函数，可以将这些值移除。 vy # 1 2 3 NA 5 vy[!is.na(vy)] # 1 2 3 5 vz # 1 2 3 NaN 5 vz[!is.nan(vz)] # 1 2 3 5 1.6.2.3 注意 也有无限值Inf和-Inf，及其相应的函数is.finite()和is.infinite()。 见/Manipulating data/Comparing vectors or factors with NA "],
["section-2.html", "第 2 章 数字 2.1 生成随机数 2.2 生成可重复的随机序列 2.3 保持随机数生成器的状态 2.4 对数值取整 2.5 比较浮点数", " 第 2 章 数字 2.1 生成随机数 2.1.1 问题 你想要生成随机数。 2.1.2 方案 要生成均匀分布的随机数，可以使用runif()函数。默认，它的范围是从0到1. runif(1) #&gt; [1] 0.09006613 # 得到4个数字的向量 runif(4) #&gt; [1] 0.6972299 0.9505426 0.8297167 0.9779939 # 得到3个从0到100变化的向量 runif(3, min=0, max=100) #&gt; [1] 83.702278 3.062253 5.388360 # 得到从0到100变化的整数 # 使用max=101 因为它永远不可能等于101。 这里利用的floor函数是用来向下取整数的 floor(runif(3, min=0, max=101)) #&gt; [1] 11 67 1 # 这个方式的结果一样 sample(1:100, 3, replace=TRUE) #&gt; [1] 8 63 64 # 生成不可替换（就是不能再取）的整数 sample(1:100, 3, replace=FALSE) #&gt; [1] 76 25 52 要生成服从正态分布的数字，使用rnorm()。默认均值是0，标准差是1。 rnorm(4) #&gt; [1] -2.3308287 -0.9073857 -0.7638332 -0.2193786 # 使用不同的均值和标准差 rnorm(4, mean=50, sd=10) #&gt; [1] 59.20927 40.12440 44.58840 41.97056 # 为了检查这个分布是否正确，给随机数画直方图 x &lt;- rnorm(400, mean=50, sd=10) hist(x) 2.1.3 注意 如果你想要你生成随机数的结果可重复，参看../Generating repeatable sequences of random numbers。 2.2 生成可重复的随机序列 2.2.1 问题 你想要生成可重复的随机数序列。 2.2.2 方案 使用 set.seed()函数，并在括号内放入数字作为种子数。 set.seed(423) runif(3) #&gt; [1] 0.1089715 0.5973455 0.9726307 set.seed(423) runif(3) #&gt; [1] 0.1089715 0.5973455 0.9726307 2.3 保持随机数生成器的状态 2.3.1 问题 你想要保存和回复随机数生成器的状态。 2.3.2 方案 将.Random.seed保存到其他变量，之后将变量值赋给.Random.seed从而恢复原来的值。 # 这个例子中，先设定随机数种子 set.seed(423) runif(3) #&gt; [1] 0.1089715 0.5973455 0.9726307 # 保存种子 oldseed &lt;- .Random.seed runif(3) #&gt; [1] 0.7973768 0.2278427 0.5189830 # 做其他随机数生成相关的事情，比如: # runif(30) # ... # 回复种子 .Random.seed &lt;- oldseed # 保存种子之后，像之前那样得到相同的随机数 runif(3) #&gt; [1] 0.7973768 0.2278427 0.5189830 如果你之前还没有在R线程中用过随机数生成器，变量.Random.seed将会不存在。如果你对此不确定，应当在保存和恢复之前进行检查： oldseed &lt;- NULL if (exists(&quot;.Random.seed&quot;)) oldseed &lt;- .Random.seed # 做一些随机数生成操作，比如： # runif(30) # ... if (!is.null(oldseed)) .Random.seed &lt;- oldseed 2.3.2.1 在函数中保存和恢复随机数生成器的状态 如果你试图在函数中通过使用 .Random.seed &lt;- x来恢复随机数生成器的状态，结果是行不通的，因为这个操作改变的是名为.Random.seed的本地变量，而不是全局环境中的这个变量。 这里有两个例子。这些函数想要做的是生成一些随机数，并使得随机数生成器保留未改变的状态。 # 这是个坏的版本 bad_rand_restore &lt;- function() { if (exists(&quot;.Random.seed&quot;)) oldseed &lt;- .Random.seed else oldseed &lt;- NULL print(runif(3)) if (!is.null(oldseed)) .Random.seed &lt;- oldseed else rm(&quot;.Random.seed&quot;) } # 这是个好的版本 rand_restore &lt;- function() { if (exists(&quot;.Random.seed&quot;, .GlobalEnv)) oldseed &lt;- .GlobalEnv$.Random.seed else oldseed &lt;- NULL print(runif(3)) if (!is.null(oldseed)) .GlobalEnv$.Random.seed &lt;- oldseed else rm(&quot;.Random.seed&quot;, envir = .GlobalEnv) } # 坏的版本没有合适地重置随机数生成器状态，因此随机数一直在改变 set.seed(423) bad_rand_restore() #&gt; [1] 0.1089715 0.5973455 0.9726307 bad_rand_restore() #&gt; [1] 0.7973768 0.2278427 0.5189830 bad_rand_restore() #&gt; [1] 0.6929255 0.8104453 0.1019465 # 好的版本每次都正确地重置了随机数生成器的状态，因此随机数可以保持一致 # stay the same. set.seed(423) rand_restore() #&gt; [1] 0.1089715 0.5973455 0.9726307 rand_restore() #&gt; [1] 0.1089715 0.5973455 0.9726307 rand_restore() #&gt; [1] 0.1089715 0.5973455 0.9726307 2.3.2.2 注意 使用者最好不要修改.Random.seed 变量。 2.4 对数值取整 2.4.1 问题 你想要对数值取整。 2.4.2 方案 存在许多中取整的方式：向最近的整数取整、向上或向下取整、或者向0取整。 x &lt;- seq(-2.5, 2.5, by=.5) # Round to nearest, with .5 values rounded to even number. round(x) #&gt; [1] -2 -2 -2 -1 0 0 0 1 2 2 2 # Round up ceiling(x) #&gt; [1] -2 -2 -1 -1 0 0 1 1 2 2 3 # Round down floor(x) #&gt; [1] -3 -2 -2 -1 -1 0 0 1 1 2 2 # Round toward zero trunc(x) #&gt; [1] -2 -2 -1 -1 0 0 0 1 1 2 2 也可以取整到小数位： x &lt;- c(.001, .07, 1.2, 44.02, 738, 9927) # 一位小数取整 round(x, digits=1) #&gt; [1] 0.0 0.1 1.2 44.0 738.0 9927.0 # 10位取整 round(x, digits=-1) #&gt; [1] 0 0 0 40 740 9930 # 向最近的5取整 round(x/5)*5 #&gt; [1] 0 0 0 45 740 9925 # 取整到最近的.02 round(x/.02)*.02 #&gt; [1] 0.00 0.08 1.20 44.02 738.00 9927.00 2.5 比较浮点数 2.5.1 问题 比较浮点数通常未能如你所想。比如： 0.3 == 3*.1 #&gt; [1] FALSE (0.1 + 0.1 + 0.1) - 0.3 #&gt; [1] 5.551115e-17 x &lt;- seq(0, 1, by=.1) x #&gt; [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 10*x - round(10*x) #&gt; [1] 0.000000e+00 0.000000e+00 0.000000e+00 4.440892e-16 0.000000e+00 0.000000e+00 #&gt; [7] 8.881784e-16 8.881784e-16 0.000000e+00 0.000000e+00 0.000000e+00 2.5.2 方案 不存在通用的解决方案，因为这个问题通常是由于非整数（浮点数）在计算机和R中的存储方式所导致的（数据都是以二进制存储在计算机的数据单元中，整数与浮点数的方式应该是存在差异的，整数好像一般是以反码的形式存储，浮点数机制略有不同吧，忘记了～有兴趣的小伙伴下方解释一下哇）。 可以通过网址http://www.mathworks.com/support/tech-notes/1100/1108.html查阅更多信息。 虽然里面使用Matlab代码写的，但是基本与R是一致的。 "],
["section-3.html", "第 3 章 字符串 3.1 使用grep,sub,gsub进行搜索和替换 3.2 通过变量创建字符串", " 第 3 章 字符串 3.1 使用grep,sub,gsub进行搜索和替换 3.1.1 问题 你想要搜索或替换字符串中特定的文本。 3.1.2 方案 有两个常用字符串搜索函数grep()和grepl()。有两个常用的字符串替换函数sub()和gsub()。它们都是向量化的操作，会应用到输入字符向量的每一个元素上。 3.1.2.1 文本搜索 grep()和grepl()函数搜索的输入的第一个参数都是带有正则表达式的字符串或者固定的字符串（需要设定选项fixed=TRUE），它们的不同之处是前者返回匹配的索引或值向量，而后者返回一个逻辑向量。 下面通过简单的例子理解它们的用法和两个函数的区别：从小写字母向量中搜索c。 &gt; grep(&quot;c&quot;, letters) [1] 3 &gt; grepl(&quot;c&quot;, letters) [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [19] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE grep()函数设定选项value=TRUE可以返回匹配的值。 &gt; grep(&quot;c&quot;, letters, value = TRUE) [1] &quot;c&quot; &gt; grep(&quot;c&quot;, c(&quot;dog&quot;, &quot;cat&quot;), value = TRUE) [1] &quot;cat&quot; 正则表达式提供了一种表达字符模式的强大方式（详情查看?regex），我们可以将它应用于文本的搜索中。例如，我们想搜索字符向量中有4个数字连续出现的字符： &gt; grep(&quot;\\\\d{4}&quot;, c(&quot;This will not match&quot;, &quot;2018-04-11, This will match&quot;)) [1] 2 3.1.2.2 文本替换 大部分情况下我们不仅仅想搜索到文本，而且还想要在搜索的基础上进行替换，这可以通过sub()和gsub()函数实现。这两个函数参数是一样的，第一个参数是搜索的模式，第二个参数是替换的模式，第三个参数是要操作的字符向量。两个函数的区别是前者只会替换字符串中第一个匹配的模式，而gsub()（g是global的缩写）会替换字符串中所有匹配的模式。 例如，我们想要将字符向量中带年份的年全部替换为2019。 &gt; sub(pattern = &quot;\\\\d{4}&quot;,replacement = &quot;2019&quot;, x = c(&quot;This will not match&quot;, &quot;2018-04-11, 2017-04-11&quot;, &quot;2018-04-12&quot;)) [1] &quot;This will not match&quot; &quot;2019-04-11, 2017-04-11&quot; &quot;2019-04-12&quot; &gt; gsub(pattern = &quot;\\\\d{4}&quot;,replacement = &quot;2019&quot;, x = c(&quot;This will not match&quot;, &quot;2018-04-11, 2017-04-11&quot;, &quot;2018-04-12&quot;)) [1] &quot;This will not match&quot; &quot;2019-04-11, 2019-04-11&quot; &quot;2019-04-12&quot; 要操作的对象第二个元素包含2个可以匹配的模式，使用sub()只会将第一个替换为2019，而使用gsub()会将所有能够匹配的模式都替换为2019。 3.2 通过变量创建字符串 3.2.1 问题 你想要通过变量创建一个字符串。 3.2.2 方案 两种从变量创建字符串的通用方法是使用paste()和sprintf()函数。对向量来说，paste更加有用；sprintf则常用于对输出实现精确的控制。 3.2.2.1 使用paste() a &lt;- &quot;apple&quot; b &lt;- &quot;banana&quot; # 将a,b变量内容连到一起，并用空格隔开 paste(a, b) #&gt; [1] &quot;apple banana&quot; # 如果不想要空格，可以设定参数sep=&quot;&quot;,或使用函数 paste0(): paste(a, b, sep=&quot;&quot;) #&gt; [1] &quot;applebanana&quot; paste0(a, b) #&gt; [1] &quot;applebanana&quot; # 用逗号加空格分开: paste(a, b, sep=&quot;, &quot;) #&gt; [1] &quot;apple, banana&quot; # 设定一个字符向量 d &lt;- c(&quot;fig&quot;, &quot;grapefruit&quot;, &quot;honeydew&quot;) # 如果输入是一个向量，输出会将其每个元素堆叠到一起： paste(d, collapse=&quot;, &quot;) #&gt; [1] &quot;fig, grapefruit, honeydew&quot; # 如果输入是一个标量和一个向量， 结果会将标量与向量里每个元素放到一起 # 并返回一个向量（这是R向量化操作的循环对齐原则）： paste(a, d) #&gt; [1] &quot;apple fig&quot; &quot;apple grapefruit&quot; &quot;apple honeydew&quot; # 使用 sep 和 collapse参数: paste(a, d, sep=&quot;-&quot;, collapse=&quot;, &quot;) #&gt; [1] &quot;apple-fig, apple-grapefruit, apple-honeydew&quot; 3.2.2.2 使用sprintf() 另一种方式是使用sprintf函数，它来自于C语言。 想要在字符串或字符变量中进行取代操作，使用%s： a &lt;- &quot;string&quot; sprintf(&quot;This is where a %s goes.&quot;, a) #&gt; [1] &quot;This is where a string goes.&quot; 如果是整数，可以使用%d或它的变体： x &lt;- 8 sprintf(&quot;Regular:%d&quot;, x) #&gt; [1] &quot;Regular:8&quot; # 可以输出到字符串，以空格开头。 sprintf(&quot;Leading spaces:%4d&quot;, x) #&gt; [1] &quot;Leading spaces: 8&quot; # 也可以使用0替代 sprintf(&quot;Leading zeros:%04d&quot;, x) #&gt; [1] &quot;Leading zeros:0008&quot; 对浮点数，使用%f进行标准释义，而%e活着%E则代表指数。你也可以使用%g或者%G让程序自动帮你进行两种格式的转换，这取决于你的有效位数。下面是R help页面中关于sprintf的例子： sprintf(&quot;%f&quot;, pi) # &quot;3.141593&quot; sprintf(&quot;%.3f&quot;, pi) # &quot;3.142&quot; sprintf(&quot;%1.0f&quot;, pi) # &quot;3&quot; sprintf(&quot;%5.1f&quot;, pi) # &quot; 3.1&quot; sprintf(&quot;%05.1f&quot;, pi) # &quot;003.1&quot; sprintf(&quot;%+f&quot;, pi) # &quot;+3.141593&quot; sprintf(&quot;% f&quot;, pi) # &quot; 3.141593&quot; sprintf(&quot;%-10f&quot;, pi) # &quot;3.141593 &quot; (左对齐) sprintf(&quot;%e&quot;, pi) #&quot;3.141593e+00&quot; sprintf(&quot;%E&quot;, pi) # &quot;3.141593E+00&quot; sprintf(&quot;%g&quot;, pi) # &quot;3.14159&quot; sprintf(&quot;%g&quot;, 1e6 * pi) # &quot;3.14159e+06&quot; (指数化) sprintf(&quot;%.9g&quot;, 1e6 * pi) # &quot;3141592.65&quot; (&quot;修正&quot;) sprintf(&quot;%G&quot;, 1e-6 * pi) # &quot;3.14159E-06&quot; 在%m.nf格式规范中：m代表域宽，它是输出字符串中字符的最小位数，可以以空格或0开头。n代表精度，它指小数点后的数字位数。 其他混合操作： x &lt;- &quot;string&quot; sprintf(&quot;Substitute in multiple strings: %s %s&quot;, x, &quot;string2&quot;) #&gt; [1] &quot;Substitute in multiple strings: string string2&quot; # To print a percent sign, use &quot;%%&quot; sprintf(&quot;A single percent sign here %%&quot;) #&gt; [1] &quot;A single percent sign here %&quot; 3.2.2.3 注意 关于更多脚本输出的信息可以查看this page。 "],
["section-4.html", "第 4 章 公式 4.1 通过字符串创建公式 4.2 从公式中提取组分", " 第 4 章 公式 4.1 通过字符串创建公式 4.1.1 问题 你想要通过字符串创建公式 4.1.2 方案 通过字符串的方式来创建公式是非常有用的。这通常用于需要将公式参数当做字符串传入函数中 最基础实用的方法就是调用函数 as.formula(): # 这将返回一个字符串 &quot;y ~ x1 + x2&quot; #&gt; [1] &quot;y ~ x1 + x2&quot; # 这将返回一个公式 as.formula(&quot;y ~ x1 + x2&quot;) #&gt; y ~ x1 + x2 #&gt; &lt;environment: 0x3361710&gt; 下面是一个简单实例： # 存在一些变量名: measurevar &lt;- &quot;y&quot; groupvars &lt;- c(&quot;x1&quot;,&quot;x2&quot;,&quot;x3&quot;) # 创建合适的字符串: paste(measurevar, paste(groupvars, collapse=&quot; + &quot;), sep=&quot; ~ &quot;) #&gt; [1] &quot;y ~ x1 + x2 + x3&quot; # 返回公式: as.formula(paste(measurevar, paste(groupvars, collapse=&quot; + &quot;), sep=&quot; ~ &quot;)) #&gt; y ~ x1 + x2 + x3 #&gt; &lt;environment: 0x3361710&gt; 原文链接：http://www.cookbook-r.com/Formulas/Creating_a_formula_from_a_string/ 4.2 从公式中提取组分 4.2.1 问题 你想要抽离公式的一部分用来使用。 4.2.2 方案 你可以把公式对象当作列表看待，使用[[操作符对其组分进行操作。 f &lt;- y ~ x1 + x2 # 观察f结构 str(f) #&gt; Class &#39;formula&#39; language y ~ x1 + x2 #&gt; ..- attr(*, &quot;.Environment&quot;)=&lt;environment: 0x1e46710&gt; # 获得每一部分 f[[1]] #&gt; `~` f[[2]] #&gt; y f[[3]] #&gt; x1 + x2 # 转换为列表观察 as.list(f) #&gt; [[1]] #&gt; `~` #&gt; #&gt; [[2]] #&gt; y #&gt; #&gt; [[3]] #&gt; x1 + x2 #&gt; #&gt; &lt;environment: 0x1e46710&gt; 如果公式左边没有任何东西，那么列表只有两个元素： f2 &lt;- ~ x1 + x2 as.list(f2) #&gt; [[1]] #&gt; `~` #&gt; #&gt; [[2]] #&gt; x1 + x2 #&gt; #&gt; &lt;environment: 0x1e46710&gt; 公式的每一个元素都是一个符号或者语言对象（包含多个符号）： str(f[[1]]) #&gt; symbol ~ str(f[[2]]) #&gt; symbol y str(f[[3]]) #&gt; language x1 + x2 # Look at parts of the langage object str(f[[3]][[1]]) #&gt; symbol + str(f[[3]][[2]]) #&gt; symbol x1 str(f[[3]][[3]]) #&gt; symbol x2 你可以使用as.character()或deparse()函数将它们转为字符串。deparse()函数可以返回一个看起来更为自然的结果： as.character(f[[1]]) #&gt; [1] &quot;~&quot; as.character(f[[2]]) #&gt; [1] &quot;y&quot; # The language object gets coerced into a string that represents the parse tree: as.character(f[[3]]) #&gt; [1] &quot;+&quot; &quot;x1&quot; &quot;x2&quot; # You can use deparse() to get a more natural looking string deparse(f[[3]]) #&gt; [1] &quot;x1 + x2&quot; deparse(f) #&gt; [1] &quot;y ~ x1 + x2&quot; 公式对象也会捕捉调用它的环境，比如我们在运行str(f)命令时看到的那样。如果要抽取它，可以使用environment()函数： environment(f) #&gt; &lt;environment: 0x1e46710&gt; 原文链接：http://www.cookbook-r.com/Formulas/Extracting_components_from_a_formula/ "],
["section-5.html", "第 5 章 数据的导入与导出 5.1 R载入文件中的数据 5.2 键盘和剪贴板把数据载入并保存到R 5.3 运行R脚本 5.4 用R把数据写入文件 5.5 用R写入文本，分析输出到文件", " 第 5 章 数据的导入与导出 5.1 R载入文件中的数据 5.1.1 问题 你想从文件中载入数据。 5.1.2 方案 5.1.2.1 带分隔符的文本文件 最简单的输入数据的方式就是将其保存为带分隔符（如：制表位或逗号）的文本文件。 data &lt;- read.csv(&quot;datafile.csv&quot;) # 导入一个没有表头的CSV文件 data &lt;- read.csv(&quot;datafile-noheader.csv&quot;, header=FALSE) 函数read.table()是一个更为普遍的函数，允许你设置分隔符，不管是否有表头，不管字符串是否有引号，等等。使用?read.table查看更多详细信息。 data &lt;- read.table(&quot;datafile-noheader.csv&quot;, header=FALSE, sep=&quot;,&quot; # 制表位分隔的文件用&quot;\\t&quot; ) 5.1.2.2 打开文件的文件选择器 某些平台，使用file.choose()可以打开文件选择的对话窗口；其他平台则会提示用户输入一个文件名。 data &lt;- read.csv(file.choose()) 5.1.2.3 把字符串看作因子（factor）或字符（character） 默认条件下，数据中的字符串都被转换为因子。如果你用read.csv()载入数据，所有的文本列都会被视为因子，即便它被处理为字符串更有意义。要这么做，使用 stringsAsFactors=FALSE: data &lt;- read.csv(&quot;datafile.csv&quot;, stringsAsFactors=FALSE) # 将某一列转化为因子 data$Sex &lt;- factor(data$Sex) 另一种将他们加载为因子，把某一列转换为字符的方法： data &lt;- read.csv(&quot;datafile.csv&quot;) data$First &lt;- as.character(data$First) data$Last &lt;- as.character(data$Last) # 另一种方法：转化名为“First”和“Last”的两列 stringcols &lt;- c(&quot;First&quot;,&quot;Last&quot;) data[stringcols] &lt;- lapply(data[stringcols], as.character) 5.1.2.4 从网上导入文件 也可以从URL加载数据。这些(很长的)URL可以加载相关文件。 data &lt;- read.csv(&quot;http://www.cookbook-r.com/Data_input_and_output/Loading_data_from_a_file/datafile.csv&quot;) # 读取没有表头的CSV文件 data &lt;- read.csv(&quot;http://www.cookbook-r.com/Data_input_and_output/Loading_data_from_a_file/datafile-noheader.csv&quot;, header=FALSE) # 手动添加表头 names(data) &lt;- c(&quot;First&quot;,&quot;Last&quot;,&quot;Sex&quot;,&quot;Number&quot;) 上述所使用的数据文件： datafile.csv： &quot;First&quot;,&quot;Last&quot;,&quot;Sex&quot;,&quot;Number&quot; &quot;Currer&quot;,&quot;Bell&quot;,&quot;F&quot;,2 &quot;Dr.&quot;,&quot;Seuss&quot;,&quot;M&quot;,49 &quot;&quot;,&quot;Student&quot;,NA,21 datafile-noheader.csv: &quot;Currer&quot;,&quot;Bell&quot;,&quot;F&quot;,2 &quot;Dr.&quot;,&quot;Seuss&quot;,&quot;M&quot;,49 &quot;&quot;,&quot;Student&quot;,NA,21 5.1.2.5 定宽文本文件 假如你的数据列宽固定，如下例： First Last Sex Number Currer Bell F 2 Dr. Seuss M 49 &quot;&quot; Student NA 21 读取这种数据的一种方式是简单地使用read.table()函数strip.white=TRUE，可以清除额外的空格。 read.table(&quot;clipboard&quot;, header=TRUE, strip.white=TRUE) 然而，你的数据文件可能包含空间列，或列没有空格分开，这样，scores列表示六个不同的测量值，每一个从0到3。 subject sex scores N 1 M 113311 NE 2 F 112231 S 3 F 111221 W 4 M 011002 这种情况，你可能需要使用read.fwf()函数。如果你读的列名来自于文件，它要求他们用分隔符（如：制表位，空格，逗号）分开。如果有多个空格分开将他们分开，如下例，你需要直接指定列的名称。 # 指定列的名称 read.fwf(&quot;myfile.txt&quot;, c(7,5,-2,1,1,1,1,1,1), # 列的宽度，-2意味着放弃这些列 skip=1, # 跳过第一行（包括表头） col.names=c(&quot;subject&quot;,&quot;sex&quot;,&quot;s1&quot;,&quot;s2&quot;,&quot;s3&quot;,&quot;s4&quot;,&quot;s5&quot;,&quot;s6&quot;), strip.white=TRUE) # 跳过每个数据的前导和尾随 #&gt; subject sex s1 s2 s3 s4 s5 s6 #&gt; 1 N 1 M 1 1 3 3 1 1 #&gt; 2 NE 2 F 1 1 2 2 3 1 #&gt; 3 S 3 F 1 1 1 2 2 1 #&gt; 4 W 4 M 0 1 1 0 0 2 # subject sex s1 s2 s3 s4 s5 s6 # N 1 M 1 1 3 3 1 1 # NE 2 F 1 1 2 2 3 1 # S 3 F 1 1 1 2 2 1 # W 4 M 0 1 1 0 0 2 # 如果第一行如下： # subject,sex,scores # 我们可以使用header=TRUE read.fwf(&quot;myfile.txt&quot;, c(7,5,-2,1,1,1,1,1,1), header=TRUE, strip.white=TRUE) #&gt; Error in read.table(file = FILE, header = header, sep = sep, row.names = row.names, : more columns than column names # 错误：列比例名多 5.1.2.6 Excel文件 gdata包里的read.xls函数可以读取Excel文件。 library(gdata) data &lt;- read.xls(&quot;data.xls&quot;) gdata包，见http://cran.r-project.org/doc/manuals/R-data.html#Reading-Excel-spreadsheets. 包的安装，见Basics-安装和使用R包 5.1.2.7 SPSS数据 foreign包里的read.spss函数可以读取SPSS文件。 library(foreign) data &lt;- read.spss(&quot;data.sav&quot;, to.data.frame=TRUE) 原文链接：http://www.cookbook-r.com/Data_input_and_output/Loading_data_from_a_file/ 5.2 键盘和剪贴板把数据载入并保存到R 5.2.1 问题 你想用键盘输入数据，而不是从文件中载入。 5.2.2 方案 5.2.2.1 数据输入 假如您的数据如下： size weight cost small 5 6 medium 8 10 large 11 9 5.2.2.1.1 键盘输入或从剪贴板载入数据 从键盘上输入的方法之一是从标准输入读取（stdin()）。 # 使用read.table和stdin()剪切和粘贴 data &lt;- read.table(stdin(), header=TRUE) # 系统将提示您输入:在这复制和粘贴文本 # 或者： # data &lt;- read.csv(stdin()) 你也可以直接从剪贴板载入： # 首先将数据复制到剪贴板 data &lt;- read.table(&#39;clipboard&#39;, header=TRUE) # 或者： # data &lt;- read.csv(&#39;clipboard&#39;) 5.2.2.1.2 在脚本中载入数据 前面的方法不能用来加载脚本文件中的数据，因为输入必须被键入(或粘贴)在运行该命令之后。 # 使用read.table() data &lt;- read.table(header=TRUE, text=&#39; size weight cost small 5 6 medium 8 10 large 11 9 &#39;) 不同的数据格式(如：以逗号分隔，没有表头，等等)，选择read.table()可以设置。 见../ Data input and output-R载入文件中的数据查看更多信息。 5.2.2.2 数据输出 默认情况下，R打印行名称。如果你想打印表的格式，可以复制粘贴，可能很有用。 print(data, row.names=FALSE) #&gt; size weight cost #&gt; small 5 6 #&gt; medium 8 10 #&gt; large 11 9 5.2.2.2.1 写入可以复制粘贴或粘贴到剪贴板的数据 可以写带分隔符数据终端（stdout()），这样它就可以被复制粘贴到其他地方，也可以直接写入到剪贴板。 write.csv(data, stdout(), row.names=FALSE) # &quot;size&quot;,&quot;weight&quot;,&quot;cost&quot; # &quot;small&quot;,5,6 # &quot;medium&quot;,8,10 # &quot;large&quot;,11,9 # 写到剪贴板(不支持Mac或Unix) write.csv(data, &#39;clipboard&#39;, row.names=FALSE) 5.2.2.2.2 输出R的载入 如果数据已经加载到R，可以使用dput()保存数据。从dput()的输出是创建数据结构的一个命令。这种方法的优点是，它可以保持任何数据类型的修改。举个例子，如果有一列数据，包含数字和你已经转换好的因子，这种方法将保留该类型，而简单地加载文本表格（如上所示）将把它处理为数字。 # 假如你已经载入数据 dput(data) #&gt; structure(list(size = structure(c(3L, 2L, 1L), .Label = c(&quot;large&quot;, #&gt; &quot;medium&quot;, &quot;small&quot;), class = &quot;factor&quot;), weight = c(5L, 8L, 11L #&gt; ), cost = c(6L, 10L, 9L)), .Names = c(&quot;size&quot;, &quot;weight&quot;, &quot;cost&quot; #&gt; ), class = &quot;data.frame&quot;, row.names = c(NA, -3L)) # 之后，我们可以使用dput输出，重新创建数据结构 newdata &lt;- structure(list(size = structure(c(3L, 2L, 1L), .Label = c(&quot;large&quot;, &quot;medium&quot;, &quot;small&quot;), class = &quot;factor&quot;), weight = c(5L, 8L, 11L ), cost = c(6L, 10L, 9L)), .Names = c(&quot;size&quot;, &quot;weight&quot;, &quot;cost&quot; ), class = &quot;data.frame&quot;, row.names = c(NA, -3L)) 原文链接：http://www.cookbook-r.com/Data_input_and_output/Loading_and_storing_data_with_the_keyboard_and_clipboard/ 5.3 运行R脚本 5.3.1 问题 你想从文本文件运行R代码 5.3.2 解决 使用source()函数。 # 首先，选择合适的目录 setwd(&#39;/home/username/desktop/rcode&#39;) source(&#39;analyze.r&#39;) 请注意，如果你想让你的脚本生成文本输出，你必须使用print()或cat()函数。 x &lt;- 1:10 # 在脚本中，这什么都不做 x # 使用print()函数: print(x) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 # 更简单的输出: 没有行/列，没有文本 cat(x) #&gt; 1 2 3 4 5 6 7 8 9 10 另一种代替方法是：运行source()并加上print.eval=TRUE选项。 原文链接：http://www.cookbook-r.com/Data_input_and_output/Running_a_script/ 5.4 用R把数据写入文件 5.4.1 问题 你想把数据写入一个文件。 5.4.2 方案 5.4.2.1 写到有分隔符的文本文件 最简单的方式是用write.csv()。默认情况下，write.csv()包含行名，但是这通常没必要，而且可能会导致混乱。 # 一个简单的例子 data &lt;- read.table(header=TRUE, text=&#39; subject sex size 1 M 7 2 F NA 3 F 9 4 M 11 &#39;) # 写入到文件，不显示行名 write.csv(data, &quot;data.csv&quot;, row.names=FALSE) # 替代“NA”，输出空格 write.csv(data, &quot;data.csv&quot;, row.names=FALSE, na=&quot;&quot;) # 用制表位可以不显示行&amp;列名 write.table(data, &quot;data.csv&quot;, sep=&quot;\\t&quot;, row.names=FALSE, col.names=FALSE) 5.4.2.2 R保存的数据格式 write.csv()和write.table()是最适合与其他数据分析程序交互操作的函数。然而，他们不会保持数据结构的特殊属性，如：列是否是一个字符类型或因子，或因子的水平的顺序。为了做到这一点，它本该在R中被写成一个特殊的格式。 下面是三种主要的方法： 第一个方法是输出R源代码，运行时，将重新创建该对象。这应该对大多数数据对象有用，但它可能无法专一地重现一些较为复杂的数据对象。 # 保存在一个能容易被R载入的文本文件中 dump(&quot;data&quot;, &quot;data.Rdmpd&quot;) # 能保存多个对象 dump(c(&quot;data&quot;, &quot;data1&quot;), &quot;data.Rdmpd&quot;) # 再次加载数据 source(&quot;data.Rdmpd&quot;) # 载入时，原始的数据名称将被自动使用 另一个方法是，在RDS格式中写入的个人数据对象。这种格式可以是二进制或ASCII。二进制更紧凑，而ASCII将与版本控制系统更有效率，如Git。 # 在二进制RDS格式中保存一个简单的对象 saveRDS(data, &quot;data.rds&quot;) # 或，使用ASCII格式 saveRDS(data, &quot;data.rds&quot;, ascii=TRUE) # 再次载入: data &lt;- readRDS(&quot;data.rds&quot;) 也可以将多个对象保存到一个单一的文件，使用RData格式。 # 在二进制RData格式中保存多个对象 save(data, file=&quot;data.RData&quot;) # 或，使用ASCII格式 save(data, file=&quot;data.RData&quot;, ascii=TRUE) # 可以保存多个对象 save(data, data1, file=&quot;data.RData&quot;) # 再次载入: load(&quot;data.RData&quot;) saveRDS()和save()一个重要的区别是，使用前者，当你用readRDS()读取数据，你指定对象的名称；使用后者，当你用load()载入数据，会自动使用原来的对象名称。自动使用原始对象名称有时可以简化工作流程，但如果数据对象在不同的环境中使用时，也会成为一个缺点。 原文链接：http://www.cookbook-r.com/Data_input_and_output/Writing_data_to_a_file/ 5.5 用R写入文本，分析输出到文件 5.5.1 问题 如果你想写出到文件 5.5.2 方案 sink()函数将会不定向输出到一个文件，而不是R终端。请注意，如果您在脚本中使用sink()，它崩溃之前输出到终端，然后看不到任何对你命令的响应。sink()的调用不带任何参数将返回输出到终端。 # 开始写入到文件 sink(&#39;analysis-output.txt&#39;) set.seed(12345) x &lt;-rnorm(10,10,1) y &lt;-rnorm(10,11,1) # 加些东西 cat(sprintf(&quot;x has %d elements:\\n&quot;, length(x))) print(x) cat(&quot;y =&quot;, y, &quot;\\n&quot;) cat(&quot;=============================\\n&quot;) cat(&quot;T-test between x and y\\n&quot;) cat(&quot;=============================\\n&quot;) t.test(x,y) # 停止写入 sink() # 附加到文件 sink(&#39;analysis-output.txt&#39;, append=TRUE) cat(&quot;Some more stuff here...\\n&quot;) sink() 输出文件的内容： x has 10 elements: [1] 10.585529 10.709466 9.890697 9.546503 10.605887 8.182044 10.630099 9.723816 [9] 9.715840 9.080678 y = 10.88375 12.81731 11.37063 11.52022 10.24947 11.8169 10.11364 10.66842 12.12071 11.29872 ============================= T-test between x and y ============================= Welch Two Sample t-test data: x and y t = -3.8326, df = 17.979, p-value = 0.001222 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -2.196802 -0.641042 sample estimates: mean of x mean of y 9.867056 11.285978 Some more stuff here... 原文链接：http://www.cookbook-r.com/Data_input_and_output/Writing_text_and_output_from_analyses_to_a_file/ "],
["section-6.html", "第 6 章 操作数据 6.1 R中的排序问题 6.2 用R生成随机的顺序 6.3 转换向量类型——数值向量，字符串向量和因子向量 6.4 用R查找并移除重复的记录 6.5 NA存在的情况下，向量或因子间的比较 6.6 数据重新编码 6.7 将向量中所有值为x的对象改变值y 6.8 重命名因子水平 6.9 重计算因子水平 6.10 改变因子水平次序 6.11 重命名数据框的列 6.12 添加和移除数据框的列 6.13 对数据框的列重新排序 6.14 融合数据框 6.15 比较数据框 6.16 重计算数据框所有因子列的水平 6.17 长宽格式数据互换 6.18 归纳总结数据 6.19 数据框与列联表互换 6.20 计算移动平均数 6.21 窗口平滑 6.22 寻找唯一值序列 6.23 用最后的非NA值填充NA值", " 第 6 章 操作数据 6.1 R中的排序问题 6.1.1 问题 你想将一个向量，矩阵或列表排序 6.1.2 解决 6.1.2.1 向量 # 生成一个随机向量 v &lt;- sample(101:110) # 排序 sort(v) #&gt; [1] 101 102 103 104 105 106 107 108 109 110 # 反向排序 sort(v, decreasing=TRUE) #&gt; [1] 110 109 108 107 106 105 104 103 102 101 6.1.2.2 列表 列表在一个或多个列进行排序，您可以使用plyr包里的arrange函数，或者使用R内置的功能。arrange函数更容易使用，但需要外部安装包。 # 生成一个列表 df &lt;- data.frame (id=1:4, weight=c(20,27,24,22), size=c(&quot;small&quot;, &quot;large&quot;, &quot;medium&quot;, &quot;large&quot;)) df library(plyr) # &quot;weight&quot;列排序，他们有相同的结果. arrange(df, weight) # 使用plyr包里的arrange函数 df[ order(df$weight), ] # 使用R内置的功能 #&gt; id weight size #&gt; 1 1 20 small #&gt; 2 4 22 large #&gt; 3 3 24 medium #&gt; 4 2 27 large # 以size为第一关键词, weight为第二关键词排序 arrange(df, size, weight) # 使用plyr包里的arrange函数 df[ order(df$size, df$weight), ] # 使用R内置的功能 #&gt; id weight size #&gt; 4 4 22 large #&gt; 2 2 27 large #&gt; 3 3 24 medium #&gt; 1 1 20 small # 所有列从左到右排序 df[ do.call(order, as.list(df)), ] # 在这个特殊的例子中,顺序将保持不变 请注意，size列是一个把行排序的因子。在这种情况下，横向将自动按字母顺序排列（创建数据表格），所以大是第一和小是最后。 6.1.2.2.1 反向排序 使用decreasing=TRUE可以反向排序。 反向排序的方法依赖于数据类型： 数字：变量名前加一个-。例如：df[order(-df$weight)] 因子：转换为整数，变量名前加一个-。例如：df[ order(-xtfrm(df$size)), ] 字符：没有简单的方法能做到这一点。一种方法是先转换为一个因子，然后如上所述。 # 反向排序weight列，他们有相同的结果： arrange(df, -weight) # 使用plyr包里的arrange函数 df[ order(df$weight, decreasing=TRUE), ] # 使用R内置的功能 df[ order(-df$weight), ] # 使用R内置的功能 #&gt; id weight size #&gt; 2 2 27 large #&gt; 3 3 24 medium #&gt; 4 4 22 large #&gt; 1 1 20 small # 升序排列size,然后降序排列weight arrange(df, size, -weight) # 使用plyr包里的arrange函数 df[ order(df$size, -df$weight), ] # 使用R内置的功能 #&gt; id weight size #&gt; 2 2 27 large #&gt; 4 4 22 large #&gt; 3 3 24 medium #&gt; 1 1 20 small # 升序排列size,然后降序排列weight # 因子需要xtfrm() arrange(df, -xtfrm(size), weight) # 使用plyr包里的arrange函数 df[ order(-xtfrm(df$size), df$weight), ] # 使用R内置的功能 #&gt; id weight size #&gt; 1 1 20 small #&gt; 3 3 24 medium #&gt; 4 4 22 large #&gt; 2 2 27 large 6.2 用R生成随机的顺序 6.2.1 问题 你想事一个数据结构随机化。 6.2.2 方案 # 创建一个向量 v &lt;- 11:20 # 随机化向量的顺序 v &lt;- sample(v) # 创建一个列表 data &lt;- data.frame(label=letters[1:5], number=11:15) data #&gt; label number #&gt; 1 a 11 #&gt; 2 b 12 #&gt; 3 c 13 #&gt; 4 d 14 #&gt; 5 e 15 # 随机化列表的顺序 data &lt;- data[sample(1:nrow(data)), ] data #&gt; label number #&gt; 5 e 15 #&gt; 2 b 12 #&gt; 4 d 14 #&gt; 3 c 13 #&gt; 1 a 11 6.2.2.1 注意 为了使随机化可重复，你应该设置随机数生成器。详见：Numbers-生成随机数、Numbers-生成可重复的随机数序列 6.3 转换向量类型——数值向量，字符串向量和因子向量 6.3.1 问题 你想在数值向量、字符串向量和因子向量间做转换。 6.3.2 方案 假设你刚开始有一个数值型向量n: n &lt;- 10:14 n #&gt; [1] 10 11 12 13 14 将这个数值型向量转换为其他两种类型（将结果保存在c和f）： # 数值型→字符串型 c &lt;- as.character(n) # 数值型→因子型 f &lt;- factor(n) # 10 11 12 13 14 将字符串型向量转化为另外两种： # 数值型 as.numeric(c) #&gt; [1] 10 11 12 13 14 # 字符串型→因子型 factor(c) #&gt; [1] 10 11 12 13 14 #&gt; Levels: 10 11 12 13 14 把一个因子转变为一个字符串型向量很简单： # 因子型→数值型 as.character(f) #&gt; [1] &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; 然而，将因子转化为数值型向量，有点棘手。如果你使用as.numberic，它将会给你因子编码的数值，恐怕不是你想要的。 as.numeric(f) #&gt; [1] 1 2 3 4 5 # 另一种方式得到数字的编码，如果这是你想要的: unclass(f) #&gt; [1] 1 2 3 4 5 #&gt; attr(,&quot;levels&quot;) #&gt; [1] &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; 方法是，先转化为字符串型，再转化为数值型。 # 因子型→数值型 as.numeric(as.character(f)) #&gt; [1] 10 11 12 13 14 6.4 用R查找并移除重复的记录 6.4.1 问题 你想查找和（或）移除向量或列表里重复的条目。 6.4.2 方案 向量： # 生成一个向量 set.seed(158) x &lt;- round(rnorm(20, 10, 5)) x #&gt; [1] 14 11 8 4 12 5 10 10 3 3 11 6 0 16 8 10 8 5 6 6 # 对于每一个元素：它是否重复（第一个值不算） duplicated(x) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE #&gt; [15] TRUE TRUE TRUE TRUE TRUE TRUE # 重复的条目的值 # 注意“6”出现了三次，所以它有俩 x[duplicated(x)] #&gt; [1] 10 3 11 8 10 8 5 6 6 # 重复的条目，没有重复 unique(x[duplicated(x)]) #&gt; [1] 10 3 11 8 5 6 # 移除重复的数据，他们效果一样: unique(x) #&gt; [1] 14 11 8 4 12 5 10 3 6 0 16 x[!duplicated(x)] #&gt; [1] 14 11 8 4 12 5 10 3 6 0 16 列表： # 一个样本列表: df &lt;- read.table(header=TRUE, text=&#39; label value A 4 B 3 C 6 B 3 B 1 A 2 A 4 A 4 &#39;) # 每一行是否有重复？ duplicated(df) #&gt; [1] FALSE FALSE FALSE TRUE FALSE FALSE TRUE TRUE # 显示重复的条目 df[duplicated(df),] #&gt; label value #&gt; 4 B 3 #&gt; 7 A 4 #&gt; 8 A 4 # 显示没有重复的条目 (行名可能不同，但值相同) unique(df[duplicated(df),]) #&gt; label value #&gt; 4 B 3 #&gt; 7 A 4 # 移除重复的数据，他们效果一样: unique(df) #&gt; label value #&gt; 1 A 4 #&gt; 2 B 3 #&gt; 3 C 6 #&gt; 5 B 1 #&gt; 6 A 2 df[!duplicated(df),] #&gt; label value #&gt; 1 A 4 #&gt; 2 B 3 #&gt; 3 C 6 #&gt; 5 B 1 #&gt; 6 A 2 6.5 NA存在的情况下，向量或因子间的比较 6.5.1 问题 你想比较两个向量或因子，而且是在NA存在的情况下比较，并返回TRUE或FALSE（而不是NA）。 6.5.2 方案 假设你有一个两列（包含布尔值）的列表： df &lt;- data.frame( a=c(TRUE,TRUE,TRUE,FALSE,FALSE,FALSE,NA,NA,NA), b=c(TRUE,FALSE,NA,TRUE,FALSE,NA,TRUE,FALSE,NA)) df #&gt; a b #&gt; 1 TRUE TRUE #&gt; 2 TRUE FALSE #&gt; 3 TRUE NA #&gt; 4 FALSE TRUE #&gt; 5 FALSE FALSE #&gt; 6 FALSE NA #&gt; 7 NA TRUE #&gt; 8 NA FALSE #&gt; 9 NA NA 通常情况下，当你比较两个包含NA值的向量或因子时，原始值是NA，结果也将有NA。根据你的目的，这（不）可能为你所需。 df$a == df$b #&gt; [1] TRUE FALSE NA FALSE TRUE NA NA NA NA # 同样的比较，但是可以生成列表的另一列： data.frame(df, isSame = (df$a==df$b)) #&gt; a b isSame #&gt; 1 TRUE TRUE TRUE #&gt; 2 TRUE FALSE FALSE #&gt; 3 TRUE NA NA #&gt; 4 FALSE TRUE FALSE #&gt; 5 FALSE FALSE TRUE #&gt; 6 FALSE NA NA #&gt; 7 NA TRUE NA #&gt; 8 NA FALSE NA #&gt; 9 NA NA NA 6.5.2.1 可以与NA相比的一个函数 这个比较函数会把NA赋予另一个值。如果一个向量的两项都是NA，则返回TRUE；如果其中一个是NA，则返回FALSE；所有其他比较(无NA之间)的方式是一样的。 # 这个函数将会返回TRUE，当两个元素相同（包括两个NA），其他情况返回FALSE compareNA &lt;- function(v1,v2) { same &lt;- (v1 == v2) | (is.na(v1) &amp; is.na(v2)) same[is.na(same)] &lt;- FALSE return(same) } 6.5.2.2 使用该函数的例子 比较两个布尔向量： compareNA(df$a, df$b) #&gt; [1] TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE # 同样的比较，生成另一列 data.frame(df, isSame = compareNA(df$a,df$b)) #&gt; a b isSame #&gt; 1 TRUE TRUE TRUE #&gt; 2 TRUE FALSE FALSE #&gt; 3 TRUE NA FALSE #&gt; 4 FALSE TRUE FALSE #&gt; 5 FALSE FALSE TRUE #&gt; 6 FALSE NA FALSE #&gt; 7 NA TRUE FALSE #&gt; 8 NA FALSE FALSE #&gt; 9 NA NA TRUE 它也能用于因子，即使因子的水平处于不同的次序： # 创建一个含因子的列表 df1 &lt;- data.frame(a = factor(c(&#39;x&#39;,&#39;x&#39;,&#39;x&#39;,&#39;y&#39;,&#39;y&#39;,&#39;y&#39;, NA, NA, NA)), b = factor(c(&#39;x&#39;,&#39;y&#39;, NA,&#39;x&#39;,&#39;y&#39;, NA,&#39;x&#39;,&#39;y&#39;, NA))) # 比较 data.frame(df1, isSame = compareNA(df1$a, df1$b)) #&gt; a b isSame #&gt; 1 x x TRUE #&gt; 2 x y FALSE #&gt; 3 x &lt;NA&gt; FALSE #&gt; 4 y x FALSE #&gt; 5 y y TRUE #&gt; 6 y &lt;NA&gt; FALSE #&gt; 7 &lt;NA&gt; x FALSE #&gt; 8 &lt;NA&gt; y FALSE #&gt; 9 &lt;NA&gt; &lt;NA&gt; TRUE # 也能用于因子，即使因子的水平处于不同的次序 df1$b &lt;- factor(df1$b, levels=c(&#39;y&#39;,&#39;x&#39;)) data.frame(df1, isSame = compareNA(df1$a, df1$b)) #&gt; a b isSame #&gt; 1 x x TRUE #&gt; 2 x y FALSE #&gt; 3 x &lt;NA&gt; FALSE #&gt; 4 y x FALSE #&gt; 5 y y TRUE #&gt; 6 y &lt;NA&gt; FALSE #&gt; 7 &lt;NA&gt; x FALSE #&gt; 8 &lt;NA&gt; y FALSE #&gt; 9 &lt;NA&gt; &lt;NA&gt; TRUE 6.6 数据重新编码 6.6.1 问题 你想重新编码数据或从现有的数据中计算生产新的数据列。 6.6.2 方案 下面的例子将使用这些数据： data &lt;- read.table(header=T, text=&#39; subject sex control cond1 cond2 1 M 7.9 12.3 10.7 2 F 6.3 10.6 11.1 3 F 9.5 13.1 13.8 4 M 11.5 13.4 12.9 &#39;) 6.6.2.1 重新编码分类变量 最简单的方法是使用plyr包里的revalue()或mapvalues()。这可以令M为1、F为2，并把它放在一个新生产的列。注意，这两个函数均保存数据类型：如果输入一个因子，输出将会是一个因子；如果输入是一个字符串向量，输出将会是一个字符串向量。 library(plyr) # 下面两行是等价的: data$scode &lt;- revalue(data$sex, c(&quot;M&quot;=&quot;1&quot;, &quot;F&quot;=&quot;2&quot;)) data$scode &lt;- mapvalues(data$sex, from = c(&quot;M&quot;, &quot;F&quot;), to = c(&quot;1&quot;, &quot;2&quot;)) data #&gt; subject sex control cond1 cond2 scode #&gt; 1 1 M 7.9 12.3 10.7 1 #&gt; 2 2 F 6.3 10.6 11.1 2 #&gt; 3 3 F 9.5 13.1 13.8 2 #&gt; 4 4 M 11.5 13.4 12.9 1 # data$sex是一个因子，因此data$scode也是因子 详见Manipulating Data - 映射向量的值 Manipulating Data - 重命名因子水平 如果你不想依赖plyr，你可以使用R内置函数： data$scode[data$sex==&quot;M&quot;] &lt;- &quot;1&quot; data$scode[data$sex==&quot;F&quot;] &lt;- &quot;2&quot; # 把列转换为因子 data$scode &lt;- factor(data$scode) data #&gt; subject sex control cond1 cond2 scode #&gt; 1 1 M 7.9 12.3 10.7 1 #&gt; 2 2 F 6.3 10.6 11.1 2 #&gt; 3 3 F 9.5 13.1 13.8 2 #&gt; 4 4 M 11.5 13.4 12.9 1 另一种方法是使用match函数： oldvalues &lt;- c(&quot;M&quot;, &quot;F&quot;) newvalues &lt;- factor(c(&quot;g1&quot;,&quot;g2&quot;)) # 因子 data$scode &lt;- newvalues[ match(data$sex, oldvalues) ] data #&gt; subject sex control cond1 cond2 scode #&gt; 1 1 M 7.9 12.3 10.7 g1 #&gt; 2 2 F 6.3 10.6 11.1 g2 #&gt; 3 3 F 9.5 13.1 13.8 g2 #&gt; 4 4 M 11.5 13.4 12.9 g1 6.6.2.2 将一个连续变量编码为分类变量 标记这些值，control值小于7为“low”，大于或等于7为“high”： data$category[data$control&lt; 7] &lt;- &quot;low&quot; data$category[data$control&gt;=7] &lt;- &quot;high&quot; # 把列转换为因子 data$category &lt;- factor(data$category) data #&gt; subject sex control cond1 cond2 scode category #&gt; 1 1 M 7.9 12.3 10.7 g1 high #&gt; 2 2 F 6.3 10.6 11.1 g2 low #&gt; 3 3 F 9.5 13.1 13.8 g2 high #&gt; 4 4 M 11.5 13.4 12.9 g1 high 用cut函数，可以指定上下限： data$category &lt;- cut(data$control, breaks=c(-Inf, 7, 9, Inf), labels=c(&quot;low&quot;,&quot;medium&quot;,&quot;high&quot;)) data #&gt; subject sex control cond1 cond2 scode category #&gt; 1 1 M 7.9 12.3 10.7 g1 medium #&gt; 2 2 F 6.3 10.6 11.1 g2 low #&gt; 3 3 F 9.5 13.1 13.8 g2 high #&gt; 4 4 M 11.5 13.4 12.9 g1 high 默认情况下，范围是左边开放、右边关闭，如(7，9]。使用right= FALSE可以设置成左边关闭、右边开放，像[7、9)。 6.6.2.3 计算得到一个新的连续变量 假设您想添加一个新列，为三个量的和。 data$total &lt;- data$control + data$cond1 + data$cond2 data #&gt; subject sex control cond1 cond2 scode category total #&gt; 1 1 M 7.9 12.3 10.7 g1 medium 30.9 #&gt; 2 2 F 6.3 10.6 11.1 g2 low 28.0 #&gt; 3 3 F 9.5 13.1 13.8 g2 high 36.4 #&gt; 4 4 M 11.5 13.4 12.9 g1 high 37.8 6.7 将向量中所有值为x的对象改变值y 6.7.1 问题 你想将向量中所有值为x的实例改为值y。 6.7.2 方案 # 创建一些样本数据 str &lt;- c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;) num &lt;- c(1, 2, 3) 最简单的方法是使用plyr包里的revalue()或mapvalues()。 library(plyr) revalue(str, c(&quot;beta&quot;=&quot;two&quot;, &quot;gamma&quot;=&quot;three&quot;)) #&gt; [1] &quot;alpha&quot; &quot;two&quot; &quot;three&quot; mapvalues(str, from = c(&quot;beta&quot;, &quot;gamma&quot;), to = c(&quot;two&quot;, &quot;three&quot;)) #&gt; [1] &quot;alpha&quot; &quot;two&quot; &quot;three&quot; # 对于数值型向量，revalue()没作用，由于它使用一个命名了的向量，向量名一般是字符串而不是数值，但mapvalues()仍然有作用 mapvalues(num, from = c(2, 3), to = c(5, 6)) #&gt; [1] 1 5 6 如果你不想依赖plyr，你可以使用R内置函数。注意，这些方法将直接修改向量；也就是说，你不需要把结果保存回变量。 # 把&quot;beta&quot; 替换为 &quot;two&quot; str[str==&quot;beta&quot;] &lt;- &quot;two&quot; str #&gt; [1] &quot;alpha&quot; &quot;two&quot; &quot;gamma&quot; num[num==2] &lt;- 5 num #&gt; [1] 1 5 3 也可以使用R的字符串的查找和替换函数来重新映射字符串向量的值。注意，alpha前后的^和$确保整个字符串匹配。没有它们，如果有一个值为alphabet，它也会被匹配，替代onebet`。 str &lt;- c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;) sub(&quot;^alpha$&quot;, &quot;one&quot;, str) #&gt; [1] &quot;one&quot; &quot;beta&quot; &quot;gamma&quot; # 把所有列的 &quot;a&quot; 替代为 &quot;X&quot; gsub(&quot;a&quot;, &quot;X&quot;, str) #&gt; [1] &quot;XlphX&quot; &quot;betX&quot; &quot;gXmmX&quot; # gsub() 替代所有匹配的元素 # sub() 只替代每一个元素首先匹配到的内容 6.7.3 另见 详见重命名因子水平 6.8 重命名因子水平 6.8.1 问题 你想要重命名因子水平。 6.8.2 方案 # 处理一个因子的样例 x &lt;- factor(c(&quot;alpha&quot;,&quot;beta&quot;,&quot;gamma&quot;,&quot;alpha&quot;,&quot;beta&quot;)) x #&gt; [1] alpha beta gamma alpha beta #&gt; Levels: alpha beta gamma levels(x) #&gt; [1] &quot;alpha&quot; &quot;beta&quot; &quot;gamma&quot; 最简单的办法是使用plyr包中的revalue()或者mapvalues()函数。 library(plyr) revalue(x, c(&quot;beta&quot;=&quot;two&quot;, &quot;gamma&quot;=&quot;three&quot;)) #&gt; [1] alpha two three alpha two #&gt; Levels: alpha two three mapvalues(x, from = c(&quot;beta&quot;, &quot;gamma&quot;), to = c(&quot;two&quot;, &quot;three&quot;)) #&gt; [1] alpha two three alpha two #&gt; Levels: alpha two three 如果你不想要依赖plyr包，你可以使用R的内置函数进行以下处理。注意这些方法会直接修改变量x；这说明，你不需要将结果重新赋值回给x。 # 通过名字重命名: change &quot;beta&quot; to &quot;two&quot; levels(x)[levels(x)==&quot;beta&quot;] &lt;- &quot;two&quot; # 你也可以通过位置重命名，但这种做法比较危险（会因数据变化造成不可控结果），不值得推荐 # 通过因子列表索引重命名: change third item, &quot;gamma&quot;, to &quot;three&quot;. levels(x)[3] &lt;- &quot;three&quot; x #&gt; [1] alpha two three alpha two #&gt; Levels: alpha two three # 重命名所有的因子水平 levels(x) &lt;- c(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;) x #&gt; [1] one two three one two #&gt; Levels: one two three 我们可以不使用plyr包而通过名字实现因子水平的重命名，但记住这只有在所有的水平都在列表中时才起作用，否则会返回NA以代替寻找不到的因子水平。 # Rename all levels, by name x &lt;- factor(c(&quot;alpha&quot;,&quot;beta&quot;,&quot;gamma&quot;,&quot;alpha&quot;,&quot;beta&quot;)) levels(x) &lt;- list(A=&quot;alpha&quot;, B=&quot;beta&quot;, C=&quot;gamma&quot;) x #&gt; [1] A B C A B #&gt; Levels: A B C 我们也可以使用R的字符串搜索与替换函数去重命名因子水平。注意字符alpha周围的^与$符号是用来确保整个字符串能够匹配（正则表达式）。如果没有它们，字符alphabet也能够被成功匹配并会被替换为onbet。 # 一个样例 x &lt;- factor(c(&quot;alpha&quot;,&quot;beta&quot;,&quot;gamma&quot;,&quot;alpha&quot;,&quot;beta&quot;)) x #&gt; [1] alpha beta gamma alpha beta #&gt; Levels: alpha beta gamma levels(x) &lt;- sub(&quot;^alpha$&quot;, &quot;one&quot;, levels(x)) x #&gt; [1] one beta gamma one beta #&gt; Levels: one beta gamma # Across all columns, replace all instances of &quot;a&quot; with &quot;X&quot; levels(x) &lt;- gsub(&quot;a&quot;, &quot;X&quot;, levels(x)) x #&gt; [1] one betX gXmmX one betX #&gt; Levels: one betX gXmmX # gsub() replaces all instances of the pattern in each factor level. # sub() replaces only the first instance in each factor level. 6.8.3 更多参考 匹配向量中值并将其替换为新的值操作类似，参见 ../Mapping vector values获取更多信息。 6.9 重计算因子水平 6.9.1 问题 你想要重新计算一个因子的水平。这在因子水平实际并没有出现在数据中时非常有用。它可能发生在数据的导入，或者当你移除一些行。 6.9.2 方案 对于单个因子变量： # 创建额外的因子水平 (gamma) x &lt;- factor(c(&quot;alpha&quot;,&quot;beta&quot;,&quot;alpha&quot;), levels=c(&quot;alpha&quot;,&quot;beta&quot;,&quot;gamma&quot;)) x #&gt; [1] alpha beta alpha #&gt; Levels: alpha beta gamma # 移除额外的因子水平 x &lt;- factor(x) x #&gt; [1] alpha beta alpha #&gt; Levels: alpha beta 当导入数据之后，你可能有一个混合因子变量和其他向量的数据框，然后想要重新计算所有因子的水平。你可以使用droplevels()函数实现这一点。 # 创建一些因子的数据框 (有额外的因子水平) df &lt;- data.frame( x = factor(c(&quot;alpha&quot;,&quot;beta&quot;,&quot;alpha&quot;), levels=c(&quot;alpha&quot;,&quot;beta&quot;,&quot;gamma&quot;)), y = c(5,8,2), z = factor(c(&quot;red&quot;,&quot;green&quot;,&quot;green&quot;), levels=c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;)) ) # 显示因子水平 (with extra levels) df$x #&gt; [1] alpha beta alpha #&gt; Levels: alpha beta gamma df$z #&gt; [1] red green green #&gt; Levels: red green blue # 丢掉额外因子水平 df &lt;- droplevels(df) # 再次显示因子，现在没有额外的因子水平了 df$x #&gt; [1] alpha beta alpha #&gt; Levels: alpha beta df$z #&gt; [1] red green green #&gt; Levels: red green 6.9.3 另见 想要重计算一个数据框中所有的因子变量列的因子水平，参见 ../Re-computing_the_levels_of_all_factor_columns_in_a_data_frame。 6.10 改变因子水平次序 6.10.1 问题 你想要改变因子水平出现的次序。 6.10.2 方案 R中有两种不同类型的因子变量：有序和无序。比如{小，中，大}和｛钢笔，橡皮擦，铅笔｝。对于绝大多数分析而言，一个因子变量是有序还是无序的不重要。如果因子是有序的，那么这个因子水平的特定次序是重要的（小 [1] small large large small medium #&gt; Levels: large medium small ``` 因子水平被显式地指定： sizes &lt;- factor(sizes, levels = c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: small medium large 我们同样可以对有序因子这样操作： sizes &lt;- ordered(c(&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;, &quot;medium&quot;)) sizes &lt;- ordered(sizes, levels = c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: small &lt; medium &lt; large 另一种方式是使用relevel()函数在列表中制作一个特定水平（这对有序因子不起作用）。 # 创建错误次序的因子 sizes &lt;- factor(c(&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;, &quot;medium&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: large medium small # 使得 medium 排最前面 sizes &lt;- relevel(sizes, &quot;medium&quot;) sizes #&gt; [1] small large large small medium #&gt; Levels: medium large small # 使得 small 排最前面 sizes &lt;- relevel(sizes, &quot;small&quot;) sizes #&gt; [1] small large large small medium #&gt; Levels: small medium large 当因子创建时，我们可以指定合适的顺序。 sizes &lt;- factor(c(&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;, &quot;medium&quot;), levels = c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: small medium large 反转因子水平次序。 # 创建错误次序的因子 sizes &lt;- factor(c(&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;, &quot;medium&quot;)) sizes #&gt; [1] small large large small medium #&gt; Levels: large medium small sizes &lt;- factor(sizes, levels=rev(levels(sizes))) sizes #&gt; [1] small large large small medium #&gt; Levels: small medium large 6.11 重命名数据框的列 6.11.1 问题 你想要给数据框的列重新命名。 6.11.2 方案 让我们从有三列的一个数据框开始： d &lt;- data.frame(alpha=1:3, beta=4:6, gamma=7:9) d #&gt; alpha beta gamma #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 names(d) #&gt; [1] &quot;alpha&quot; &quot;beta&quot; &quot;gamma&quot; 最简单的方式是使用plyr包的rename()函数： library(plyr) rename(d, c(&quot;beta&quot;=&quot;two&quot;, &quot;gamma&quot;=&quot;three&quot;)) #&gt; alpha two three #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 如果你不想要依赖plyr包，你可以使用下面R内置的函数。注意这些直接修改了d，意味着你不需要把结果保存回d。 # 通过name函数重命名列：把&quot;beta&quot;改为&quot;two&quot; names(d)[names(d)==&quot;beta&quot;] &lt;- &quot;two&quot; d #&gt; alpha two gamma #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 # 你也可以通过位置索引改变名字，但这种操作会有点危险，一旦你以后对数据做出改变，这些操作可能就不适用了。 # 通过名字向量的位置索引重命名：改变第三项，将&quot;gamma&quot;改成&quot;three&quot; names(d)[3] &lt;- &quot;three&quot; d #&gt; alpha two three #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 也可以使用R的字符串搜索和替换函数来重命名列。注意alpha周围的^和$是确保全部字符串匹配。没有他们的话，如果存在一个叫alphabet的列也会匹配成功。 names(d) &lt;- sub(&quot;^alpha$&quot;, &quot;one&quot;, names(d)) d #&gt; one two three #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 # 所有的列中，替换列名中的&quot;t&quot;为&quot;X&quot; names(d) &lt;- gsub(&quot;t&quot;, &quot;X&quot;, names(d)) d #&gt; one Xwo Xhree #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 # gsub()替换每个列名中所有的匹配项 # sub()只替换每个列名中匹配的第一项 6.12 添加和移除数据框的列 6.12.1 问题 你想要对一个数据框添加或者移除一些列（变量）。 6.12.2 方案 这里有着许多解决办法： data &lt;- read.table(header=TRUE, text=&#39; id weight 1 20 2 27 3 24 &#39;) # 添加一列的办法 data$size &lt;- c(&quot;small&quot;, &quot;large&quot;, &quot;medium&quot;) data[[&quot;size&quot;]] &lt;- c(&quot;small&quot;, &quot;large&quot;, &quot;medium&quot;) data[,&quot;size&quot;] &lt;- c(&quot;small&quot;, &quot;large&quot;, &quot;medium&quot;) data$size &lt;- 0 # 添加的变量所有行都是一样的值 # 移除列的办法 data$size &lt;- NULL data[[&quot;size&quot;]] &lt;- NULL data[,&quot;size&quot;] &lt;- NULL data[[3]] &lt;- NULL data[,3] &lt;- NULL data &lt;- subset(data, select=-size) 6.13 对数据框的列重新排序 6.13.1 问题 你想要对一个数据框的列重新排序。 6.13.2 方案 # 一个样例数据框 data &lt;- read.table(header=TRUE, text=&#39; id weight size 1 20 small 2 27 large 3 24 medium &#39;) # 根据列名数字排序 data[c(1,3,2)] #&gt; id size weight #&gt; 1 1 small 20 #&gt; 2 2 large 27 #&gt; 3 3 medium 24 # 如果你想要实际改变`data`，需要把它重新赋值回`data`符号： # data &lt;- data[c(1,3,2)] # 根据列名重新排序 data[c(&quot;size&quot;, &quot;id&quot;, &quot;weight&quot;)] #&gt; size id weight #&gt; 1 small 1 20 #&gt; 2 large 2 27 #&gt; 3 medium 3 24 上面例子中对数据框进行索引是将数据框作为一个列表（一个数据框实际上就是向量列表）。你也可以使用矩阵形式的索引方式： data[, c(1,3,2)] #&gt; id size weight #&gt; 1 1 small 20 #&gt; 2 2 large 27 #&gt; 3 3 medium 24 矩阵形式索引的缺点在于当你只指定一列时结果会不同。下面例子中，返回的结果对象是一个向量而不是数据框。因为返回的数据类型并不能总是与矩阵索引保持一致，所以通常使用列表形式进行索引更为安全，或者在矩阵索引形式中指定drop=FALSE选项： # 列表形式的索引 data[2] #&gt; weight #&gt; 1 20 #&gt; 2 27 #&gt; 3 24 # 矩阵形式的索引——降维会变为一个向量 data[,2] #&gt; [1] 20 27 24 # 矩阵形式的索引，指定drop=FALSE——保留维度以保存数据框形式 data[, 2, drop=FALSE] #&gt; weight #&gt; 1 20 #&gt; 2 27 #&gt; 3 24 6.14 融合数据框 6.14.1 问题 你想要基于一个给定的列融合两个数据框（像SQL的join）。 6.14.2 方案 # 创建一个将storyid映射到titles上的数据框 stories &lt;- read.table(header=TRUE, text=&#39; storyid title 1 lions 2 tigers 3 bears &#39;) # 创建另一个有数据和storyid的数据框（没有titles） data &lt;- read.table(header=TRUE, text=&#39; subject storyid rating 1 1 6.7 1 2 4.5 1 3 3.7 2 2 3.3 2 3 4.1 2 1 5.2 &#39;) # 融合两个数据框 merge(stories, data, &quot;storyid&quot;) #&gt; storyid title subject rating #&gt; 1 1 lions 1 6.7 #&gt; 2 1 lions 2 5.2 #&gt; 3 2 tigers 1 4.5 #&gt; 4 2 tigers 2 3.3 #&gt; 5 3 bears 1 3.7 #&gt; 6 3 bears 2 4.1 如果两个数据框里你想要匹配的列有不同的名字，可以通过选项指定： # 下面使用的是`id`替换了storyid stories2 &lt;- read.table(header=TRUE, text=&#39; id title 1 lions 2 tigers 3 bears &#39;) # 融合两个数据框 merge(x=stories2, y=data, by.x=&quot;id&quot;, by.y=&quot;storyid&quot;) #&gt; id title subject rating #&gt; 1 1 lions 1 6.7 #&gt; 2 1 lions 2 5.2 #&gt; 3 2 tigers 1 4.5 #&gt; 4 2 tigers 2 3.3 #&gt; 5 3 bears 1 3.7 #&gt; 6 3 bears 2 4.1 # 注意结果的列名继承第一个数据框 我们也可以融合多个列： # 制造更多的数据 animals &lt;- read.table(header=T, text=&#39; size type name small cat lynx big cat tiger small dog chihuahua big dog &quot;great dane&quot; &#39;) observations &lt;- read.table(header=T, text=&#39; number size type 1 big cat 2 small dog 3 small dog 4 big dog &#39;) merge(observations, animals, c(&quot;size&quot;,&quot;type&quot;)) #&gt; size type number name #&gt; 1 big cat 1 tiger #&gt; 2 big dog 4 great dane #&gt; 3 small dog 2 chihuahua #&gt; 4 small dog 3 chihuahua 6.14.2.1 注意 融合之后，改变列名的顺序可能是 有用的，参见../Reordering the columns in a data frame 。 6.15 比较数据框 6.15.1 问题 你想要比较两个或多个数据框并找到在超过一个数据框中出现的行，或者仅在一个数据框中出现的行。 6.15.2 方案 6.15.2.1 一个例子 假设你有下面三个数据框，你想要知道那些至少在两个数据框中出现的行。 dfA &lt;- data.frame(Subject=c(1,1,2,2), Response=c(&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;)) dfA #&gt; Subject Response #&gt; 1 1 X #&gt; 2 1 X #&gt; 3 2 X #&gt; 4 2 X dfB &lt;- data.frame(Subject=c(1,2,3), Response=c(&quot;X&quot;,&quot;Y&quot;,&quot;X&quot;)) dfB #&gt; Subject Response #&gt; 1 1 X #&gt; 2 2 Y #&gt; 3 3 X dfC &lt;- data.frame(Subject=c(1,2,3), Response=c(&quot;Z&quot;,&quot;Y&quot;,&quot;Z&quot;)) dfC #&gt; Subject Response #&gt; 1 1 Z #&gt; 2 2 Y #&gt; 3 3 Z 在dfA中，包括(1,X)的行同样出现在了dfB，但是包含(2,X)的行没有出现在任何其他的数据框。相似地，df包含的(1,X)出现在了dfA，(2,Y)出现在了dfC，但是(3,X)没有出现在其他数据框。 你可能想要标记在其他数据框中出现了的行，或者没有数据框中都是唯一的行。 6.15.2.1.1 连接数据框 进一步地，我们首先用一个可以识别每一行来自哪里的列来连接数据框。这里称为Coder变量因为它可能是由三个不同的人编码的数据。在这个例子中，你可能想要找到编码者同意之处（至少出现在两个数据框中的行），或者它们不同意之处。 dfA$Coder &lt;- &quot;A&quot; dfB$Coder &lt;- &quot;B&quot; dfC$Coder &lt;- &quot;C&quot; df &lt;- rbind(dfA, dfB, dfC) # 把它们粘在一起 df &lt;- df[,c(&quot;Coder&quot;, &quot;Subject&quot;, &quot;Response&quot;)] # 重新排序 df #&gt; Coder Subject Response #&gt; 1 A 1 X #&gt; 2 A 1 X #&gt; 3 A 2 X #&gt; 4 A 2 X #&gt; 5 B 1 X #&gt; 6 B 2 Y #&gt; 7 B 3 X #&gt; 8 C 1 Z #&gt; 9 C 2 Y #&gt; 10 C 3 Z 如果你的数据一开始就是这种格式，那就不要将它们连接到一起啦。 6.15.2.1.2 寻找重复行 使用在文末定义的函数dupsBetweenGroups，我们可以找出在不同组别中重复的行。 # 找出在不同组别中重复的行 dupRows &lt;- dupsBetweenGroups(df, &quot;Coder&quot;) # 在数据框的旁边打印出来 cbind(df, dup=dupRows) #&gt; Coder Subject Response dup #&gt; 1 A 1 X TRUE #&gt; 2 A 1 X TRUE #&gt; 3 A 2 X FALSE #&gt; 4 A 2 X FALSE #&gt; 5 B 1 X TRUE #&gt; 6 B 2 Y TRUE #&gt; 7 B 3 X FALSE #&gt; 8 C 1 Z FALSE #&gt; 9 C 2 Y TRUE #&gt; 10 C 3 Z FALSE 注意这不会标记在同一组中的重复行，比如Coder=A时，有两行Subject=2以及Response=X，但没有标记出来。 6.15.2.1.3 寻找唯一行 同样可以找出在每一组中唯一出现的行。 cbind(df, unique=!dupRows) #&gt; Coder Subject Response unique #&gt; 1 A 1 X FALSE #&gt; 2 A 1 X FALSE #&gt; 3 A 2 X TRUE #&gt; 4 A 2 X TRUE #&gt; 5 B 1 X FALSE #&gt; 6 B 2 Y FALSE #&gt; 7 B 3 X TRUE #&gt; 8 C 1 Z TRUE #&gt; 9 C 2 Y FALSE #&gt; 10 C 3 Z TRUE 6.15.2.1.4 拆分数据框 如果你想要把连接的数据框拆分为三个原始的数据框 # 保存df的结果 dfDup &lt;- cbind(df, dup=dupRows) dfA &lt;- subset(dfDup, Coder==&quot;A&quot;, select=-Coder) dfA #&gt; Subject Response dup #&gt; 1 1 X TRUE #&gt; 2 1 X TRUE #&gt; 3 2 X FALSE #&gt; 4 2 X FALSE dfB &lt;- subset(dfDup, Coder==&quot;B&quot;, select=-Coder) dfB #&gt; Subject Response dup #&gt; 5 1 X TRUE #&gt; 6 2 Y TRUE #&gt; 7 3 X FALSE dfC &lt;- subset(dfDup, Coder==&quot;C&quot;, select=-Coder) dfC #&gt; Subject Response dup #&gt; 8 1 Z FALSE #&gt; 9 2 Y TRUE #&gt; 10 3 Z FALSE 6.15.2.1.5 忽略列 有可能需要通过移除数据框的列来忽略一个或者多个列，结果又可以把原始完整的数据框连接起来。 # 忽略Subject列——仅使用Response列 dfNoSub &lt;- subset(df, select=-Subject) dfNoSub #&gt; Coder Response #&gt; 1 A X #&gt; 2 A X #&gt; 3 A X #&gt; 4 A X #&gt; 5 B X #&gt; 6 B Y #&gt; 7 B X #&gt; 8 C Z #&gt; 9 C Y #&gt; 10 C Z # 检查重复行 dupRows &lt;- dupsBetweenGroups(dfNoSub, &quot;Coder&quot;) # 把结果连接起来 cbind(df, dup=dupRows) #&gt; Coder Subject Response dup #&gt; 1 A 1 X TRUE #&gt; 2 A 1 X TRUE #&gt; 3 A 2 X TRUE #&gt; 4 A 2 X TRUE #&gt; 5 B 1 X TRUE #&gt; 6 B 2 Y TRUE #&gt; 7 B 3 X TRUE #&gt; 8 C 1 Z FALSE #&gt; 9 C 2 Y TRUE #&gt; 10 C 3 Z FALSE 6.15.2.2 dupsBetweenGroups 函数 该函数用来寻找不同组别的重复行： dupsBetweenGroups &lt;- function (df, idcol) { # df: the data frame # idcol: the column which identifies the group each row belongs to # Get the data columns to use for finding matches datacols &lt;- setdiff(names(df), idcol) # Sort by idcol, then datacols. Save order so we can undo the sorting later. sortorder &lt;- do.call(order, df) df &lt;- df[sortorder,] # Find duplicates within each id group (first copy not marked) dupWithin &lt;- duplicated(df) # With duplicates within each group filtered out, find duplicates between groups. # Need to scan up and down with duplicated() because first copy is not marked. dupBetween = rep(NA, nrow(df)) dupBetween[!dupWithin] &lt;- duplicated(df[!dupWithin,datacols]) dupBetween[!dupWithin] &lt;- duplicated(df[!dupWithin,datacols], fromLast=TRUE) | dupBetween[!dupWithin] # ============= Replace NA&#39;s with previous non-NA value ============== # This is why we sorted earlier - it was necessary to do this part efficiently # Get indexes of non-NA&#39;s goodIdx &lt;- !is.na(dupBetween) # These are the non-NA values from x only # Add a leading NA for later use when we index into this vector goodVals &lt;- c(NA, dupBetween[goodIdx]) # Fill the indices of the output vector with the indices pulled from # these offsets of goodVals. Add 1 to avoid indexing to zero. fillIdx &lt;- cumsum(goodIdx)+1 # The original vector, now with gaps filled dupBetween &lt;- goodVals[fillIdx] # Undo the original sort dupBetween[sortorder] &lt;- dupBetween # Return the vector of which entries are duplicated across groups return(dupBetween) } 6.15.2.3 注意 想要寻找单个数据框中的重复行，参看../Finding and removing duplicate records。 6.16 重计算数据框所有因子列的水平 6.16.1 问题 你想要重新计算一个数据框中所有因子列（变量）的因子水平。 6.16.2 方案 有时候在读入和清理数据之后，你会发现数据（数据框）结果中有的因子列有一些不存在的因子水平。 例如，下面的d有一个空行。当它被读入时，因子列会出现“”水平，它不应该是数据的一部分。 d &lt;- read.csv(header = TRUE, text=&#39; x,y,value a,one,1 ,,5 b,two,4 c,three,10 &#39;) d #&gt; x y value #&gt; 1 a one 1 #&gt; 2 5 #&gt; 3 b two 4 #&gt; 4 c three 10 str(d) #&gt; &#39;data.frame&#39;: 4 obs. of 3 variables: #&gt; $ x : Factor w/ 4 levels &quot;&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 2 1 3 4 #&gt; $ y : Factor w/ 4 levels &quot;&quot;,&quot;one&quot;,&quot;three&quot;,..: 2 1 4 3 #&gt; $ value: int 1 5 4 10 即便移除了空行，因子中仍有“”水平： # 移除第二行 d &lt;- d[-2,] d #&gt; x y value #&gt; 1 a one 1 #&gt; 3 b two 4 #&gt; 4 c three 10 str(d) #&gt; &#39;data.frame&#39;: 3 obs. of 3 variables: #&gt; $ x : Factor w/ 4 levels &quot;&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 2 3 4 #&gt; $ y : Factor w/ 4 levels &quot;&quot;,&quot;one&quot;,&quot;three&quot;,..: 2 4 3 #&gt; $ value: int 1 4 10 6.16.2.1 使用droplevels 最简单的方式是使用droplevels()函数： d1 &lt;- droplevels(d) str(d1) #&gt; &#39;data.frame&#39;: 3 obs. of 3 variables: #&gt; $ x : Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3 #&gt; $ y : Factor w/ 3 levels &quot;one&quot;,&quot;three&quot;,..: 1 3 2 #&gt; $ value: int 1 4 10 6.16.2.2 使用vapply 和 lapply 为了重新计算所有因子列的水平，我们使用以is.factor()为参数的vapply()函数去找出哪些列是因子，然后再利用以factor()函数为参数的lapply()操作将那些列重新计算因子水平。 # 找出哪些列是因子 factor_cols &lt;- vapply(d, is.factor, logical(1)) # 把factor()函数应用到那些列，并把结果赋回d d[factor_cols] &lt;- lapply(d[factor_cols], factor) str(d) #&gt; &#39;data.frame&#39;: 3 obs. of 3 variables: #&gt; $ x : Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3 #&gt; $ y : Factor w/ 3 levels &quot;one&quot;,&quot;three&quot;,..: 1 3 2 #&gt; $ value: int 1 4 10 6.16.3 另见 关于重计算一个因子变量水平的信息，参见 ../Re-computing_the_levels_of_factor. 6.17 长宽格式数据互换 6.17.1 问题 你想要把数据从宽格式转换为长格式。 R中许多函数希望输入的数据是长格式而不是宽格式。然而像SPSS软件经常使用宽格式数据。 6.17.2 方案 下面有两类方法： tidyr包的gather()和spread()函数。这是reshape2包的一个新接口。 reshape2包的melt()与dcast()函数。 这里不包含其他一些实现的方法，因为这些方法不是很好使用： reshape()函数，它比较让人迷惑，因为它是R的基础包的一部分，而不是reshape2包的一部分。 stack() 和 unstack() 6.17.2.1 样例数据 这里使用的数据框包含同样数据的长、宽格式。它们接下来会被相互转换。 olddata_wide &lt;- read.table(header=TRUE, text=&#39; subject sex control cond1 cond2 1 M 7.9 12.3 10.7 2 F 6.3 10.6 11.1 3 F 9.5 13.1 13.8 4 M 11.5 13.4 12.9 &#39;) # 确保subject列是一个因子 olddata_wide$subject &lt;- factor(olddata_wide$subject) olddata_long &lt;- read.table(header=TRUE, text=&#39; subject sex condition measurement 1 M control 7.9 1 M cond1 12.3 1 M cond2 10.7 2 F control 6.3 2 F cond1 10.6 2 F cond2 11.1 3 F control 9.5 3 F cond1 13.1 3 F cond2 13.8 4 M control 11.5 4 M cond1 13.4 4 M cond2 12.9 &#39;) # 确保subject列是一个因子 olddata_long$subject &lt;- factor(olddata_long$subject) 6.17.2.2 tidyr 6.17.2.2.1 从宽格式到长格式 使用 gather: olddata_wide #&gt; subject sex control cond1 cond2 #&gt; 1 1 M 7.9 12.3 10.7 #&gt; 2 2 F 6.3 10.6 11.1 #&gt; 3 3 F 9.5 13.1 13.8 #&gt; 4 4 M 11.5 13.4 12.9 library(tidyr) # The arguments to gather(): # - data: Data object # - key: Name of new key column (made from names of data columns) # - value: Name of new value column # - ...: Names of source columns that contain values # - factor_key: Treat the new key column as a factor (instead of character vector) data_long &lt;- gather(olddata_wide, condition, measurement, control:cond2, factor_key=TRUE) data_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 2 2 F control 6.3 #&gt; 3 3 F control 9.5 #&gt; 4 4 M control 11.5 #&gt; 5 1 M cond1 12.3 #&gt; 6 2 F cond1 10.6 #&gt; 7 3 F cond1 13.1 #&gt; 8 4 M cond1 13.4 #&gt; 9 1 M cond2 10.7 #&gt; 10 2 F cond2 11.1 #&gt; 11 3 F cond2 13.8 #&gt; 12 4 M cond2 12.9 在这个例子中，来源列通过control:cond2指定聚集到一起。这里的意思是使用位置上在control和conda2之间（包括control与conda2）的所有列。另一种使用的方式是单独为每一列命名，如下： gather(olddata_wide, condition, measurement, control, cond1, cond2) 如果你需要编程化使用gather()函数，可能需要使用包含列名的变量。想要实现它的话，你需要使用gather_()函数，它会使用字符串而不是没加引号的列名。 keycol &lt;- &quot;condition&quot; valuecol &lt;- &quot;measurement&quot; gathercols &lt;- c(&quot;control&quot;, &quot;cond1&quot;, &quot;cond2&quot;) gather_(olddata_wide, keycol, valuecol, gathercols) 备择：重命名变量列的因子水平，并排序。 # 重命名因子水平 levels(data_long$condition)[levels(data_long$condition)==&quot;cond1&quot;] &lt;- &quot;first&quot; levels(data_long$condition)[levels(data_long$condition)==&quot;cond2&quot;] &lt;- &quot;second&quot; # 首先按照subject排序，然后按condition data_long &lt;- data_long[order(data_long$subject, data_long$condition), ] data_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 5 1 M first 12.3 #&gt; 9 1 M second 10.7 #&gt; 2 2 F control 6.3 #&gt; 6 2 F first 10.6 #&gt; 10 2 F second 11.1 #&gt; 3 3 F control 9.5 #&gt; 7 3 F first 13.1 #&gt; 11 3 F second 13.8 #&gt; 4 4 M control 11.5 #&gt; 8 4 M first 13.4 #&gt; 12 4 M second 12.9 6.17.2.2.2 从长格式到宽格式 使用 spread: olddata_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 2 1 M cond1 12.3 #&gt; 3 1 M cond2 10.7 #&gt; 4 2 F control 6.3 #&gt; 5 2 F cond1 10.6 #&gt; 6 2 F cond2 11.1 #&gt; 7 3 F control 9.5 #&gt; 8 3 F cond1 13.1 #&gt; 9 3 F cond2 13.8 #&gt; 10 4 M control 11.5 #&gt; 11 4 M cond1 13.4 #&gt; 12 4 M cond2 12.9 library(tidyr) # The arguments to spread(): # - data: Data object # - key: Name of column containing the new column names # - value: Name of column containing values data_wide &lt;- spread(olddata_long, condition, measurement) data_wide #&gt; subject sex cond1 cond2 control #&gt; 1 1 M 12.3 10.7 7.9 #&gt; 2 2 F 10.6 11.1 6.3 #&gt; 3 3 F 13.1 13.8 9.5 #&gt; 4 4 M 13.4 12.9 11.5 备择：一些可以使数据看起来更nice的操作。 # 重命名 names(data_wide)[names(data_wide)==&quot;cond1&quot;] &lt;- &quot;first&quot; names(data_wide)[names(data_wide)==&quot;cond2&quot;] &lt;- &quot;second&quot; # 排序 data_wide &lt;- data_wide[, c(1,2,5,3,4)] data_wide #&gt; subject sex control first second #&gt; 1 1 M 7.9 12.3 10.7 #&gt; 2 2 F 6.3 10.6 11.1 #&gt; 3 3 F 9.5 13.1 13.8 #&gt; 4 4 M 11.5 13.4 12.9 因子水平的顺序决定了列的顺序。水平次序能够在重塑之前被改变（changed），或者列也可以在之后重新排序（re-ordered）。 6.17.2.3 reshape2 6.17.2.3.1 从宽格式到长格式 使用 melt: olddata_wide #&gt; subject sex control cond1 cond2 #&gt; 1 1 M 7.9 12.3 10.7 #&gt; 2 2 F 6.3 10.6 11.1 #&gt; 3 3 F 9.5 13.1 13.8 #&gt; 4 4 M 11.5 13.4 12.9 library(reshape2) # 指定id.vars：需要保持的变量名 melt(olddata_wide, id.vars=c(&quot;subject&quot;, &quot;sex&quot;)) #&gt; subject sex variable value #&gt; 1 1 M control 7.9 #&gt; 2 2 F control 6.3 #&gt; 3 3 F control 9.5 #&gt; 4 4 M control 11.5 #&gt; 5 1 M cond1 12.3 #&gt; 6 2 F cond1 10.6 #&gt; 7 3 F cond1 13.1 #&gt; 8 4 M cond1 13.4 #&gt; 9 1 M cond2 10.7 #&gt; 10 2 F cond2 11.1 #&gt; 11 3 F cond2 13.8 #&gt; 12 4 M cond2 12.9 melt的一些选项可以使得输出更好处理： data_long &lt;- melt(olddata_wide, # 变量ID，需要保持的变量名 id.vars=c(&quot;subject&quot;, &quot;sex&quot;), # 来源列（被转换的） measure.vars=c(&quot;control&quot;, &quot;cond1&quot;, &quot;cond2&quot; ), # 目的列的名字可以确定测量列数值的来自的原始列（变量） # 这里measurement是数值，condition指定了其来源 variable.name=&quot;condition&quot;, value.name=&quot;measurement&quot; ) data_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 2 2 F control 6.3 #&gt; 3 3 F control 9.5 #&gt; 4 4 M control 11.5 #&gt; 5 1 M cond1 12.3 #&gt; 6 2 F cond1 10.6 #&gt; 7 3 F cond1 13.1 #&gt; 8 4 M cond1 13.4 #&gt; 9 1 M cond2 10.7 #&gt; 10 2 F cond2 11.1 #&gt; 11 3 F cond2 13.8 #&gt; 12 4 M cond2 12.9 如果你不设定measure.vars，melt函数会自动使用除id.vars的所有其他变量。反之亦然。 如果你不指定variable.name，它会把那列命名为&quot;variable&quot;，如果你不使用value.name变量，它会将它命名为&quot;measurement&quot;。 备择：重命名变量列的因子水平。 # 重命名因子名 levels(data_long$condition)[levels(data_long$condition)==&quot;cond1&quot;] &lt;- &quot;first&quot; levels(data_long$condition)[levels(data_long$condition)==&quot;cond2&quot;] &lt;- &quot;second&quot; # 首先按subject排序，然后按condition排序 data_long &lt;- data_long[ order(data_long$subject, data_long$condition), ] data_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 5 1 M first 12.3 #&gt; 9 1 M second 10.7 #&gt; 2 2 F control 6.3 #&gt; 6 2 F first 10.6 #&gt; 10 2 F second 11.1 #&gt; 3 3 F control 9.5 #&gt; 7 3 F first 13.1 #&gt; 11 3 F second 13.8 #&gt; 4 4 M control 11.5 #&gt; 8 4 M first 13.4 #&gt; 12 4 M second 12.9 6.17.2.3.2 从长格式到宽格式 下面代码使用dcast函数重塑数据。这个函数用于数据框，如果你处理数组或矩阵，替换使用acast。 olddata_long #&gt; subject sex condition measurement #&gt; 1 1 M control 7.9 #&gt; 2 1 M cond1 12.3 #&gt; 3 1 M cond2 10.7 #&gt; 4 2 F control 6.3 #&gt; 5 2 F cond1 10.6 #&gt; 6 2 F cond2 11.1 #&gt; 7 3 F control 9.5 #&gt; 8 3 F cond1 13.1 #&gt; 9 3 F cond2 13.8 #&gt; 10 4 M control 11.5 #&gt; 11 4 M cond1 13.4 #&gt; 12 4 M cond2 12.9 # From the source: # &quot;subject&quot; and &quot;sex&quot; are columns we want to keep the same # &quot;condition&quot; is the column that contains the names of the new column to put things in # &quot;measurement&quot; holds the measurements # &quot;subject&quot; 和 &quot;sex&quot; 是我们想要保留的列 # &quot;condition&quot;是我们想要放入新列名的列 # &quot;measurement&quot;包含数值 library(reshape2) data_wide &lt;- dcast(olddata_long, subject + sex ~ condition, value.var=&quot;measurement&quot;) data_wide #&gt; subject sex cond1 cond2 control #&gt; 1 1 M 12.3 10.7 7.9 #&gt; 2 2 F 10.6 11.1 6.3 #&gt; 3 3 F 13.1 13.8 9.5 #&gt; 4 4 M 13.4 12.9 11.5 备择：一些可以使数据看起来更nice的操作。 # 重命名 names(data_wide)[names(data_wide)==&quot;cond1&quot;] &lt;- &quot;first&quot; names(data_wide)[names(data_wide)==&quot;cond2&quot;] &lt;- &quot;second&quot; # 重排序 data_wide &lt;- data_wide[, c(1,2,5,3,4)] data_wide #&gt; subject sex control first second #&gt; 1 1 M 7.9 12.3 10.7 #&gt; 2 2 F 6.3 10.6 11.1 #&gt; 3 3 F 9.5 13.1 13.8 #&gt; 4 4 M 11.5 13.4 12.9 因子水平的顺序决定了列的顺序。水平次序能够在重塑之前被改变（changed），或者列也可以在之后重新排序（re-ordered）。 6.18 归纳总结数据 6.18.1 问题 你想要按照组别总结你的数据（均值、标准差等等）。 6.18.2 方案 有三种方法描述基于一些特定变量的分组数据，然后对每一组使用总结函数（像均值、标准差等等）。 ddply()函数：它比较容易使用，但需要载入plyr包。这种方法可能就是你要找的（说明很多人用呗，好用呗）。 summaryBy()函数：它也比较容易使用，然而它需要载入doBy包。 aggregate()函数，它比较难使用一点但内置于R中。 假设你有以下数据并想求得每一组样本大小、均值的改变、标准差以及均值的标准误，而这里的组别是根据性别和条件指定的：F-placebo, F-aspirin, M-placebo和 M-aspirin。 data &lt;- read.table(header=TRUE, text=&#39; subject sex condition before after change 1 F placebo 10.1 6.9 -3.2 2 F placebo 6.3 4.2 -2.1 3 M aspirin 12.4 6.3 -6.1 4 F placebo 8.1 6.1 -2.0 5 M aspirin 15.2 9.9 -5.3 6 F aspirin 10.9 7.0 -3.9 7 F aspirin 11.6 8.5 -3.1 8 M aspirin 9.5 3.0 -6.5 9 F placebo 11.5 9.0 -2.5 10 M placebo 11.9 11.0 -0.9 11 F aspirin 11.4 8.0 -3.4 12 M aspirin 10.0 4.4 -5.6 13 M aspirin 12.5 5.4 -7.1 14 M placebo 10.6 10.6 0.0 15 M aspirin 9.1 4.3 -4.8 16 F placebo 12.1 10.2 -1.9 17 F placebo 11.0 8.8 -2.2 18 F placebo 11.9 10.2 -1.7 19 M aspirin 9.1 3.6 -5.5 20 M placebo 13.5 12.4 -1.1 21 M aspirin 12.0 7.5 -4.5 22 F placebo 9.1 7.6 -1.5 23 M placebo 9.9 8.0 -1.9 24 F placebo 7.6 5.2 -2.4 25 F placebo 11.8 9.7 -2.1 26 F placebo 11.8 10.7 -1.1 27 F aspirin 10.1 7.9 -2.2 28 M aspirin 11.6 8.3 -3.3 29 F aspirin 11.3 6.8 -4.5 30 F placebo 10.3 8.3 -2.0 &#39;) 6.18.2.1 使用 ddply library(plyr) # 给每一组运行长度、均值、标准差等函数 # 每一组依据性别+条件划分 cdata &lt;- ddply(data, c(&quot;sex&quot;, &quot;condition&quot;), summarise, N = length(change), mean = mean(change), sd = sd(change), se = sd / sqrt(N) ) cdata #&gt; sex condition N mean sd se #&gt; 1 F aspirin 5 -3.420000 0.8642916 0.3865230 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 #&gt; 3 M aspirin 9 -5.411111 1.1307569 0.3769190 #&gt; 4 M placebo 4 -0.975000 0.7804913 0.3902456 6.18.2.1.1 处理缺失值 如果数据中存在NA值，需要给每个函数添加na.rm=TRUE标记去除缺失值。因为函数length()没有na.rm选项，所以可以使用sum(!is.na(...))的方式对非缺失值进行计数。 # 给数据加些NA值 dataNA &lt;- data dataNA$change[11:14] &lt;- NA cdata &lt;- ddply(dataNA, c(&quot;sex&quot;, &quot;condition&quot;), summarise, N = sum(!is.na(change)), mean = mean(change, na.rm=TRUE), sd = sd(change, na.rm=TRUE), se = sd / sqrt(N) ) cdata #&gt; sex condition N mean sd se #&gt; 1 F aspirin 4 -3.425000 0.9979145 0.4989572 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 #&gt; 3 M aspirin 7 -5.142857 1.0674848 0.4034713 #&gt; 4 M placebo 3 -1.300000 0.5291503 0.3055050 6.18.2.1.2 自动总结函数 不像我们刚才手动地指定想要的值然后计算标准误，这个函数可以自动处理所有的细节。它可以干以下的事情： 寻找均值、标准差和计数 寻找均值的标准误（强调，如果你处理的是被试内变量这可能不是你想要的，，参见../../Graphs/Plotting means and error bars (ggplot2)获取怎么绘制组内变量的误差棒信息。关于被试设计问题，可以点击详细了解） 寻找95%的置信区间（也可以指定其他值） 重命令结果数据集的变量名，这样更方便后续处理 要使用的话，把函数放你的代码中然后像下面一样调用它。 ## Summarizes data. ## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%). ## data: a data frame. ## measurevar: the name of a column that contains the variable to be summariezed ## groupvars: a vector containing names of columns that contain grouping variables ## na.rm: a boolean that indicates whether to ignore NA&#39;s ## conf.interval: the percent range of the confidence interval (default is 95%) summarySE &lt;- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE) { library(plyr) # New version of length which can handle NA&#39;s: if na.rm==T, don&#39;t count them length2 &lt;- function (x, na.rm=FALSE) { if (na.rm) sum(!is.na(x)) else length(x) } # This does the summary. For each group&#39;s data frame, return a vector with # N, mean, and sd datac &lt;- ddply(data, groupvars, .drop=.drop, .fun = function(xx, col) { c(N = length2(xx[[col]], na.rm=na.rm), mean = mean (xx[[col]], na.rm=na.rm), sd = sd (xx[[col]], na.rm=na.rm) ) }, measurevar ) # Rename the &quot;mean&quot; column datac &lt;- rename(datac, c(&quot;mean&quot; = measurevar)) datac$se &lt;- datac$sd / sqrt(datac$N) # Calculate standard error of the mean # Confidence interval multiplier for standard error # Calculate t-statistic for confidence interval: # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1 ciMult &lt;- qt(conf.interval/2 + .5, datac$N-1) datac$ci &lt;- datac$se * ciMult return(datac) } 举个例子使用它（用95%的置信区间）。与之前手动计算这些步骤相反，summarySE函数一步搞定： summarySE(data, measurevar=&quot;change&quot;, groupvars=c(&quot;sex&quot;, &quot;condition&quot;)) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420000 0.8642916 0.3865230 1.0731598 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 0.3334201 #&gt; 3 M aspirin 9 -5.411111 1.1307569 0.3769190 0.8691767 #&gt; 4 M placebo 4 -0.975000 0.7804913 0.3902456 1.2419358 # With a data set with NA&#39;s, use na.rm=TRUE summarySE(dataNA, measurevar=&quot;change&quot;, groupvars=c(&quot;sex&quot;, &quot;condition&quot;), na.rm=TRUE) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 4 -3.425000 0.9979145 0.4989572 1.5879046 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 0.3334201 #&gt; 3 M aspirin 7 -5.142857 1.0674848 0.4034713 0.9872588 #&gt; 4 M placebo 3 -1.300000 0.5291503 0.3055050 1.3144821 6.18.2.1.3 用零填满空组合 有时候总结的数据框中存在因子的空组合 - 这意思是，因子组合可能存在，但原始数据框里又没有实际出现。它在自动填满有NA值的数据框时有用。要做到这一点，当调用ddply或summarySE时设置.drop=FALSE。（这里我翻译的不是很如意，大家可以查看原文） 例子： # 首先移除所有 Male+Placebo 条目 dataSub &lt;- subset(data, !(sex==&quot;M&quot; &amp; condition==&quot;placebo&quot;)) # 如果我们总结数据，在本来有 Male+Placebo 的地方会存在空行 # 因为这个组合已经被我们删除了 summarySE(dataSub, measurevar=&quot;change&quot;, groupvars=c(&quot;sex&quot;, &quot;condition&quot;)) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420000 0.8642916 0.3865230 1.0731598 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 0.3334201 #&gt; 3 M aspirin 9 -5.411111 1.1307569 0.3769190 0.8691767 # 设置 .drop=FALSE 指定不要扔掉这个组合 summarySE(dataSub, measurevar=&quot;change&quot;, groupvars=c(&quot;sex&quot;, &quot;condition&quot;), .drop=FALSE) #&gt; Warning in qt(conf.interval/2 + 0.5, datac$N - 1): NaNs produced #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420000 0.8642916 0.3865230 1.0731598 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 0.3334201 #&gt; 3 M aspirin 9 -5.411111 1.1307569 0.3769190 0.8691767 #&gt; 4 M placebo 0 NaN NA NA NA 6.18.2.2 使用summaryBy 使用summarizeBy()函数瓦解数据： library(doBy) # 给每一组运行长度、均值、标准差等函数 # 每一组依据性别+条件划分 cdata &lt;- summaryBy(change ~ sex + condition, data=data, FUN=c(length,mean,sd)) cdata #&gt; sex condition change.length change.mean change.sd #&gt; 1 F aspirin 5 -3.420000 0.8642916 #&gt; 2 F placebo 12 -2.058333 0.5247655 #&gt; 3 M aspirin 9 -5.411111 1.1307569 #&gt; 4 M placebo 4 -0.975000 0.7804913 # Rename column change.length to just N names(cdata)[names(cdata)==&quot;change.length&quot;] &lt;- &quot;N&quot; # Calculate standard error of the mean cdata$change.se &lt;- cdata$change.sd / sqrt(cdata$N) cdata #&gt; sex condition N change.mean change.sd change.se #&gt; 1 F aspirin 5 -3.420000 0.8642916 0.3865230 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 #&gt; 3 M aspirin 9 -5.411111 1.1307569 0.3769190 #&gt; 4 M placebo 4 -0.975000 0.7804913 0.3902456 注意如果你有任何被试内变量，这些标准误值在比对组别差异时就没用了。参见 ../../Graphs/Plotting means and error bars (ggplot2) 获取如何绘制被试内变量的误差棒。 6.18.2.2.1 处理缺失值 如果数据中存在NA值，你需要添加na.rm=TRUE选项。通常你可以在summaryBy()函数中设置，但length()函数识别不了这个选项。一种解决方式是根据length()函数定义一个新的取长度函数去处理NA值。 # 新版的length函数可以处理NA值，如果na.rm=T,则不对NA计数 length2 &lt;- function (x, na.rm=FALSE) { if (na.rm) sum(!is.na(x)) else length(x) } # 给数据添加一些NA值 dataNA &lt;- data dataNA$change[11:14] &lt;- NA cdataNA &lt;- summaryBy(change ~ sex + condition, data=dataNA, FUN=c(length2, mean, sd), na.rm=TRUE) cdataNA #&gt; sex condition change.length2 change.mean change.sd #&gt; 1 F aspirin 4 -3.425000 0.9979145 #&gt; 2 F placebo 12 -2.058333 0.5247655 #&gt; 3 M aspirin 7 -5.142857 1.0674848 #&gt; 4 M placebo 3 -1.300000 0.5291503 # Now, do the same as before 6.18.2.2.2 自动总结函数 （注意这里的自动总结函数与之前的不同，它是通过summaryBy实现的） 不像我们刚才手动地指定想要的值然后计算标准误，这个函数可以自动处理所有的细节。它可以干以下的事情： 寻找均值、标准差和计数 寻找均值的标准误（强调，如果你处理的是被试内变量这可能不是你想要的，，参见../../Graphs/Plotting means and error bars (ggplot2)获取怎么绘制组内变量的误差棒信息。关于被试设计问题，可以点击详细了解） 寻找95%的置信区间（也可以指定其他值） 重命令结果数据集的变量名，这样更方便后续处理 要使用的话，把函数放你的代码中然后像下面一样调用它。 ## Summarizes data. ## Gives count, mean, standard deviation, standard error of the mean, and confidence ## interval (default 95%). ## data: a data frame. ## measurevar: the name of a column that contains the variable to be summariezed ## groupvars: a vector containing names of columns that contain grouping variables ## na.rm: a boolean that indicates whether to ignore NA&#39;s ## conf.interval: the percent range of the confidence interval (default is 95%) summarySE &lt;- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE, conf.interval=.95) { library(doBy) # New version of length which can handle NA&#39;s: if na.rm==T, don&#39;t count them length2 &lt;- function (x, na.rm=FALSE) { if (na.rm) sum(!is.na(x)) else length(x) } # Collapse the data formula &lt;- as.formula(paste(measurevar, paste(groupvars, collapse=&quot; + &quot;), sep=&quot; ~ &quot;)) datac &lt;- summaryBy(formula, data=data, FUN=c(length2,mean,sd), na.rm=na.rm) # Rename columns names(datac)[ names(datac) == paste(measurevar, &quot;.mean&quot;, sep=&quot;&quot;) ] &lt;- measurevar names(datac)[ names(datac) == paste(measurevar, &quot;.sd&quot;, sep=&quot;&quot;) ] &lt;- &quot;sd&quot; names(datac)[ names(datac) == paste(measurevar, &quot;.length2&quot;, sep=&quot;&quot;) ] &lt;- &quot;N&quot; datac$se &lt;- datac$sd / sqrt(datac$N) # Calculate standard error of the mean # Confidence interval multiplier for standard error # Calculate t-statistic for confidence interval: # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1 ciMult &lt;- qt(conf.interval/2 + .5, datac$N-1) datac$ci &lt;- datac$se * ciMult return(datac) } 举个例子使用它（用95%的置信区间）。与之前手动计算这些步骤相反，summarySE函数一步搞定： summarySE(data, measurevar=&quot;change&quot;, groupvars=c(&quot;sex&quot;,&quot;condition&quot;)) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420000 0.8642916 0.3865230 1.0731598 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 0.3334201 #&gt; 3 M aspirin 9 -5.411111 1.1307569 0.3769190 0.8691767 #&gt; 4 M placebo 4 -0.975000 0.7804913 0.3902456 1.2419358 # With a data set with NA&#39;s, use na.rm=TRUE summarySE(dataNA, measurevar=&quot;change&quot;, groupvars=c(&quot;sex&quot;,&quot;condition&quot;), na.rm=TRUE) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 4 -3.425000 0.9979145 0.4989572 1.5879046 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 0.3334201 #&gt; 3 M aspirin 7 -5.142857 1.0674848 0.4034713 0.9872588 #&gt; 4 M placebo 3 -1.300000 0.5291503 0.3055050 1.3144821 6.18.2.2.3 用零填满空组合 有时候总结的数据框中存在因子的空组合 - 这意思是，因子组合可能存在，但原始数据框里又没有实际出现。它在自动填满有NA值的数据框时有用。 这个例子将会用0填满缺失的组合： fillMissingCombs &lt;- function(df, factors, measures) { # Make a list of the combinations of factor levels levelList &lt;- list() for (f in factors) { levelList[[f]] &lt;- levels(df[,f]) } fullFactors &lt;- expand.grid(levelList) dfFull &lt;- merge(fullFactors, df, all.x=TRUE) # Wherever there is an NA in the measure vars, replace with 0 for (m in measures) { dfFull[is.na(dfFull[,m]), m] &lt;- 0 } return(dfFull) } 使用例子： # First remove some all Male+Placebo entries from the data dataSub &lt;- subset(data, !(sex==&quot;M&quot; &amp; condition==&quot;placebo&quot;)) # If we summarize the data, there will be a missing row for Male+Placebo, # since there were no cases with this combination. cdataSub &lt;- summarySE(dataSub, measurevar=&quot;change&quot;, groupvars=c(&quot;sex&quot;, &quot;condition&quot;)) cdataSub #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420000 0.8642916 0.3865230 1.0731598 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 0.3334201 #&gt; 3 M aspirin 9 -5.411111 1.1307569 0.3769190 0.8691767 # This will fill in the missing combinations with zeros fillMissingCombs(cdataSub, factors=c(&quot;sex&quot;,&quot;condition&quot;), measures=c(&quot;N&quot;,&quot;change&quot;,&quot;sd&quot;,&quot;se&quot;,&quot;ci&quot;)) #&gt; sex condition N change sd se ci #&gt; 1 F aspirin 5 -3.420000 0.8642916 0.3865230 1.0731598 #&gt; 2 F placebo 12 -2.058333 0.5247655 0.1514867 0.3334201 #&gt; 3 M aspirin 9 -5.411111 1.1307569 0.3769190 0.8691767 #&gt; 4 M placebo 0 0.000000 0.0000000 0.0000000 0.0000000 6.18.2.3 使用 aggregate aggregate函数比较难用，但它内置于R，所以不需要按照其他包。 # 对每个目录 (sex*condition) 中的对象计数 cdata &lt;- aggregate(data[&quot;subject&quot;], by=data[c(&quot;sex&quot;,&quot;condition&quot;)], FUN=length) cdata #&gt; sex condition subject #&gt; 1 F aspirin 5 #&gt; 2 M aspirin 9 #&gt; 3 F placebo 12 #&gt; 4 M placebo 4 # 重命名 &quot;subject&quot; 列为 &quot;N&quot; names(cdata)[names(cdata)==&quot;subject&quot;] &lt;- &quot;N&quot; cdata #&gt; sex condition N #&gt; 1 F aspirin 5 #&gt; 2 M aspirin 9 #&gt; 3 F placebo 12 #&gt; 4 M placebo 4 # 按性别排序 cdata &lt;- cdata[order(cdata$sex),] cdata #&gt; sex condition N #&gt; 1 F aspirin 5 #&gt; 3 F placebo 12 #&gt; 2 M aspirin 9 #&gt; 4 M placebo 4 # 我们也保留 before 和 after列： # 得到性别和条件下的平均影响大小 # Get the average effect size by sex and condition cdata.means &lt;- aggregate(data[c(&quot;before&quot;,&quot;after&quot;,&quot;change&quot;)], by = data[c(&quot;sex&quot;,&quot;condition&quot;)], FUN=mean) cdata.means #&gt; sex condition before after change #&gt; 1 F aspirin 11.06000 7.640000 -3.420000 #&gt; 2 M aspirin 11.26667 5.855556 -5.411111 #&gt; 3 F placebo 10.13333 8.075000 -2.058333 #&gt; 4 M placebo 11.47500 10.500000 -0.975000 # 融合数据框 cdata &lt;- merge(cdata, cdata.means) cdata #&gt; sex condition N before after change #&gt; 1 F aspirin 5 11.06000 7.640000 -3.420000 #&gt; 2 F placebo 12 10.13333 8.075000 -2.058333 #&gt; 3 M aspirin 9 11.26667 5.855556 -5.411111 #&gt; 4 M placebo 4 11.47500 10.500000 -0.975000 # 得到标准差 cdata.sd &lt;- aggregate(data[&quot;change&quot;], by = data[c(&quot;sex&quot;,&quot;condition&quot;)], FUN=sd) # 重命名列 names(cdata.sd)[names(cdata.sd)==&quot;change&quot;] &lt;- &quot;change.sd&quot; cdata.sd #&gt; sex condition change.sd #&gt; 1 F aspirin 0.8642916 #&gt; 2 M aspirin 1.1307569 #&gt; 3 F placebo 0.5247655 #&gt; 4 M placebo 0.7804913 # 融合 cdata &lt;- merge(cdata, cdata.sd) cdata #&gt; sex condition N before after change change.sd #&gt; 1 F aspirin 5 11.06000 7.640000 -3.420000 0.8642916 #&gt; 2 F placebo 12 10.13333 8.075000 -2.058333 0.5247655 #&gt; 3 M aspirin 9 11.26667 5.855556 -5.411111 1.1307569 #&gt; 4 M placebo 4 11.47500 10.500000 -0.975000 0.7804913 # 计算标准误 cdata$change.se &lt;- cdata$change.sd / sqrt(cdata$N) cdata #&gt; sex condition N before after change change.sd change.se #&gt; 1 F aspirin 5 11.06000 7.640000 -3.420000 0.8642916 0.3865230 #&gt; 2 F placebo 12 10.13333 8.075000 -2.058333 0.5247655 0.1514867 #&gt; 3 M aspirin 9 11.26667 5.855556 -5.411111 1.1307569 0.3769190 #&gt; 4 M placebo 4 11.47500 10.500000 -0.975000 0.7804913 0.3902456 如果你有NA值想要跳过，设置 na.rm=TRUE: cdata.means &lt;- aggregate(data[c(&quot;before&quot;,&quot;after&quot;,&quot;change&quot;)], by = data[c(&quot;sex&quot;,&quot;condition&quot;)], FUN=mean, na.rm=TRUE) cdata.means #&gt; sex condition before after change #&gt; 1 F aspirin 11.06000 7.640000 -3.420000 #&gt; 2 M aspirin 11.26667 5.855556 -5.411111 #&gt; 3 F placebo 10.13333 8.075000 -2.058333 #&gt; 4 M placebo 11.47500 10.500000 -0.975000 6.19 数据框与列联表互换 6.19.1 问题 你想要在多种情况的一个数据框、每种情况类型计数的数据框以及一个列联表之间转换。 6.19.2 方案 这里有3种数据结构代表相同的信息，但是是以不同的形式： cases: 每一行代表一个情况的数据框 ctable: 一个列联表 counts: 计数的数据框，每行代表每一种组合的数目 # 每一行代表一种情况 cases &lt;- data.frame( Sex=c(&quot;M&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;), Color=c(&quot;brown&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;brown&quot;, &quot;brown&quot;) ) cases #&gt; Sex Color #&gt; 1 M brown #&gt; 2 M blue #&gt; 3 F brown #&gt; 4 F brown #&gt; 5 F brown # 一个列联表 ctable &lt;- table(cases) ctable #&gt; Color #&gt; Sex blue brown #&gt; F 0 3 #&gt; M 1 1 # 一个每种组合计数的表格 counts &lt;- data.frame( Sex=c(&quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;), Color=c(&quot;blue&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;brown&quot;), Freq=c(0, 1, 3, 1) ) counts #&gt; Sex Color Freq #&gt; 1 F blue 0 #&gt; 2 M blue 1 #&gt; 3 F brown 3 #&gt; 4 M brown 1 6.19.2.1 将情况记录转为列联表 将情况记录转为列联表（上面已经展示了）： # Cases to Table ctable &lt;- table(cases) ctable #&gt; Color #&gt; Sex blue brown #&gt; F 0 3 #&gt; M 1 1 # 如果你使用两个向量调用table函数，它将不会给维度添加名字（Sex和Color） table(cases$Sex, cases$Color) #&gt; #&gt; blue brown #&gt; F 0 3 #&gt; M 1 1 # 维度名可以通过`dnn`选项手动指定 table(cases$Sex, cases$Color, dnn=c(&quot;Sex&quot;,&quot;Color&quot;)) #&gt; Color #&gt; Sex blue brown #&gt; F 0 3 #&gt; M 1 1 6.19.2.2 将情况记录转为计数 它可以用一个数据框代表每一种组合的计数。注意它被转换并存储在countdf变量中： # Cases to Counts countdf &lt;- as.data.frame(table(cases)) countdf #&gt; Sex Color Freq #&gt; 1 F blue 0 #&gt; 2 M blue 1 #&gt; 3 F brown 3 #&gt; 4 M brown 1 6.19.2.3 列联表转为情况记录 countsToCases(as.data.frame(ctable)) #&gt; Sex Color #&gt; 2 M blue #&gt; 3 F brown #&gt; 3.1 F brown #&gt; 3.2 F brown #&gt; 4 M brown 注意countsToCases函数定义在下面（文章最后）。 6.19.2.4 列联表转为计数 as.data.frame(ctable) #&gt; Sex Color Freq #&gt; 1 F blue 0 #&gt; 2 M blue 1 #&gt; 3 F brown 3 #&gt; 4 M brown 1 （从这里我们可以看到上一个代码的中间效果） 6.19.2.5 计数转为情况记录 countsToCases(countdf) #&gt; Sex Color #&gt; 2 M blue #&gt; 3 F brown #&gt; 3.1 F brown #&gt; 3.2 F brown #&gt; 4 M brown 这相当于是列联表转为情况记录的第二步。 6.19.2.6 计数转为列联表 xtabs(Freq ~ Sex+Color, data=countdf) #&gt; Color #&gt; Sex blue brown #&gt; F 0 3 #&gt; M 1 1 6.19.2.7 countsToCases() 函数 这个函数使用在上面的例子中： # Convert from data frame of counts to data frame of cases. # `countcol` is the name of the column containing the counts countsToCases &lt;- function(x, countcol = &quot;Freq&quot;) { # Get the row indices to pull from x idx &lt;- rep.int(seq_len(nrow(x)), x[[countcol]]) # Drop count column x[[countcol]] &lt;- NULL # Get the rows from x x[idx, ] } 6.20 计算移动平均数 6.20.1 问题 你想要计算移动平均数 6.20.2 解决方案 假设你的数据时带缺失值的噪声正弦波。 set.seed(993) x &lt;- 1:300 y &lt;- sin(x/20) + rnorm(300,sd=.1) y[251:255] &lt;- NA filter()函数可以用来计算移动平均数。 # 绘制未平滑的数据（灰色） plot(x, y, type=&quot;l&quot;, col=grey(.5)) # 绘制网格 grid() # 延迟平滑 # 当前样本和之前19个样本的平均数（红色） f20 &lt;- rep(1/20, 20) f20 #&gt; [1] 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 #&gt; [18] 0.05 0.05 0.05 y_lag &lt;- filter(y, f20, sides=1) lines(x, y_lag, col=&quot;red&quot;) # 对称性平滑： #计算当前样本，时间上将来样本和过去10个样本的平均数（蓝色） f21 &lt;- rep(1/21,21) f21 #&gt; [1] 0.04761905 0.04761905 0.04761905 0.04761905 0.04761905 0.04761905 0.04761905 #&gt; [8] 0.04761905 0.04761905 0.04761905 0.04761905 0.04761905 0.04761905 0.04761905 #&gt; [15] 0.04761905 0.04761905 0.04761905 0.04761905 0.04761905 0.04761905 0.04761905 y_sym &lt;- filter(y, f21, sides=2) lines(x, y_sym, col=&quot;blue&quot;) plot of chunk unnamed-chunk-2 filter()会在遭遇缺失值时留下空缺，就像上面图中显示的一样。 一种处理缺失值的方法是简单地忽略它，不把它包含在平均数的计算中。这个功能可以由下面的函数实现： # x: the vector # n: the number of samples # centered: if FALSE, then average current sample and previous (n-1) samples # if TRUE, then average symmetrically in past and future. (If n is even, use one more sample from future.) movingAverage &lt;- function(x, n=1, centered=FALSE) { if (centered) { before &lt;- floor ((n-1)/2) after &lt;- ceiling((n-1)/2) } else { before &lt;- n-1 after &lt;- 0 } # Track the sum and count of number of non-NA items s &lt;- rep(0, length(x)) count &lt;- rep(0, length(x)) # Add the centered data new &lt;- x # Add to count list wherever there isn&#39;t a count &lt;- count + !is.na(new) # Now replace NA_s with 0_s and add to total new[is.na(new)] &lt;- 0 s &lt;- s + new # Add the data from before i &lt;- 1 while (i &lt;= before) { # This is the vector with offset values to add new &lt;- c(rep(NA, i), x[1:(length(x)-i)]) count &lt;- count + !is.na(new) new[is.na(new)] &lt;- 0 s &lt;- s + new i &lt;- i+1 } # Add the data from after i &lt;- 1 while (i &lt;= after) { # This is the vector with offset values to add new &lt;- c(x[(i+1):length(x)], rep(NA, i)) count &lt;- count + !is.na(new) new[is.na(new)] &lt;- 0 s &lt;- s + new i &lt;- i+1 } # return sum divided by count s/count } # 用比较厚的线条绘制和之前一样的图 plot(x, y, type=&quot;l&quot;, col=grey(.5)) grid() y_lag &lt;- filter(y, rep(1/20, 20), sides=1) lines(x, y_lag, col=&quot;red&quot;, lwd=4) # 用红色表示延迟平均 y_sym &lt;- filter(y, rep(1/21,21), sides=2) lines(x, y_sym, col=&quot;blue&quot;, lwd=4) # 用蓝色表示对称平均 # 用上面定义的函数计算延迟平均 y_lag_na.rm &lt;- movingAverage(y, 20) lines(x, y_lag_na.rm, col=&quot;green&quot;, lwd=2) # 用上面定义的函数计算对称性平均 y_sym_na.rm &lt;- movingAverage(y, 21, TRUE) lines(x, y_sym_na.rm, col=&quot;green&quot;, lwd=2) plot of chunk unnamed-chunk-3 6.21 窗口平滑 6.21.1 问题 你想要计算序列给定窗口长度的平均数。这是平滑数据的一种方式。 6.21.2 方案 假设你有一个数值向量并且想要找出第一个连续四个数、第二个连续四个数等等如此的平均数。（就像用一个窗口在序列上移动，移动一次，计算一次） # 生成有22个（0-99）以内的随机数向量 set.seed(123) x &lt;- floor(runif(22)*100) x #&gt; [1] 28 78 40 88 94 4 52 89 55 45 95 45 67 57 10 89 24 4 32 95 88 69 # 将向量长度取整到最接近的4的倍数 newlength &lt;- ceiling(length(x)/4)*4 newlength #&gt; [1] 24 # 给新增的数值取NA值 x[newlength] &lt;- NA x #&gt; [1] 28 78 40 88 94 4 52 89 55 45 95 45 67 57 10 89 24 4 32 95 88 69 NA NA # 将它转换为4行的矩阵 x &lt;- matrix(x, nrow=4) x #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 28 94 55 67 24 88 #&gt; [2,] 78 4 45 57 4 69 #&gt; [3,] 40 52 95 10 32 NA #&gt; [4,] 88 89 45 89 95 NA # 计算每一列的均值，忽略NA值 colMeans(x, na.rm=TRUE) #&gt; [1] 58.50 59.75 60.00 55.75 38.75 78.50 6.22 寻找唯一值序列 6.22.1 问题 你需要找到一个向量或者因子的唯一值 6.22.2 方案 你可以通过在向量里迭代寻找唯一值，但这样做在R里是很慢的。一个比较快的方案是通过rle()函数： # 示例数据 v &lt;- c(&quot;A&quot;,&quot;A&quot;,&quot;A&quot;, &quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;, NA,NA, &quot;C&quot;,&quot;C&quot;, &quot;B&quot;, &quot;C&quot;,&quot;C&quot;,&quot;C&quot;) v #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; NA NA &quot;C&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; vr &lt;- rle(v) vr #&gt; Run Length Encoding #&gt; lengths: int [1:7] 3 4 1 1 2 1 3 #&gt; values : chr [1:7] &quot;A&quot; &quot;B&quot; NA NA &quot;C&quot; &quot;B&quot; &quot;C&quot; RLE编码的数据能够通过 inverse.rle()转换回到一个向量 inverse.rle(vr) #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; NA NA &quot;C&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; 一个问题是每一个缺失值NA都会视为长度为1，即使NA是相邻的。可以通过用别的值替代NA来做到。对于数值变量，Inf或者别的数字都可使用；对于字符变量，任何字符串都能使用。当然，否则特殊值不能出现在向量中。 w &lt;- v w[is.na(w)] &lt;- &quot;ZZZ&quot; w #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;ZZZ&quot; &quot;ZZZ&quot; &quot;C&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; #&gt; [15] &quot;C&quot; wr &lt;- rle(w) wr #&gt; Run Length Encoding #&gt; lengths: int [1:6] 3 4 2 2 1 3 #&gt; values : chr [1:6] &quot;A&quot; &quot;B&quot; &quot;ZZZ&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; # 在RLE编码数据中用NA代替ZZZ wr$values[ wr$values==&quot;ZZZ&quot; ] &lt;- NA wr #&gt; Run Length Encoding #&gt; lengths: int [1:6] 3 4 2 2 1 3 #&gt; values : chr [1:6] &quot;A&quot; &quot;B&quot; NA &quot;C&quot; &quot;B&quot; &quot;C&quot; w2 &lt;- inverse.rle(wr) w2 #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; NA NA &quot;C&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; 6.22.3 向量上运行 虽然因子基本上只是带有一些关于级别信息的整数向量，但是rle()函数不能处理因子。解决方案是手动将因子转换为整数向量或字符向量。使用整数向量速度快，内存效率高，这对于大型数据集可能很重要，但是很难解释。使用字符向量比较慢，需要更多的内存，但是更容易解释。 # 假设这是我们要处理的向量 f &lt;- factor(v) f #&gt; [1] A A A B B B B &lt;NA&gt; &lt;NA&gt; C C B C C C #&gt; Levels: A B C # 将向量级别保存到一个新的变量 # 这个不是必须的，但是保存顺序是很有用的 f_levels &lt;- levels(f) f_levels #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; fc &lt;- as.character(f) fc[ is.na(fc) ] &lt;- &quot;ZZZ&quot; fc #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;ZZZ&quot; &quot;ZZZ&quot; &quot;C&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; #&gt; [15] &quot;C&quot; fr &lt;- rle(fc) fr #&gt; Run Length Encoding #&gt; lengths: int [1:6] 3 4 2 2 1 3 #&gt; values : chr [1:6] &quot;A&quot; &quot;B&quot; &quot;ZZZ&quot; &quot;C&quot; &quot;B&quot; &quot;C&quot; # 在RLE编码数据中用NA代替ZZZ fr$values[ fr$values==&quot;ZZZ&quot; ] &lt;- NA fr #&gt; Run Length Encoding #&gt; lengths: int [1:6] 3 4 2 2 1 3 #&gt; values : chr [1:6] &quot;A&quot; &quot;B&quot; NA &quot;C&quot; &quot;B&quot; &quot;C&quot; # 将RLE编码数据转换成因子 f2 &lt;- inverse.rle(fr) f2 &lt;- factor(f, levels=f_levels) f2 #&gt; [1] A A A B B B B &lt;NA&gt; &lt;NA&gt; C C B C C C #&gt; Levels: A B C 6.23 用最后的非NA值填充NA值 6.23.1 问题 你想要将非NA值代替向量或者因子中的NA值 6.23.2 方案 这段代码展示了如何填充向量中的空白。如果需要重复执行此操作，请参阅下面的函数。该函数还可以用第一个确定的值填充领头NA，并正确处理因子。 # 示例数据 x &lt;- c(NA,NA, &quot;A&quot;,&quot;A&quot;, &quot;B&quot;,&quot;B&quot;,&quot;B&quot;, NA,NA, &quot;C&quot;, NA,NA,NA, &quot;A&quot;,&quot;A&quot;,&quot;B&quot;, NA,NA) goodIdx &lt;- !is.na(x) goodIdx #&gt; [1] FALSE FALSE TRUE TRUE TRUE TRUE TRUE FALSE FALSE TRUE FALSE FALSE FALSE TRUE #&gt; [15] TRUE TRUE FALSE FALSE # 这些是来自x的非NA数值 # 加入领头的NA，后边会使用。用来进行索引 goodVals &lt;- c(NA, x[goodIdx]) goodVals #&gt; [1] NA &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; # 用来自输出向量的索引填充输出向量的索引 # 这些补偿了goodVals。加1是为了避免索引为0 fillIdx &lt;- cumsum(goodIdx)+1 fillIdx #&gt; [1] 1 1 2 3 4 5 6 6 6 7 7 7 7 8 9 10 10 10 # 原本向量的值被填充了 #&gt; [1] NA NA &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; 6.23.2.1 填充空隙的函数 此函数执行与上面代码相同的操作。它还可以用第一个良好的值填充领头NA，并正确处理因子。 fillNAgaps &lt;- function(x, firstBack=FALSE) { ## 向量或因子中的NA被之前一个非NA值代替 ## 如果firstBack为TRUE，将会对领头的NA填充第一个非NA值，否则不会 # 如果是一个因子，保存因子的水平，并转换为整数 lvls &lt;- NULL if (is.factor(x)) { lvls &lt;- levels(x) x &lt;- as.integer(x) } goodIdx &lt;- !is.na(x) # 这些是来自于x的非NA值 # 加入领头NA或者以第一个值代替，取决于firstBack参数 if (firstBack) goodVals &lt;- c(x[goodIdx][1], x[goodIdx]) else goodVals &lt;- c(NA, x[goodIdx]) # 用来自输出向量的索引填充输出向量的索引 # 这些补偿了goodVals。加1是为了避免索引为0 fillIdx &lt;- cumsum(goodIdx)+1 x &lt;- goodVals[fillIdx] # 如果它最初是一个因子，那么将它转换回来 if (!is.null(lvls)) { x &lt;- factor(x, levels=seq_along(lvls), labels=lvls) } x } # 示例数据 x &lt;- c(NA,NA, &quot;A&quot;,&quot;A&quot;, &quot;B&quot;,&quot;B&quot;,&quot;B&quot;, NA,NA, &quot;C&quot;, NA,NA,NA, &quot;A&quot;,&quot;A&quot;,&quot;B&quot;, NA,NA) x #&gt; [1] NA NA &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; NA NA &quot;C&quot; NA NA NA &quot;A&quot; &quot;A&quot; &quot;B&quot; NA NA fillNAgaps(x) #&gt; [1] NA NA &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; # 对领头的NA以第一个非NA值进行填充 fillNAgaps(x, firstBack=TRUE) #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; # 因子数据也能使用 y &lt;- factor(x) y #&gt; [1] &lt;NA&gt; &lt;NA&gt; A A B B B &lt;NA&gt; &lt;NA&gt; C &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; A A B &lt;NA&gt; #&gt; [18] &lt;NA&gt; #&gt; Levels: A B C fillNAgaps(y) #&gt; [1] &lt;NA&gt; &lt;NA&gt; A A B B B B B C C C C A A B B #&gt; [18] B #&gt; Levels: A B C 6.23.2.2 注释 改编自来自于zoo library的na.locf() 函数 "],
["section-7.html", "第 7 章 统计分析 7.1 回归和相关分析 7.2 t检验 7.3 频数检验 7.4 ANOVA 7.5 逻辑回归 7.6 变量同质性", " 第 7 章 统计分析 7.1 回归和相关分析 7.1.1 问题 你想要做线性回归和/或相关分析。 7.1.2 方案 要处理的一些样例数据： # 制造一些数据 # X增加（大的干扰噪声） # Z缓慢增加 # 构建Y，它与X变量负相关，与X*Z变量正相关 set.seed(955) xvar &lt;- 1:20 + rnorm(20,sd=3) zvar &lt;- 1:20/4 + rnorm(20,sd=2) yvar &lt;- -2*xvar + xvar*zvar/5 + 3 + rnorm(20,sd=4) # 用制造的变量构建数据框 dat &lt;- data.frame(x=xvar, y=yvar, z=zvar) # 展示头部几行 head(dat) #&gt; x y z #&gt; 1 -4.252354 4.5857688 1.89877152 #&gt; 2 1.702318 -4.9027824 -0.82937359 #&gt; 3 4.323054 -4.3076433 -1.31283495 #&gt; 4 1.780628 0.2050367 -0.28479448 #&gt; 5 11.537348 -29.7670502 -1.27303976 #&gt; 6 6.672130 -10.1458220 -0.09459239 7.1.2.1 相关 # 相关系数 cor(dat$x, dat$y) #&gt; [1] -0.7695378 7.1.2.2 相关矩阵（多个变量） 我们也可以对多个配对变量进行相关分析操作，结果是一个矩阵或是数据框。 # 变量之间的相关矩阵 cor(dat) #&gt; x y z #&gt; x 1.0000000 -0.769537849 0.491698938 #&gt; y -0.7695378 1.000000000 0.004172295 #&gt; z 0.4916989 0.004172295 1.000000000 # Print with only two decimal places round(cor(dat), 2) #&gt; x y z #&gt; x 1.00 -0.77 0.49 #&gt; y -0.77 1.00 0.00 #&gt; z 0.49 0.00 1.00 7.1.2.3 线性回归 线性回归，当dat$x是预测变量时，dat$y为响应变量。这可以使用一个数据框的两列，或者是直接使用数值向量。 # 下面两个命令会显示一样的结果 fit &lt;- lm(y ~ x, data=dat) # 使用数据框的x列和y列 fit &lt;- lm(dat$y ~ dat$x) # 使用dat$x和dat$y进行拟合 fit #&gt; #&gt; Call: #&gt; lm(formula = dat$y ~ dat$x) #&gt; #&gt; Coefficients: #&gt; (Intercept) dat$x #&gt; -0.2278 -1.1829 # 这说明预测 y = -0.2278 - 1.1829*x # 获取更详细的信息 summary(fit) #&gt; #&gt; Call: #&gt; lm(formula = dat$y ~ dat$x) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -15.8922 -2.5114 0.2866 4.4646 9.3285 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) -0.2278 2.6323 -0.087 0.932 #&gt; dat$x -1.1829 0.2314 -5.113 7.28e-05 *** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 6.506 on 18 degrees of freedom #&gt; Multiple R-squared: 0.5922, Adjusted R-squared: 0.5695 #&gt; F-statistic: 26.14 on 1 and 18 DF, p-value: 7.282e-05 7.1.2.4 多个预测变量的线性回归（多元线性回归） 使用y作为线性回归的响应变量，x和z作为预测变量。 注意下面的公式没有检测x与z之间的交互效应。 # 这些都有相同的结果 fit2 &lt;- lm(y ~ x + z, data=dat) # 使用数据框的x,y,z列 fit2 &lt;- lm(dat$y ~ dat$x + dat$z) # 使用向量 fit2 #&gt; #&gt; Call: #&gt; lm(formula = dat$y ~ dat$x + dat$z) #&gt; #&gt; Coefficients: #&gt; (Intercept) dat$x dat$z #&gt; -1.382 -1.564 1.858 summary(fit2) #&gt; #&gt; Call: #&gt; lm(formula = dat$y ~ dat$x + dat$z) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -7.974 -3.187 -1.205 3.847 7.524 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) -1.3816 1.9878 -0.695 0.49644 #&gt; dat$x -1.5642 0.1984 -7.883 4.46e-07 *** #&gt; dat$z 1.8578 0.4753 3.908 0.00113 ** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 4.859 on 17 degrees of freedom #&gt; Multiple R-squared: 0.7852, Adjusted R-squared: 0.7599 #&gt; F-statistic: 31.07 on 2 and 17 DF, p-value: 2.1e-06 7.1.2.4.1 交互效应 如何合适地构建多元线性回归并且检验交互效应非常复杂，这里不作讲述。这里我们仅仅用x和z变量以及它们之间的交互效应拟合模型。 想要构建x与z之间的交互效应模型，需要添加x:z项。我们也可以使用公式x*z来代表x+z+x:z。 # 下面两个公式等效 fit3 &lt;- lm(y ~ x * z, data=dat) fit3 &lt;- lm(y ~ x + z + x:z, data=dat) fit3 #&gt; #&gt; Call: #&gt; lm(formula = y ~ x + z + x:z, data = dat) #&gt; #&gt; Coefficients: #&gt; (Intercept) x z x:z #&gt; 2.2820 -2.1311 -0.1068 0.2081 summary(fit3) #&gt; #&gt; Call: #&gt; lm(formula = y ~ x + z + x:z, data = dat) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -5.3045 -3.5998 0.3926 2.1376 8.3957 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 2.28204 2.20064 1.037 0.3152 #&gt; x -2.13110 0.27406 -7.776 8e-07 *** #&gt; z -0.10682 0.84820 -0.126 0.9013 #&gt; x:z 0.20814 0.07874 2.643 0.0177 * #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 4.178 on 16 degrees of freedom #&gt; Multiple R-squared: 0.8505, Adjusted R-squared: 0.8225 #&gt; F-statistic: 30.34 on 3 and 16 DF, p-value: 7.759e-07 7.2 t检验 7.2.1 问题 你想要检验来自两个总体的样本是否有不同的均值（显著性差异），或者检验从一个总体抽取的样本均值和理论均值有显著性差异。 7.2.2 方案 7.2.2.1 样本数据 我们将使用内置的sleep数据集。 sleep #&gt; extra group ID #&gt; 1 0.7 1 1 #&gt; 2 -1.6 1 2 #&gt; 3 -0.2 1 3 #&gt; 4 -1.2 1 4 #&gt; 5 -0.1 1 5 #&gt; 6 3.4 1 6 #&gt; 7 3.7 1 7 #&gt; 8 0.8 1 8 #&gt; 9 0.0 1 9 #&gt; 10 2.0 1 10 #&gt; 11 1.9 2 1 #&gt; 12 0.8 2 2 #&gt; 13 1.1 2 3 #&gt; 14 0.1 2 4 #&gt; 15 -0.1 2 5 #&gt; 16 4.4 2 6 #&gt; 17 5.5 2 7 #&gt; 18 1.6 2 8 #&gt; 19 4.6 2 9 #&gt; 20 3.4 2 10 我们将制造sleep数据的宽格式版本；下面我们将看看如何处理长格式和宽格式的数据。 sleep_wide &lt;- data.frame( ID=1:10, group1=sleep$extra[1:10], group2=sleep$extra[11:20] ) sleep_wide #&gt; ID group1 group2 #&gt; 1 1 0.7 1.9 #&gt; 2 2 -1.6 0.8 #&gt; 3 3 -0.2 1.1 #&gt; 4 4 -1.2 0.1 #&gt; 5 5 -0.1 -0.1 #&gt; 6 6 3.4 4.4 #&gt; 7 7 3.7 5.5 #&gt; 8 8 0.8 1.6 #&gt; 9 9 0.0 4.6 #&gt; 10 10 2.0 3.4 7.2.2.2 比较两组：独立双样本t检验 假设有两组独立样本（我们这里忽略ID变量）。 t.test函数能够操作像sleep这样的长格式数据——一列记录测量值，一列指定组别；或者操作两个单独的向量。 # Welch t-test t.test(extra ~ group, sleep) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: extra by group #&gt; t = -1.8608, df = 17.776, p-value = 0.07939 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -3.3654832 0.2054832 #&gt; sample estimates: #&gt; mean in group 1 mean in group 2 #&gt; 0.75 2.33 # Same for wide data (two separate vectors) # t.test(sleep_wide$group1, sleep_wide$group2) 默认，t.test不假设有方差齐性（或称作方差同质）。默认的不是Student t检验而是使用了Welch t检验。注意Welch t-test结果中df=17.776，这是因为对不同质方差进行了校正。要使用Student t检验的话，设置var.equal=TRUE。 # Student t-test t.test(extra ~ group, sleep, var.equal=TRUE) #&gt; #&gt; Two Sample t-test #&gt; #&gt; data: extra by group #&gt; t = -1.8608, df = 18, p-value = 0.07919 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -3.363874 0.203874 #&gt; sample estimates: #&gt; mean in group 1 mean in group 2 #&gt; 0.75 2.33 # Same for wide data (two separate vectors) # t.test(sleep_wide$group1, sleep_wide$group2, var.equal=TRUE) 7.2.2.3 配对样本t检验 你也可以使用配对样本t检验比较配对的数据。数据配对是指你可能有对某种药物治疗前后有观测值或者不同治疗有配对的研究对象。 再次说明，t-test函数可以用于有分组变量的数据框或者两个向量。它依赖相对位置来决定配对。如果你使用有分组变量的长格式数据，group=1的第一行与group2的第一行配对。确保数据排序好并且不存在缺失值是非常重要的；否则配对可以丢弃。这种情况中，我们能通过group和ID变量进行排序来确保顺序是一样的。 # Sort by group then ID sleep &lt;- sleep[order(sleep$group, sleep$ID), ] # Paired t-test t.test(extra ~ group, sleep, paired=TRUE) #&gt; #&gt; Paired t-test #&gt; #&gt; data: extra by group #&gt; t = -4.0621, df = 9, p-value = 0.002833 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -2.4598858 -0.7001142 #&gt; sample estimates: #&gt; mean of the differences #&gt; -1.58 # Same for wide data (two separate vectors) # t.test(sleep.wide$group1, sleep.wide$group2, paired=TRUE) 配对t检验等价于检测是否配对的观察值的总体均值是否为0。 t.test(sleep.wide$group1 - sleep.wide$group2, mu=0, var.equal=TRUE) #&gt; Error in t.test(sleep.wide$group1 - sleep.wide$group2, mu = 0, var.equal = TRUE): object &#39;sleep.wide&#39; not found 7.2.2.4 与期望的总体均值进行比较：单样本t检验 假设你想要检测是否extra列的数据抽取自总体均值为0的总体。（这里忽略group与ID列） t.test(sleep$extra, mu=0) #&gt; #&gt; One Sample t-test #&gt; #&gt; data: sleep$extra #&gt; t = 3.413, df = 19, p-value = 0.002918 #&gt; alternative hypothesis: true mean is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 0.5955845 2.4844155 #&gt; sample estimates: #&gt; mean of x #&gt; 1.54 7.3 频数检验 7.3.1 问题 你有分类数据然后想要检验是否这些数据值的频数分布是否与预期不符，或者是否组间的频数分布有（显著）差异。 7.3.2 方案 频数检验通常解决两类问题： 频数分布与预期或者理论的分布（比如50%的yes，50%的no）符合吗？（拟合优度检验） 两组或多组之间的频率分布有差异吗？（独立检验） 通常用于解决这样问题的统计检验方法，分为精确检验与近似检验两种。 期望分布 比较组别 精确 精确二项检验 Fisher精确检验 近似 卡方拟合优度 独立卡方检验 注意：精确二项检验仅能用于有两个水平的单变量。Fisher精确检验仅能用于二维列联表（比如，当存在一个独立变量和一个非独立变量时它可以使用；但不能用于两个独立变量和一个非独立变量的情况）。 想要检验配对或被试内效应，我们可以使用McNemar检验。使用该检验必须满足存在两个水平的独立变量和两个水平的非独立变量。 想要检验有重复测量的两个变量独立性，我们可以使用Cochran-Mantel-Haenszel 检验。 假设你有下面的数据，其中每一行代表一个记录： data &lt;- read.table(header=TRUE, text=&#39; condition result control 0 control 0 control 0 control 0 treatment 1 control 0 control 0 treatment 0 treatment 1 control 1 treatment 1 treatment 1 treatment 1 treatment 1 treatment 0 control 0 control 1 control 0 control 1 treatment 0 treatment 1 treatment 0 treatment 0 control 0 treatment 1 control 0 control 0 treatment 1 treatment 0 treatment 1 &#39;) 相比于以记录的数据框存储，你的数据可能是计数的数据框，或者是一个列联表。 7.3.2.1 拟合优度检验 （期望频率） 7.3.2.1.1 卡方检验 想要检验假设：结果列result（忽略条件condition）中的两个值在总体中几乎相等（50%-50%）。 # 为result列创建列联表，包含0和1两个值 # 注意“０”和“１”是列名而不是实际的值 ct &lt;- table(data$result) ct #&gt; #&gt; 0 1 #&gt; 17 13 # 也可以手动创建表格 #ct &lt;- matrix(c(17,13), ncol=2) #colnames(ct1) &lt;- c(&quot;0&quot;, &quot;1&quot;) # 执行卡方检验 chisq.test(ct) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: ct #&gt; X-squared = 0.53333, df = 1, p-value = 0.4652 想要检验有不同期望频率的样本（比如下面一个0.75，一个0.25）： # 概率表 —— 和必须为1 pt &lt;- c(.75, .25) chisq.test(ct, p=pt) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: ct #&gt; X-squared = 5.3778, df = 1, p-value = 0.02039 如果你想要从检验结果中提取信息，可以将结果保存进一个变量，然后用str()函数查看变量信息，接着把你想要的部分取出来。例如： chi_res &lt;- chisq.test(ct, p=pt) # View all the parts that can be extracted str(chi_res) #&gt; List of 9 #&gt; $ statistic: Named num 5.38 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;X-squared&quot; #&gt; $ parameter: Named num 1 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;df&quot; #&gt; $ p.value : num 0.0204 #&gt; $ method : chr &quot;Chi-squared test for given probabilities&quot; #&gt; $ data.name: chr &quot;ct&quot; #&gt; $ observed : &#39;table&#39; int [1:2(1d)] 17 13 #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 1 #&gt; .. ..$ : chr [1:2] &quot;0&quot; &quot;1&quot; #&gt; $ expected : Named num [1:2] 22.5 7.5 #&gt; ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;0&quot; &quot;1&quot; #&gt; $ residuals: table [1:2(1d)] -1.16 2.01 #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 1 #&gt; .. ..$ : chr [1:2] &quot;0&quot; &quot;1&quot; #&gt; $ stdres : table [1:2(1d)] -2.32 2.32 #&gt; ..- attr(*, &quot;dimnames&quot;)=List of 1 #&gt; .. ..$ : chr [1:2] &quot;0&quot; &quot;1&quot; #&gt; - attr(*, &quot;class&quot;)= chr &quot;htest&quot; # 获取卡方值 chi_res$statistic #&gt; X-squared #&gt; 5.377778 # 获取p值 chi_res$p.value #&gt; [1] 0.02039484 7.3.2.1.2 精确二项检验 精确二项检验仅能用于存在两个值的单变量数据。 ct &lt;- table(data$result) ct #&gt; #&gt; 0 1 #&gt; 17 13 binom.test(ct, p=0.5) #&gt; #&gt; Exact binomial test #&gt; #&gt; data: ct #&gt; number of successes = 17, number of trials = 30, p-value = 0.5847 #&gt; alternative hypothesis: true probability of success is not equal to 0.5 #&gt; 95 percent confidence interval: #&gt; 0.3742735 0.7453925 #&gt; sample estimates: #&gt; probability of success #&gt; 0.5666667 # 使用75%的期望概率——注意1在第二列，所以只需要令p=0.25 binom.test(ct, p=0.25) #&gt; #&gt; Exact binomial test #&gt; #&gt; data: ct #&gt; number of successes = 17, number of trials = 30, p-value = 0.0002157 #&gt; alternative hypothesis: true probability of success is not equal to 0.25 #&gt; 95 percent confidence interval: #&gt; 0.3742735 0.7453925 #&gt; sample estimates: #&gt; probability of success #&gt; 0.5666667 如果你想要从检验结果中提取信息，可以将结果保存进一个变量，然后用str()函数查看变量信息，接着把你想要的部分取出来。例如： bin_res &lt;- binom.test(ct, p=0.25) # View all the parts that can be extracted str(bin_res) #&gt; List of 9 #&gt; $ statistic : Named num 17 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;number of successes&quot; #&gt; $ parameter : Named num 30 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;number of trials&quot; #&gt; $ p.value : Named num 0.000216 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;0&quot; #&gt; $ conf.int : atomic [1:2] 0.374 0.745 #&gt; ..- attr(*, &quot;conf.level&quot;)= num 0.95 #&gt; $ estimate : Named num 0.567 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;probability of success&quot; #&gt; $ null.value : Named num 0.25 #&gt; ..- attr(*, &quot;names&quot;)= chr &quot;probability of success&quot; #&gt; $ alternative: chr &quot;two.sided&quot; #&gt; $ method : chr &quot;Exact binomial test&quot; #&gt; $ data.name : chr &quot;ct&quot; #&gt; - attr(*, &quot;class&quot;)= chr &quot;htest&quot; # 获取p值 bin_res$p.value #&gt; 0 #&gt; 0.0002156938 # 获取95%置信区间 bin_res$conf.int #&gt; [1] 0.3742735 0.7453925 #&gt; attr(,&quot;conf.level&quot;) #&gt; [1] 0.95 7.3.2.2 独立检验（比较组间） 7.3.2.2.1 卡方检验 想要检验控制和处理组结果的频数差异，使用2维列联表。 ct &lt;- table(data$condition, data$result) ct #&gt; #&gt; 0 1 #&gt; control 11 3 #&gt; treatment 6 10 chisq.test(ct) #&gt; #&gt; Pearson&#39;s Chi-squared test with Yates&#39; continuity correction #&gt; #&gt; data: ct #&gt; X-squared = 3.593, df = 1, p-value = 0.05802 chisq.test(ct, correct=FALSE) #&gt; #&gt; Pearson&#39;s Chi-squared test #&gt; #&gt; data: ct #&gt; X-squared = 5.1293, df = 1, p-value = 0.02353 7.3.2.2.2 Fisher精确检验 对于小样本而言Fisher精确检验更为适合。小样本的2x2列表非常典型，样本更多、更复杂的列表计算强度非常大。当然，用R进行比较复杂的计算也是没有太大问题的。 ct &lt;- table(data$condition, data$result) ct #&gt; #&gt; 0 1 #&gt; control 11 3 #&gt; treatment 6 10 fisher.test(ct) #&gt; #&gt; Fisher&#39;s Exact Test for Count Data #&gt; #&gt; data: ct #&gt; p-value = 0.03293 #&gt; alternative hypothesis: true odds ratio is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0.966861 45.555016 #&gt; sample estimates: #&gt; odds ratio #&gt; 5.714369 7.3.2.2.3 Cochran-Mantel-Haenszel test Cochran-Mantel-Haenszel 检验 （或称为 Mantel-Haenszel 检验)）用于检验重复测量两离散变量的独立性。通常使用 2x2xK列表表示，K是测量条件的次数。比如你想要指导是否一个处理（C vs. D）是否影响了恢复的概率（yes or no）。假设该处理一天监控测量三次——早上、中午和晚上，而你想要你的检验能够控制它。那么你可以使用CMH检验对2x2x3列联表进行操作，第三个变量是你想要控制的变量。 R中的CMH检验可以处理比2x2xK维度更高的数据，例如你处理3x3xK列联表。 在接下来的例子里有三个变量：Location，Allele和Habitat。问题是——当控制location变量时，Allel（94或非94）和Habitat（marine或estuarine）两个变量是否独立。 fish &lt;- read.table(header=TRUE, text=&#39; Location Allele Habitat Count tillamook 94 marine 56 tillamook 94 estuarine 69 tillamook non-94 marine 40 tillamook non-94 estuarine 77 yaquina 94 marine 61 yaquina 94 estuarine 257 yaquina non-94 marine 57 yaquina non-94 estuarine 301 alsea 94 marine 73 alsea 94 estuarine 65 alsea non-94 marine 71 alsea non-94 estuarine 79 umpqua 94 marine 71 umpqua 94 estuarine 48 umpqua non-94 marine 55 umpqua non-94 estuarine 48 &#39;) 注意上面的数据是计数的数据框，而不是像之前的例子是记录的数据框。这里我们使用xtabs()函数将它转换为列联表。 # 制造一个3维的列联表，最后一个变量时要控制的Location变量 ct &lt;- xtabs(Count ~ Allele + Habitat + Location, data=fish) ct #&gt; , , Location = alsea #&gt; #&gt; Habitat #&gt; Allele estuarine marine #&gt; 94 65 73 #&gt; non-94 79 71 #&gt; #&gt; , , Location = tillamook #&gt; #&gt; Habitat #&gt; Allele estuarine marine #&gt; 94 69 56 #&gt; non-94 77 40 #&gt; #&gt; , , Location = umpqua #&gt; #&gt; Habitat #&gt; Allele estuarine marine #&gt; 94 48 71 #&gt; non-94 48 55 #&gt; #&gt; , , Location = yaquina #&gt; #&gt; Habitat #&gt; Allele estuarine marine #&gt; 94 257 61 #&gt; non-94 301 57 # This prints ct in a &quot;flat&quot; format ftable(ct) #&gt; Location alsea tillamook umpqua yaquina #&gt; Allele Habitat #&gt; 94 estuarine 65 69 48 257 #&gt; marine 73 56 71 61 #&gt; non-94 estuarine 79 77 48 301 #&gt; marine 71 40 55 57 # 按指定方式进行变量输出 ftable(ct, row.vars=c(&quot;Location&quot;,&quot;Allele&quot;), col.vars=&quot;Habitat&quot;) #&gt; Habitat estuarine marine #&gt; Location Allele #&gt; alsea 94 65 73 #&gt; non-94 79 71 #&gt; tillamook 94 69 56 #&gt; non-94 77 40 #&gt; umpqua 94 48 71 #&gt; non-94 48 55 #&gt; yaquina 94 257 61 #&gt; non-94 301 57 mantelhaen.test(ct) #&gt; #&gt; Mantel-Haenszel chi-squared test with continuity correction #&gt; #&gt; data: ct #&gt; Mantel-Haenszel X-squared = 5.0497, df = 1, p-value = 0.02463 #&gt; alternative hypothesis: true common odds ratio is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0.6005522 0.9593077 #&gt; sample estimates: #&gt; common odds ratio #&gt; 0.759022 根据检验结果，当控制Location变量时Allele与Habitat变量存在相关（p=.025）。 注意列联表的前两个维度处理是一致的，所以前后顺序变化都不会影响结果。而最后一个变量变化会导致结果的不同，下面是一个实例。 # 下面两个看似不同的列联表，实际检验结果相同 ct.1 &lt;- xtabs(Count ~ Habitat + Allele + Location, data=fish) ct.2 &lt;- xtabs(Count ~ Allele + Habitat + Location, data=fish) mantelhaen.test(ct.1) #&gt; #&gt; Mantel-Haenszel chi-squared test with continuity correction #&gt; #&gt; data: ct.1 #&gt; Mantel-Haenszel X-squared = 5.0497, df = 1, p-value = 0.02463 #&gt; alternative hypothesis: true common odds ratio is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0.6005522 0.9593077 #&gt; sample estimates: #&gt; common odds ratio #&gt; 0.759022 mantelhaen.test(ct.2) #&gt; #&gt; Mantel-Haenszel chi-squared test with continuity correction #&gt; #&gt; data: ct.2 #&gt; Mantel-Haenszel X-squared = 5.0497, df = 1, p-value = 0.02463 #&gt; alternative hypothesis: true common odds ratio is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0.6005522 0.9593077 #&gt; sample estimates: #&gt; common odds ratio #&gt; 0.759022 # 把Allele放到最后，结果不同了 ct.3 &lt;- xtabs(Count ~ Location + Habitat + Allele, data=fish) ct.4 &lt;- xtabs(Count ~ Habitat + Location + Allele, data=fish) mantelhaen.test(ct.3) #&gt; #&gt; Cochran-Mantel-Haenszel test #&gt; #&gt; data: ct.3 #&gt; Cochran-Mantel-Haenszel M^2 = 168.47, df = 3, p-value &lt; 2.2e-16 mantelhaen.test(ct.4) #&gt; #&gt; Cochran-Mantel-Haenszel test #&gt; #&gt; data: ct.4 #&gt; Cochran-Mantel-Haenszel M^2 = 168.47, df = 3, p-value &lt; 2.2e-16 # 把Habitat放最后，结果也不同 ct.5 &lt;- xtabs(Count ~ Allele + Location + Habitat, data=fish) ct.6 &lt;- xtabs(Count ~ Location + Allele + Habitat, data=fish) mantelhaen.test(ct.5) #&gt; #&gt; Cochran-Mantel-Haenszel test #&gt; #&gt; data: ct.5 #&gt; Cochran-Mantel-Haenszel M^2 = 2.0168, df = 3, p-value = 0.5689 mantelhaen.test(ct.6) #&gt; #&gt; Cochran-Mantel-Haenszel test #&gt; #&gt; data: ct.6 #&gt; Cochran-Mantel-Haenszel M^2 = 2.0168, df = 3, p-value = 0.5689 7.3.2.3 McNemar检验 McNemar检验概念上是频数数据的一个被试内检验。例如，假设你想要检验是否一个处理增加了一个人对某个问题反应“yes”的概率，而且你只有每个人处理前和处理后的数据。标准的卡方检验将不合适，因为它假设了组别是独立的。取而代之，我们可以使用McNemar检验。该检验仅适用于当存在一个独立变量的两次测量时。用于McNemar的列联表与用于卡方检验的非常相似，但结构上是不同的。 假设你有下面的数据。每个对象有处理前和后的反应。 data &lt;- read.table(header=TRUE, text=&#39; subject time result 1 pre 0 1 post 1 2 pre 1 2 post 1 3 pre 0 3 post 1 4 pre 1 4 post 0 5 pre 1 5 post 1 6 pre 0 6 post 1 7 pre 0 7 post 1 8 pre 0 8 post 1 9 pre 0 9 post 1 10 pre 1 10 post 1 11 pre 0 11 post 0 12 pre 1 12 post 1 13 pre 0 13 post 1 14 pre 0 14 post 0 15 pre 0 15 post 1 &#39;) library(tidyr) data_wide &lt;- spread(data, time, result) data_wide #&gt; subject post pre #&gt; 1 1 1 0 #&gt; 2 2 1 1 #&gt; 3 3 1 0 #&gt; 4 4 0 1 #&gt; 5 5 1 1 #&gt; 6 6 1 0 #&gt; 7 7 1 0 #&gt; 8 8 1 0 #&gt; 9 9 1 0 #&gt; 10 10 1 1 #&gt; 11 11 0 0 #&gt; 12 12 1 1 #&gt; 13 13 1 0 #&gt; 14 14 0 0 #&gt; 15 15 1 0 接下来从数据框的pre和post列生成列联表： ct &lt;- table( data_wide[,c(&quot;pre&quot;,&quot;post&quot;)] ) ct #&gt; post #&gt; pre 0 1 #&gt; 0 2 8 #&gt; 1 1 4 # 下面是用于标准卡方检验的列联表，注意差别喔 # table(data[,c(&quot;time&quot;,&quot;result&quot;)]) # result # time 0 1 # post 3 12 # pre 10 5 执行检验： mcnemar.test(ct) #&gt; #&gt; McNemar&#39;s Chi-squared test with continuity correction #&gt; #&gt; data: ct #&gt; McNemar&#39;s chi-squared = 4, df = 1, p-value = 0.0455 对于小样本，它会使用连续校正。我们可以使用精确校正的McNemar检验替换这种校正方式，前者更加的精确，可通过exact2x2包获取。 library(exact2x2) #&gt; Loading required package: exactci #&gt; Loading required package: ssanv mcnemar.exact(ct) #&gt; #&gt; Exact McNemar test (with central confidence intervals) #&gt; #&gt; data: ct #&gt; b = 8, c = 1, p-value = 0.03906 #&gt; alternative hypothesis: true odds ratio is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 1.072554 354.981246 #&gt; sample estimates: #&gt; odds ratio #&gt; 8 7.4 ANOVA 7.4.1 问题 你想要使用ANOVA比较多组之间的差异。 7.4.2 方案 假设这是你的数据： data &lt;- read.table(header=TRUE, text=&#39; subject sex age before after 1 F old 9.5 7.1 2 M old 10.3 11.0 3 M old 7.5 5.8 4 F old 12.4 8.8 5 M old 10.2 8.6 6 M old 11.0 8.0 7 M young 9.1 3.0 8 F young 7.9 5.2 9 F old 6.6 3.4 10 M young 7.7 4.0 11 M young 9.4 5.3 12 M old 11.6 11.3 13 M young 9.9 4.6 14 F young 8.6 6.4 15 F young 14.3 13.5 16 F old 9.2 4.7 17 M young 9.8 5.1 18 F old 9.9 7.3 19 F young 13.0 9.5 20 M young 10.2 5.4 21 M young 9.0 3.7 22 F young 7.9 6.2 23 M old 10.1 10.0 24 M young 9.0 1.7 25 M young 8.6 2.9 26 M young 9.4 3.2 27 M young 9.7 4.7 28 M young 9.3 4.9 29 F young 10.7 9.8 30 M old 9.3 9.4 &#39;) # 确保subject列是一个因子变量，这样不会当作连续变量对待 data$subject &lt;- factor(data$subject) 7.4.2.1 单因素ANOVA分析 # 单因素： # 独立变量: sex # 依赖变量: before aov1 &lt;- aov(before ~ sex, data=data) summary(aov1) #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; sex 1 1.53 1.529 0.573 0.455 #&gt; Residuals 28 74.70 2.668 # 显示均值 model.tables(aov1, &quot;means&quot;) #&gt; Tables of means #&gt; Grand mean #&gt; #&gt; 9.703333 #&gt; #&gt; sex #&gt; F M #&gt; 10 9.532 #&gt; rep 11 19.000 7.4.2.2 双因素ANOVA分析 # 2x2 between: # 独立变量: sex # 独立变量 age # 依赖变量: after # 下面两种调用方式等价： aov2 &lt;- aov(after ~ sex*age, data=data) aov2 &lt;- aov(after ~ sex + age + sex:age, data=data) summary(aov2) #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; sex 1 16.08 16.08 4.038 0.0550 . #&gt; age 1 38.96 38.96 9.786 0.0043 ** #&gt; sex:age 1 89.61 89.61 22.509 6.6e-05 *** #&gt; Residuals 26 103.51 3.98 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # 显示均值 model.tables(aov2, &quot;means&quot;) #&gt; Tables of means #&gt; Grand mean #&gt; #&gt; 6.483333 #&gt; #&gt; sex #&gt; F M #&gt; 7.445 5.926 #&gt; rep 11.000 19.000 #&gt; #&gt; age #&gt; old young #&gt; 7.874 5.556 #&gt; rep 12.000 18.000 #&gt; #&gt; sex:age #&gt; age #&gt; sex old young #&gt; F 6.260 8.433 #&gt; rep 5.000 6.000 #&gt; M 9.157 4.042 #&gt; rep 7.000 12.000 7.4.2.3 Tukey HSD post-hoc 检验 TukeyHSD(aov2) #&gt; Tukey multiple comparisons of means #&gt; 95% family-wise confidence level #&gt; #&gt; Fit: aov(formula = after ~ sex + age + sex:age, data = data) #&gt; #&gt; $sex #&gt; diff lwr upr p adj #&gt; M-F -1.519139 -3.073025 0.03474709 0.0549625 #&gt; #&gt; $age #&gt; diff lwr upr p adj #&gt; young-old -2.31785 -3.846349 -0.7893498 0.0044215 #&gt; #&gt; $`sex:age` #&gt; diff lwr upr p adj #&gt; M:old-F:old 2.8971429 -0.3079526 6.1022384 0.0869856 #&gt; F:young-F:old 2.1733333 -1.1411824 5.4878491 0.2966111 #&gt; M:young-F:old -2.2183333 -5.1319553 0.6952887 0.1832890 #&gt; F:young-M:old -0.7238095 -3.7691188 2.3214997 0.9138789 #&gt; M:young-M:old -5.1154762 -7.7187601 -2.5121923 0.0000676 #&gt; M:young-F:young -4.3916667 -7.1285380 -1.6547953 0.0008841 7.4.3 有受试内变量的ANOVAs 对于有受试内变量的ANOVA分析，数据必须满足为长格式。上面提到的数据都是宽格式，所以我们需要先转换数据格式（参见[长宽格式互相转换] 同样地，有受试内变量的ANOVA分析需要一个识别列。当前数据里是subject列。识别变量必须是一个因子，如果是数值类型，函数会解析错误导致不能正常工作。 library(tidyr) # 原始数据 # subject sex age before after # 1 F old 9.5 7.1 # 2 M old 10.3 11.0 # 3 M old 7.5 5.8 # 转换为长格式 data_long &lt;- gather(data, time, value, before:after) # Look at first few rows head(data_long) #&gt; subject sex age time value #&gt; 1 1 F old before 9.5 #&gt; 2 2 M old before 10.3 #&gt; 3 3 M old before 7.5 #&gt; 4 4 F old before 12.4 #&gt; 5 5 M old before 10.2 #&gt; 6 6 M old before 11.0 # 确保subject列是一个因子 data_long$subject &lt;- factor(data_long$subject) 7.4.3.1 One-way within ANOVA 首先，像上面展示的一样将数据从宽格式转换到长格式并确保subject列是因子变量。如果subject是数值向量，而不是因子，你的结果将会出错。 # 独立变量 (within): time # 依赖变量: value aov_time &lt;- aov(value ~ time + Error(subject/time), data=data_long) summary(aov_time) #&gt; #&gt; Error: subject #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; Residuals 29 261.2 9.009 #&gt; #&gt; Error: subject:time #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; time 1 155.53 155.53 71.43 2.59e-09 *** #&gt; Residuals 29 63.14 2.18 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # This won&#39;t work here for some reason (?) model.tables(aov_time, &quot;means&quot;) #&gt; Tables of means #&gt; Grand mean #&gt; #&gt; 8.093333 #&gt; #&gt; time #&gt; time #&gt; after before #&gt; 6.483 9.703 7.4.3.2 混合设计 ANOVA 首先，像上面展示的一样将数据从宽格式转换到长格式并确保subject列是因子变量。 # 2x2 mixed: # 独立变量（被试间） : age # 独立变量（被试内） : time # 依赖变量: value aov_age_time &lt;- aov(value ~ age*time + Error(subject/time), data=data_long) summary(aov_age_time) #&gt; #&gt; Error: subject #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; age 1 24.44 24.440 2.89 0.1 #&gt; Residuals 28 236.81 8.457 #&gt; #&gt; Error: subject:time #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; time 1 155.53 155.53 98.14 1.18e-10 *** #&gt; age:time 1 18.77 18.77 11.84 0.00184 ** #&gt; Residuals 28 44.37 1.58 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # This won&#39;t work here because the data is unbalanced model.tables(aov_age_time, &quot;means&quot;) #&gt; Tables of means #&gt; Grand mean #&gt; #&gt; 8.093333 #&gt; #&gt; age #&gt; old young #&gt; 8.875 7.572 #&gt; rep 24.000 36.000 #&gt; #&gt; time #&gt; after before #&gt; 6.483 9.703 #&gt; rep 30.000 30.000 #&gt; #&gt; age:time #&gt; time #&gt; age after before #&gt; old 7.950 9.800 #&gt; rep 12.000 12.000 #&gt; young 5.506 9.639 #&gt; rep 18.000 18.000 7.4.3.3 更多被试内变量的ANOVA 下面这些例子使用的不是上面的数据，但可以解释怎么进行相应的处理。首先，像上面展示的一样将数据从宽格式转换到长格式并确保subject列是因子变量。 # 两个被试内变量 aov.ww &lt;- aov(y ~ w1*w2 + Error(subject/(w1*w2)), data=data_long) # 1个被试间变量，两个被试内变量 aov.bww &lt;- aov(y ~ b1*w1*w2 + Error(subject/(w1*w2)) + b1, data=data_long) # 两个被试间变量，一个被试内变量 aov.bww &lt;- aov(y ~ b1*b2*w1 + Error(subject/(w1)) + b1*b2, data=data_long) 7.5 逻辑回归 7.5.1 问题 你想要运用逻辑回归分析。 7.5.2 方案 逻辑回归典型使用于当存在一个离散的响应变量（比如赢和输）和一个与响应变量（也称为结果变量、因变量）的概率或几率相关联的连续预测变量的情况。它也适用于有多个预测变量的分类预测。 假设我们从内置的mtcars数据集的一部分开始，像下面这样，我们将vs作为响应变量，mpg作为一个连续的预测变量，am作为一个分类（离散）的预测变量。 data(mtcars) dat &lt;- subset(mtcars, select=c(mpg, am, vs)) dat #&gt; mpg am vs #&gt; Mazda RX4 21.0 1 0 #&gt; Mazda RX4 Wag 21.0 1 0 #&gt; Datsun 710 22.8 1 1 #&gt; Hornet 4 Drive 21.4 0 1 #&gt; Hornet Sportabout 18.7 0 0 #&gt; Valiant 18.1 0 1 #&gt; Duster 360 14.3 0 0 #&gt; Merc 240D 24.4 0 1 #&gt; Merc 230 22.8 0 1 #&gt; Merc 280 19.2 0 1 #&gt; Merc 280C 17.8 0 1 #&gt; Merc 450SE 16.4 0 0 #&gt; Merc 450SL 17.3 0 0 #&gt; Merc 450SLC 15.2 0 0 #&gt; Cadillac Fleetwood 10.4 0 0 #&gt; Lincoln Continental 10.4 0 0 #&gt; Chrysler Imperial 14.7 0 0 #&gt; Fiat 128 32.4 1 1 #&gt; Honda Civic 30.4 1 1 #&gt; Toyota Corolla 33.9 1 1 #&gt; Toyota Corona 21.5 0 1 #&gt; Dodge Challenger 15.5 0 0 #&gt; AMC Javelin 15.2 0 0 #&gt; Camaro Z28 13.3 0 0 #&gt; Pontiac Firebird 19.2 0 0 #&gt; Fiat X1-9 27.3 1 1 #&gt; Porsche 914-2 26.0 1 0 #&gt; Lotus Europa 30.4 1 1 #&gt; Ford Pantera L 15.8 1 0 #&gt; Ferrari Dino 19.7 1 0 #&gt; Maserati Bora 15.0 1 0 #&gt; Volvo 142E 21.4 1 1 7.5.2.1 连续预测变量，离散响应变量 如果数据集有一个离散变量和一个连续变量，并且连续变量离散变量概率的预测器（就像直线回归中x可以预测y一样，只不过是两个连续变量，而逻辑回归中被预测的是离散变量），逻辑回归可能适用。 下面例子中，mpg是连续预测变量，vs是离散响应变量。. # 执行逻辑回归 —— 下面两种方式等效 # logit是二项分布家族的默认模型 logr_vm &lt;- glm(vs ~ mpg, data=dat, family=binomial) logr_vm &lt;- glm(vs ~ mpg, data=dat, family=binomial(link=&quot;logit&quot;)) 查看模型信息： # 输出模型信息 logr_vm #&gt; #&gt; Call: glm(formula = vs ~ mpg, family = binomial(link = &quot;logit&quot;), data = dat) #&gt; #&gt; Coefficients: #&gt; (Intercept) mpg #&gt; -8.8331 0.4304 #&gt; #&gt; Degrees of Freedom: 31 Total (i.e. Null); 30 Residual #&gt; Null Deviance: 43.86 #&gt; Residual Deviance: 25.53 AIC: 29.53 # More information about the model summary(logr_vm) #&gt; #&gt; Call: #&gt; glm(formula = vs ~ mpg, family = binomial(link = &quot;logit&quot;), data = dat) #&gt; #&gt; Deviance Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -2.2127 -0.5121 -0.2276 0.6402 1.6980 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error z value Pr(&gt;|z|) #&gt; (Intercept) -8.8331 3.1623 -2.793 0.00522 ** #&gt; mpg 0.4304 0.1584 2.717 0.00659 ** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; (Dispersion parameter for binomial family taken to be 1) #&gt; #&gt; Null deviance: 43.860 on 31 degrees of freedom #&gt; Residual deviance: 25.533 on 30 degrees of freedom #&gt; AIC: 29.533 #&gt; #&gt; Number of Fisher Scoring iterations: 6 7.5.2.1.1 画图 我们可以使用ggplot2或者基本图形绘制数据和逻辑回归结果。 library(ggplot2) ggplot(dat, aes(x=mpg, y=vs)) + geom_point() + stat_smooth(method=&quot;glm&quot;, method.args=list(family=&quot;binomial&quot;), se=FALSE) par(mar = c(4, 4, 1, 1)) # 减少一些边缘使得图形显示更好些 plot(dat$mpg, dat$vs) curve(predict(logr_vm, data.frame(mpg=x), type=&quot;response&quot;), add=TRUE) 7.5.2.2 离散预测变量，离散响应变量 这个跟上面的操作大致相同，am是一个离散的预测变量，vs是一个离散的响应变量。 # 执行逻辑回归 logr_va &lt;- glm(vs ~ am, data=dat, family=binomial) # 打印模型信息 logr_va #&gt; #&gt; Call: glm(formula = vs ~ am, family = binomial, data = dat) #&gt; #&gt; Coefficients: #&gt; (Intercept) am #&gt; -0.5390 0.6931 #&gt; #&gt; Degrees of Freedom: 31 Total (i.e. Null); 30 Residual #&gt; Null Deviance: 43.86 #&gt; Residual Deviance: 42.95 AIC: 46.95 # More information about the model summary(logr_va) #&gt; #&gt; Call: #&gt; glm(formula = vs ~ am, family = binomial, data = dat) #&gt; #&gt; Deviance Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -1.2435 -0.9587 -0.9587 1.1127 1.4132 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error z value Pr(&gt;|z|) #&gt; (Intercept) -0.5390 0.4756 -1.133 0.257 #&gt; am 0.6931 0.7319 0.947 0.344 #&gt; #&gt; (Dispersion parameter for binomial family taken to be 1) #&gt; #&gt; Null deviance: 43.860 on 31 degrees of freedom #&gt; Residual deviance: 42.953 on 30 degrees of freedom #&gt; AIC: 46.953 #&gt; #&gt; Number of Fisher Scoring iterations: 4 7.5.2.2.1 画图 尽管图形可能会比连续预测变量的信息少，我们还是可以使用ggplot2或者基本图形绘制逻辑数据和回归结果。因为数据点大致在4个位置，我们可以使用抖动点避免叠加。 library(ggplot2) ggplot(dat, aes(x=am, y=vs)) + geom_point(shape=1, position=position_jitter(width=.05,height=.05)) + stat_smooth(method=&quot;glm&quot;, method.args=list(family=&quot;binomial&quot;), se=FALSE) par(mar = c(4, 4, 1, 1)) # 减少一些边缘使得图形显示更好些 plot(jitter(dat$am, .2), jitter(dat$vs, .2)) curve(predict(logr_va, data.frame(am=x), type=&quot;response&quot;), add=TRUE) 7.5.2.3 连续和离散预测变量，离散响应变量 这跟先前的例子相似，这里mpg是连续预测变量，am是离散预测变量，vs是离散响应变量。 logr_vma &lt;- glm(vs ~ mpg + am, data=dat, family=binomial) logr_vma #&gt; #&gt; Call: glm(formula = vs ~ mpg + am, family = binomial, data = dat) #&gt; #&gt; Coefficients: #&gt; (Intercept) mpg am #&gt; -12.7051 0.6809 -3.0073 #&gt; #&gt; Degrees of Freedom: 31 Total (i.e. Null); 29 Residual #&gt; Null Deviance: 43.86 #&gt; Residual Deviance: 20.65 AIC: 26.65 summary(logr_vma) #&gt; #&gt; Call: #&gt; glm(formula = vs ~ mpg + am, family = binomial, data = dat) #&gt; #&gt; Deviance Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -2.05888 -0.44544 -0.08765 0.33335 1.68405 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error z value Pr(&gt;|z|) #&gt; (Intercept) -12.7051 4.6252 -2.747 0.00602 ** #&gt; mpg 0.6809 0.2524 2.698 0.00697 ** #&gt; am -3.0073 1.5995 -1.880 0.06009 . #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; (Dispersion parameter for binomial family taken to be 1) #&gt; #&gt; Null deviance: 43.860 on 31 degrees of freedom #&gt; Residual deviance: 20.646 on 29 degrees of freedom #&gt; AIC: 26.646 #&gt; #&gt; Number of Fisher Scoring iterations: 6 7.5.2.4 有交互项的多个预测变量 当有多个预测变量时我们可能需要检验交互项。交互项可以单独指定，像a + b + c + a:b + b:c + a:b:c，或者它们可以使用a * b *c自动展开（这两种等效）。如果只是想指定部分可能的交互项，比如a与c有交互项，使用a + b + c + a:c。 # 执行逻辑回归，下面两种方式等效 logr_vmai &lt;- glm(vs ~ mpg * am, data=dat, family=binomial) logr_vmai &lt;- glm(vs ~ mpg + am + mpg:am, data=dat, family=binomial) logr_vmai #&gt; #&gt; Call: glm(formula = vs ~ mpg + am + mpg:am, family = binomial, data = dat) #&gt; #&gt; Coefficients: #&gt; (Intercept) mpg am mpg:am #&gt; -20.4784 1.1084 10.1055 -0.6637 #&gt; #&gt; Degrees of Freedom: 31 Total (i.e. Null); 28 Residual #&gt; Null Deviance: 43.86 #&gt; Residual Deviance: 19.12 AIC: 27.12 summary(logr_vmai) #&gt; #&gt; Call: #&gt; glm(formula = vs ~ mpg + am + mpg:am, family = binomial, data = dat) #&gt; #&gt; Deviance Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -1.70566 -0.31124 -0.04817 0.28038 1.55603 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error z value Pr(&gt;|z|) #&gt; (Intercept) -20.4784 10.5525 -1.941 0.0523 . #&gt; mpg 1.1084 0.5770 1.921 0.0547 . #&gt; am 10.1055 11.9104 0.848 0.3962 #&gt; mpg:am -0.6637 0.6242 -1.063 0.2877 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; (Dispersion parameter for binomial family taken to be 1) #&gt; #&gt; Null deviance: 43.860 on 31 degrees of freedom #&gt; Residual deviance: 19.125 on 28 degrees of freedom #&gt; AIC: 27.125 #&gt; #&gt; Number of Fisher Scoring iterations: 7 7.6 变量同质性 7.6.1 问题 你想要（精确）检验样本的方差同质性（同方差，方差齐性）。许多统计检验假设总体同方差。 7.6.2 方案 有许多检验方差同质性的方式，下面列出三种： Bartlett’s test - 如果数据服从正态分布，这是最好地检验方法。该方法对非正态数据非常敏感，如果数据不是正态的很可能返回假阳性的结果。 Levene’s test - 数据偏离正态性时比Bartlett检验更稳定（鲁棒性更好），内置于car包 Fligner-Killeen test - 这是一个非参数检验，数据偏离正态是非常稳定适用。 对于所有的检验，零假设为总体方差相同（同质；不是相等的意思）；备择假设是至少两组样本（总体方差）不同。 7.6.2.1 样例数据 这里的例子使用了InsectSprays 和 ToothGrowth 数据集。 InsectSprays 数据集有一个独立变量，而 ToothGrowth 数据集有两个独立变量。 head(InsectSprays) #&gt; count spray #&gt; 1 10 A #&gt; 2 7 A #&gt; 3 20 A #&gt; 4 14 A #&gt; 5 14 A #&gt; 6 12 A tg &lt;- ToothGrowth tg$dose &lt;- factor(tg$dose) # Treat this column as a factor, not numeric head(tg) #&gt; len supp dose #&gt; 1 4.2 VC 0.5 #&gt; 2 11.5 VC 0.5 #&gt; 3 7.3 VC 0.5 #&gt; 4 5.8 VC 0.5 #&gt; 5 6.4 VC 0.5 #&gt; 6 10.0 VC 0.5 快速绘制数据集的箱线图： plot(count ~ spray, data = InsectSprays) plot(len ~ interaction(dose,supp), data=ToothGrowth) 初一看好像数据集的方差都不同质，但这需要像下面一样进行合适的检验。 7.6.2.2 Bartlett’s test 有一个独立变量： bartlett.test(count ~ spray, data=InsectSprays) #&gt; #&gt; Bartlett test of homogeneity of variances #&gt; #&gt; data: count by spray #&gt; Bartlett&#39;s K-squared = 25.96, df = 5, p-value = 9.085e-05 # Same effect, but with two vectors, instead of two columns from a data frame # bartlett.test(InsectSprays$count ~ InsectSprays$spray) 有多个独立变量，必须使用interaction()函数将这些独立变量包裹为含所有因子组合的单个变量。如果不适应，那么会得到错误的自由度，因而p值也将是错误的。 bartlett.test(len ~ interaction(supp,dose), data=ToothGrowth) #&gt; #&gt; Bartlett test of homogeneity of variances #&gt; #&gt; data: len by interaction(supp, dose) #&gt; Bartlett&#39;s K-squared = 6.9273, df = 5, p-value = 0.2261 # The above gives the same result as testing len vs. dose alone, without supp bartlett.test(len ~ dose, data=ToothGrowth) #&gt; #&gt; Bartlett test of homogeneity of variances #&gt; #&gt; data: len by dose #&gt; Bartlett&#39;s K-squared = 0.66547, df = 2, p-value = 0.717 7.6.2.3 Levene’s test leveneTest 函数是car 包的一部分。 有一个独立变量： library(car) leveneTest(count ~ spray, data=InsectSprays) #&gt; Levene&#39;s Test for Homogeneity of Variance (center = median) #&gt; Df F value Pr(&gt;F) #&gt; group 5 3.8214 0.004223 ** #&gt; 66 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 有两个独立变量。注意这里 interaction函数不需要，因为该函数用于其他两个检验。 leveneTest(len ~ supp*dose, data=tg) #&gt; Levene&#39;s Test for Homogeneity of Variance (center = median) #&gt; Df F value Pr(&gt;F) #&gt; group 5 1.7086 0.1484 #&gt; 54 7.6.2.4 Fligner-Killeen test 有一个独立变量： fligner.test(count ~ spray, data=InsectSprays) #&gt; #&gt; Fligner-Killeen test of homogeneity of variances #&gt; #&gt; data: count by spray #&gt; Fligner-Killeen:med chi-squared = 14.483, df = 5, p-value = 0.01282 # Same effect, but with two vectors, instead of two columns from a data frame # fligner.test(InsectSprays$count ~ InsectSprays$spray) 当处理多个独立变量时，这个fligner.test 函数有跟bartlett.test相同的行为。必须使用 interaction() 函数。 fligner.test(len ~ interaction(supp,dose), data=ToothGrowth) #&gt; #&gt; Fligner-Killeen test of homogeneity of variances #&gt; #&gt; data: len by interaction(supp, dose) #&gt; Fligner-Killeen:med chi-squared = 7.7488, df = 5, p-value = 0.1706 # The above gives the same result as testing len vs. dose alone, without supp fligner.test(len ~ dose, data=ToothGrowth) #&gt; #&gt; Fligner-Killeen test of homogeneity of variances #&gt; #&gt; data: len by dose #&gt; Fligner-Killeen:med chi-squared = 1.3879, df = 2, p-value = 0.4996 "],
["section-8.html", "第 8 章 图形 8.1 条形图与线图 8.2 绘制均值和误差棒 8.3 ggplot | 绘制分布图 8.4 箱型图 8.5 ggplot|散点图 8.6 ggplot | 标题 8.7 ggplot|坐标轴 8.8 图例 (ggplot2) 8.9 线条 (ggplot2) 8.10 ggplot | 分面 8.11 ggplot |多图 8.12 颜色（ggplot2) 8.13 图形混杂-输出到文件-PDF-PNG-TIFF-SVG 8.14 图形混杂-形状和线形 8.15 图形混杂-字体 8.16 图形混杂-抗混淆位图输出 8.17 标准绘图 | 散点图 8.18 标准绘图|箱线图 8.19 标准绘图|QQ图 8.20 其他有趣图形-相关矩阵", " 第 8 章 图形 8.1 条形图与线图 8.1.1 问题 你想要创建基本的条形图与线图 8.1.2 方案 想要使用ggplot2绘制图形，数据必须是一个数据框，而且必须是长格式。 8.1.2.1 基本图形，离散x-axis 使用条形图，条形的高度通常代表这种不同的东西： 每一组事件的计数，通过stat_bin指定，ggplot2默认使用该选项 数据集中某一列的值，通过stat_identity指定 x axis 高度含义 Common name 连续 计数 直方图 离散 计数 条形图 连续 数值 条形图 离散 数值 条形图 8.1.2.1.1 有值的条形图 这里有一些样例数据 (抽自reshape2包的 tips 数据集): dat &lt;- data.frame( time = factor(c(&quot;Lunch&quot;,&quot;Dinner&quot;), levels=c(&quot;Lunch&quot;,&quot;Dinner&quot;)), total_bill = c(14.89, 17.23) ) dat #&gt; time total_bill #&gt; 1 Lunch 14.89 #&gt; 2 Dinner 17.23 # Load the ggplot2 package library(ggplot2) 在这些例子中，条形的高度代表数据框某一列的值，所以使用stat=&quot;identity&quot; 而不是默认的stat=&quot;bin&quot;。 这里使用的映射变量为： time: x-axis 和有时填充颜色 total_bill: y-axis # 非常基本的条形图 ggplot(data=dat, aes(x=time, y=total_bill)) + geom_bar(stat=&quot;identity&quot;) # 按时间填充颜色 ggplot(data=dat, aes(x=time, y=total_bill, fill=time)) + geom_bar(stat=&quot;identity&quot;) ## 这和上面是一样的结果 # ggplot(data=dat, aes(x=time, y=total_bill)) + # geom_bar(aes(fill=time), stat=&quot;identity&quot;) # 添加黑色的边框线 ggplot(data=dat, aes(x=time, y=total_bill, fill=time)) + geom_bar(colour=&quot;black&quot;, stat=&quot;identity&quot;) # 没有图例，因为这个信息是多余的 ggplot(data=dat, aes(x=time, y=total_bill, fill=time)) + geom_bar(colour=&quot;black&quot;, stat=&quot;identity&quot;) + guides(fill=FALSE) 一个理想的条形图可能是下面这样的： # 添加题目，缩小箱宽，填充颜色，改变轴标签 ggplot(data=dat, aes(x=time, y=total_bill, fill=time)) + geom_bar(colour=&quot;black&quot;, fill=&quot;#DD8888&quot;, width=.8, stat=&quot;identity&quot;) + guides(fill=FALSE) + xlab(&quot;Time of day&quot;) + ylab(&quot;Total bill&quot;) + ggtitle(&quot;Average bill for 2 people&quot;) plot of chunk unnamed-chunk-4 参见 ../Colors (ggplot2) 获取更多关于颜色的信息。 8.1.2.1.2 计数的条形图 在下面例子中，条形高度代表事件的计数。 我们直接使用reshape2的tips数据集。 library(reshape2) # 查看头几行 head(tips) #&gt; total_bill tip sex smoker day time size #&gt; 1 16.99 1.01 Female No Sun Dinner 2 #&gt; 2 10.34 1.66 Male No Sun Dinner 3 #&gt; 3 21.01 3.50 Male No Sun Dinner 3 #&gt; 4 23.68 3.31 Male No Sun Dinner 2 #&gt; 5 24.59 3.61 Female No Sun Dinner 4 #&gt; 6 25.29 4.71 Male No Sun Dinner 4 想要得到一个计数的条形图，不要映射变量到y，使用 stat=&quot;bin&quot; (默认就是这个) 而不是stat=&quot;identity&quot;: # 计数的条形图 ggplot(data=tips, aes(x=day)) + geom_bar(stat=&quot;count&quot;) ## 和上面等同, 因为stat=&quot;bin&quot;是默认 # ggplot(data=tips, aes(x=day)) + # geom_bar() plot of chunk unnamed-chunk-6 8.1.2.2 线图 对于线图，数据点必须分组从而R知道怎么连接这些点。如果只有一组的话，非常简单，设定group=1即可，如果是多组，需要设定分组变量。 下面是使用的映射变量 time: x-axis total_bill: y-axis # 基本的线图 ggplot(data=dat, aes(x=time, y=total_bill, group=1)) + geom_line() ## This would have the same result as above # ggplot(data=dat, aes(x=time, y=total_bill)) + # geom_line(aes(group=1)) # 添加点 ggplot(data=dat, aes(x=time, y=total_bill, group=1)) + geom_line() + geom_point() # 改变线和点的颜色 # 改变线的类型和点的类型，用更粗的线、更大的点 # 用红色填充点 ggplot(data=dat, aes(x=time, y=total_bill, group=1)) + geom_line(colour=&quot;red&quot;, linetype=&quot;dashed&quot;, size=1.5) + geom_point(colour=&quot;red&quot;, size=4, shape=21, fill=&quot;white&quot;) 理想的线图可能像下面这样： # 设定y轴的范围 # 改变轴标签 ggplot(data=dat, aes(x=time, y=total_bill, group=1)) + geom_line() + geom_point() + expand_limits(y=0) + xlab(&quot;Time of day&quot;) + ylab(&quot;Total bill&quot;) + ggtitle(&quot;Average bill for 2 people&quot;) plot of chunk unnamed-chunk-8 8.1.3 有更多变量的图 下面这个数据将用于接下来的例子 dat1 &lt;- data.frame( sex = factor(c(&quot;Female&quot;,&quot;Female&quot;,&quot;Male&quot;,&quot;Male&quot;)), time = factor(c(&quot;Lunch&quot;,&quot;Dinner&quot;,&quot;Lunch&quot;,&quot;Dinner&quot;), levels=c(&quot;Lunch&quot;,&quot;Dinner&quot;)), total_bill = c(13.53, 16.81, 16.24, 17.42) ) dat1 #&gt; sex time total_bill #&gt; 1 Female Lunch 13.53 #&gt; 2 Female Dinner 16.81 #&gt; 3 Male Lunch 16.24 #&gt; 4 Male Dinner 17.42 8.1.3.1 条形图 变量映射： time: x-axis sex: color fill total_bill: y-axis. # 堆积条形图 -- 不常用 ggplot(data=dat1, aes(x=time, y=total_bill, fill=sex)) + geom_bar(stat=&quot;identity&quot;) # 条形图，x轴是time,颜色填充是sex ggplot(data=dat1, aes(x=time, y=total_bill, fill=sex)) + geom_bar(stat=&quot;identity&quot;, position=position_dodge()) ggplot(data=dat1, aes(x=time, y=total_bill, fill=sex)) + geom_bar(stat=&quot;identity&quot;, position=position_dodge(), colour=&quot;black&quot;) # 改变颜色 ggplot(data=dat1, aes(x=time, y=total_bill, fill=sex)) + geom_bar(stat=&quot;identity&quot;, position=position_dodge(), colour=&quot;black&quot;) + scale_fill_manual(values=c(&quot;#999999&quot;, &quot;#E69F00&quot;)) 改变映射是非常容易的 # 条形图，x轴是性别，颜色是时间 ggplot(data=dat1, aes(x=sex, y=total_bill, fill=time)) + geom_bar(stat=&quot;identity&quot;, position=position_dodge(), colour=&quot;black&quot;) plot of chunk unnamed-chunk-11 8.1.3.2 线图 变量映射： time: x-axis sex: line color total_bill: y-axis. 想要绘制多条线，必须指定分组变量。 # 基本的带点线图 ggplot(data=dat1, aes(x=time, y=total_bill, group=sex)) + geom_line() + geom_point() # 将性别映射到颜色 ggplot(data=dat1, aes(x=time, y=total_bill, group=sex, colour=sex)) + geom_line() + geom_point() # 映射性别到不同的点类型 ggplot(data=dat1, aes(x=time, y=total_bill, group=sex, shape=sex)) + geom_line() + geom_point() # 使用更粗的线、更大的点 ggplot(data=dat1, aes(x=time, y=total_bill, group=sex, shape=sex)) + geom_line(size=1.5) + geom_point(size=3, fill=&quot;white&quot;) + scale_shape_manual(values=c(22,21)) 更改颜色和线型变量的映射非常容易： ggplot(data=dat1, aes(x=sex, y=total_bill, group=time, shape=time, color=time)) + geom_line() + geom_point() plot of chunk unnamed-chunk-13 8.1.3.3 完成的例子 完成的例子可能像下面这样 # 一个条形图 ggplot(data=dat1, aes(x=time, y=total_bill, fill=sex)) + geom_bar(colour=&quot;black&quot;, stat=&quot;identity&quot;, position=position_dodge(), size=.3) + # 更粗的线 scale_fill_hue(name=&quot;Sex of payer&quot;) + # 设定图例标题 xlab(&quot;Time of day&quot;) + ylab(&quot;Total bill&quot;) + # 设定轴标签 ggtitle(&quot;Average bill for 2 people&quot;) + # 设定题目 theme_bw() # 一个线图 ggplot(data=dat1, aes(x=time, y=total_bill, group=sex, shape=sex, colour=sex)) + geom_line(aes(linetype=sex), size=1) + # 按性别设定线型 geom_point(size=3, fill=&quot;white&quot;) + # 使用更大的点，并用颜色填充 expand_limits(y=0) + # 将0包含仅y轴 scale_colour_hue(name=&quot;Sex of payer&quot;, # 设定图例标题 l=30) + # 使用更深的颜色 (lightness=30) scale_shape_manual(name=&quot;Sex of payer&quot;, values=c(22,21)) + # scale_linetype_discrete(name=&quot;Sex of payer&quot;) + xlab(&quot;Time of day&quot;) + ylab(&quot;Total bill&quot;) + # 设定轴标签 ggtitle(&quot;Average bill for 2 people&quot;) + # 设定标题 theme_bw() + theme(legend.position=c(.7, .4)) # 图例的位置 为了保证上图的图例一致，必须指定3次。至于为何如此，点击 这里。 8.1.4 使用数值 x-axis datn &lt;- read.table(header=TRUE, text=&#39; supp dose length OJ 0.5 13.23 OJ 1.0 22.70 OJ 2.0 26.06 VC 0.5 7.98 VC 1.0 16.77 VC 2.0 26.14 &#39;) 来自ToothGrowth 数据集。 8.1.4.1 当x-axis作为连续变量时 我们可以用它绘制一个线图 ggplot(data=datn, aes(x=dose, y=length, group=supp, colour=supp)) + geom_line() + geom_point() plot of chunk unnamed-chunk-16 8.1.4.2 当x-axis作为分类变量时 首先，我们要将该变量转换为因子。 # 拷贝数据框并将它转换为因子 datn2 &lt;- datn datn2$dose &lt;- factor(datn2$dose) ggplot(data=datn2, aes(x=dose, y=length, group=supp, colour=supp)) + geom_line() + geom_point() # 使用原始的数据框，但使用factor函数在绘图时转换 ggplot(data=datn, aes(x=factor(dose), y=length, group=supp, colour=supp)) + geom_line() + geom_point() 当连续值作为分类变量使用时，也可以绘制条形图。 ggplot(data=datn2, aes(x=dose, y=length, fill=supp)) + geom_bar(stat=&quot;identity&quot;, position=position_dodge()) ggplot(data=datn, aes(x=factor(dose), y=length, fill=supp)) + geom_bar(stat=&quot;identity&quot;, position=position_dodge()) 8.2 绘制均值和误差棒 8.2.1 问题 你想要为一个数据集绘制均值的误差棒。 8.2.2 方案 想要用ggplot2绘制图形，数据必须是数据框形式，而且是长格式（相对于宽格式）。 如果你的数据需要重构，请参考 this page 获取更多信息。 8.2.2.1 示例数据 下面的示例将使用 ToothGrowth 数据集。注意 dose 在这里是一个数值列， 一些情况下我们将它转换为因子变量将会更加有用。 tg &lt;- ToothGrowth head(tg) #&gt; len supp dose #&gt; 1 4.2 VC 0.5 #&gt; 2 11.5 VC 0.5 #&gt; 3 7.3 VC 0.5 #&gt; 4 5.8 VC 0.5 #&gt; 5 6.4 VC 0.5 #&gt; 6 10.0 VC 0.5 library(ggplot2) 首先，我们必须对数据进行统计汇总。 这可以通过多种方式实现，参考this page. 在这个案例中，我们将使用 summarySE() 函数，该函数代码在本页面的最下方 ( summarySE 函数的代码在使用前必须已经键入)。 # summarySE 函数提供了标准差、标准误以及95%的置信区间 tgc &lt;- summarySE(tg, measurevar=&quot;len&quot;, groupvars=c(&quot;supp&quot;,&quot;dose&quot;)) tgc #&gt; supp dose N len sd se ci #&gt; 1 OJ 0.5 10 13.23 4.459709 1.4102837 3.190283 #&gt; 2 OJ 1.0 10 22.70 3.910953 1.2367520 2.797727 #&gt; 3 OJ 2.0 10 26.06 2.655058 0.8396031 1.899314 #&gt; 4 VC 0.5 10 7.98 2.746634 0.8685620 1.964824 #&gt; 5 VC 1.0 10 16.77 2.515309 0.7954104 1.799343 #&gt; 6 VC 2.0 10 26.14 4.797731 1.5171757 3.432090 8.2.3 线图 数据统计总结后，我们就可以开始绘制图形了。这里是一些带误差棒的线图和点图，误差棒代表标准差、标准误或者是95%的置信区间。 # 均值的标准误 ggplot(tgc, aes(x=dose, y=len, colour=supp)) + geom_errorbar(aes(ymin=len-se, ymax=len+se), width=.1) + geom_line() + geom_point() # 发现误差棒重叠（dose=2.0），我们使用 position_dodge 将它们进行水平移动 pd &lt;- position_dodge(0.1) # move them .05 to the left and right ggplot(tgc, aes(x=dose, y=len, colour=supp)) + geom_errorbar(aes(ymin=len-se, ymax=len+se), width=.1, position=pd) + geom_line(position=pd) + geom_point(position=pd) # 使用95%置信区间替换标准误 ggplot(tgc, aes(x=dose, y=len, colour=supp)) + geom_errorbar(aes(ymin=len-ci, ymax=len+ci), width=.1, position=pd) + geom_line(position=pd) + geom_point(position=pd) # 黑色的误差棒 - 注意&#39;group=supp&#39;的映射 -- 没有它，误差棒将不会避开（就是会重叠）。 ggplot(tgc, aes(x=dose, y=len, colour=supp, group=supp)) + geom_errorbar(aes(ymin=len-ci, ymax=len+ci), colour=&quot;black&quot;, width=.1, position=pd) + geom_line(position=pd) + geom_point(position=pd, size=3) plot of chunk unnamed-chunk-4 plot of chunk unnamed-chunk-4 plot of chunk unnamed-chunk-4 plot of chunk unnamed-chunk-4 一张完成的带误差棒（代表均值的标准误）的图形可能像下面显示的那样。最会画点，这样白色将会在线和误差棒的上面（这个需要理解图层概念，顺序不同展示的效果是不一样的）。 ggplot(tgc, aes(x=dose, y=len, colour=supp, group=supp)) + geom_errorbar(aes(ymin=len-se, ymax=len+se), colour=&quot;black&quot;, width=.1, position=pd) + geom_line(position=pd) + geom_point(position=pd, size=3, shape=21, fill=&quot;white&quot;) + # 21的填充的圆 xlab(&quot;Dose (mg)&quot;) + ylab(&quot;Tooth length&quot;) + scale_colour_hue(name=&quot;Supplement type&quot;, # 图例标签使用暗色 breaks=c(&quot;OJ&quot;, &quot;VC&quot;), labels=c(&quot;Orange juice&quot;, &quot;Ascorbic acid&quot;), l=40) + # 使用暗色，亮度为40 ggtitle(&quot;The Effect of Vitamin C on\\nTooth Growth in Guinea Pigs&quot;) + expand_limits(y=0) + # 扩展范围 scale_y_continuous(breaks=0:20*4) + # 每4个单位设置标记（y轴） theme_bw() + theme(legend.justification=c(1,0), legend.position=c(1,0)) # 右下方放置图例 plot of chunk unnamed-chunk-5 8.2.4 直方图 直方图绘制误差棒也非常相似。 注意 tgc$dose 必须是一个因子。如果它是一个数值向量，将会不起作用。 # 将dose转换为因子变量 tgc2 &lt;- tgc tgc2$dose &lt;- factor(tgc2$dose) # 误差棒代表了均值的标准误 ggplot(tgc2, aes(x=dose, y=len, fill=supp)) + geom_bar(position=position_dodge(), stat=&quot;identity&quot;) + geom_errorbar(aes(ymin=len-se, ymax=len+se), width=.2, # 误差棒的宽度 position=position_dodge(.9)) # 使用95%的置信区间替换标准误 ggplot(tgc2, aes(x=dose, y=len, fill=supp)) + geom_bar(position=position_dodge(), stat=&quot;identity&quot;) + geom_errorbar(aes(ymin=len-ci, ymax=len+ci), width=.2, # 误差棒的宽度 position=position_dodge(.9)) plot of chunk unnamed-chunk-6 plot of chunk unnamed-chunk-6 一张绘制完成的图片像下面这样： ggplot(tgc2, aes(x=dose, y=len, fill=supp)) + geom_bar(position=position_dodge(), stat=&quot;identity&quot;, colour=&quot;black&quot;, # 使用黑色边框, size=.3) + # 将线变细 geom_errorbar(aes(ymin=len-se, ymax=len+se), size=.3, # 将线变细 width=.2, position=position_dodge(.9)) + xlab(&quot;Dose (mg)&quot;) + ylab(&quot;Tooth length&quot;) + scale_fill_hue(name=&quot;Supplement type&quot;, # Legend label, use darker colors breaks=c(&quot;OJ&quot;, &quot;VC&quot;), labels=c(&quot;Orange juice&quot;, &quot;Ascorbic acid&quot;)) + ggtitle(&quot;The Effect of Vitamin C on\\nTooth Growth in Guinea Pigs&quot;) + scale_y_continuous(breaks=0:20*4) + theme_bw() plot of chunk unnamed-chunk-7 8.2.5 为组内变量添加误差棒 当所有的变量都属于不同组别时，我们画标准误或者置信区间会显得非常简单直观。然而，当我们描绘的是组内变量（重复测量），那么添加标准误或者通常的置信区间可能会对不同条件下差异的推断产生误导作用。 下面的方法来自 Morey (2008)，它是对 Cousineau (2005)的矫正，而它所做的就是 提供比 Loftus and Masson (1994)更简单的方法。 你可以查看这些文章，以获得更多对组内变量误差棒问题的详细探讨和方案。 这里有一个组内变量的数据集 (from Morey 2008): pre/post-test。 dfw &lt;- read.table(header=TRUE, text=&#39; subject pretest posttest 1 59.4 64.5 2 46.4 52.4 3 46.0 49.7 4 49.0 48.7 5 32.5 37.4 6 45.2 49.5 7 60.3 59.9 8 54.3 54.1 9 45.4 49.6 10 38.9 48.5 &#39;) # 将物体的ID作为因子变量对待 dfw$subject &lt;- factor(dfw$subject) 第一步是将该数据集转换为长格式。See this page for more information about the conversion. # 转换为长格式 library(reshape2) dfw_long &lt;- melt(dfw, id.vars = &quot;subject&quot;, measure.vars = c(&quot;pretest&quot;,&quot;posttest&quot;), variable.name = &quot;condition&quot;) dfw_long #&gt; subject condition value #&gt; 1 1 pretest 59.4 #&gt; 2 2 pretest 46.4 #&gt; 3 3 pretest 46.0 #&gt; 4 4 pretest 49.0 #&gt; 5 5 pretest 32.5 #&gt; 6 6 pretest 45.2 #&gt; 7 7 pretest 60.3 #&gt; 8 8 pretest 54.3 #&gt; 9 9 pretest 45.4 #&gt; 10 10 pretest 38.9 #&gt; 11 1 posttest 64.5 #&gt; 12 2 posttest 52.4 #&gt; 13 3 posttest 49.7 #&gt; 14 4 posttest 48.7 #&gt; 15 5 posttest 37.4 #&gt; 16 6 posttest 49.5 #&gt; 17 7 posttest 59.9 #&gt; 18 8 posttest 54.1 #&gt; 19 9 posttest 49.6 #&gt; 20 10 posttest 48.5 使用 summarySEwithin函数瓦解数据 (defined at the [bottom](http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#Helper functions) of this page; both of the helper functions below must be entered before the function is called here). dfwc &lt;- summarySEwithin(dfw_long, measurevar=&quot;value&quot;, withinvars=&quot;condition&quot;, idvar=&quot;subject&quot;, na.rm=FALSE, conf.interval=.95) dfwc #&gt; condition N value value_norm sd se ci #&gt; 1 posttest 10 51.43 51.43 2.262361 0.7154214 1.618396 #&gt; 2 pretest 10 47.74 47.74 2.262361 0.7154214 1.618396 library(ggplot2) # Make the graph with the 95% confidence interval ggplot(dfwc, aes(x=condition, y=value, group=1)) + geom_line() + geom_errorbar(width=.1, aes(ymin=value-ci, ymax=value+ci)) + geom_point(shape=21, size=3, fill=&quot;white&quot;) + ylim(40,60) plot of chunk unnamed-chunk-10 value和value_norm 列代表了未标准化和标准化后的值。See the section below on normed means for more information. 8.2.5.1 理解组内变量的误差棒 这部分解释组内的误差棒值是如何计算出来的。这些步骤仅作解释目的；它们对于绘制误差棒是非必需的。 下面独立数据的图形结果展示了组内变量condition存在连续一致的趋势，但使用常规的标准误（或者置信区间）则不能充分地展示这一点。Morey (2008) 和Cousineau (2005)的方法本质是标准化数据去移除组间的变化，计算出这个标准化数据的变异程度。 # Use a consistent y range ymax &lt;- max(dfw_long$value) ymin &lt;- min(dfw_long$value) # Plot the individuals ggplot(dfw_long, aes(x=condition, y=value, colour=subject, group=subject)) + geom_line() + geom_point(shape=21, fill=&quot;white&quot;) + ylim(ymin,ymax) # 创造标准化的版本 dfwNorm.long &lt;- normDataWithin(data=dfw_long, idvar=&quot;subject&quot;, measurevar=&quot;value&quot;) # Plot the normed individuals ggplot(dfwNorm.long, aes(x=condition, y=value_norm, colour=subject, group=subject)) + geom_line() + geom_point(shape=21, fill=&quot;white&quot;) + ylim(ymin,ymax) plot of chunk unnamed-chunk-11 plot of chunk unnamed-chunk-11 针对正常（组间）方法和组内方法的误差棒差异在下面呈现。正常的方法计算出的误差棒用红色表示，组内方法的误差棒用黑色表示。 # Instead of summarySEwithin, use summarySE, which treats condition as though it were a between-subjects variable dfwc_between &lt;- summarySE(data=dfw_long, measurevar=&quot;value&quot;, groupvars=&quot;condition&quot;, na.rm=FALSE, conf.interval=.95) dfwc_between #&gt; condition N value sd se ci #&gt; 1 pretest 10 47.74 8.598992 2.719240 6.151348 #&gt; 2 posttest 10 51.43 7.253972 2.293907 5.189179 # 用红色显示组间的置信区间，用黑色展示组内的置信区间 ggplot(dfwc_between, aes(x=condition, y=value, group=1)) + geom_line() + geom_errorbar(width=.1, aes(ymin=value-ci, ymax=value+ci), colour=&quot;red&quot;) + geom_errorbar(width=.1, aes(ymin=value-ci, ymax=value+ci), data=dfwc) + geom_point(shape=21, size=3, fill=&quot;white&quot;) + ylim(ymin,ymax) plot of chunk unnamed-chunk-12 8.2.5.2 两个组内变量 如果存在超过一个的组内变量，我们可以使用相同的函数summarySEwithin。下面的数据集来自Hays (1994)，在 Rouder and Morey (2005)中用来绘制这类的组内误差棒。 data &lt;- read.table(header=TRUE, text=&#39; Subject RoundMono SquareMono RoundColor SquareColor 1 41 40 41 37 2 57 56 56 53 3 52 53 53 50 4 49 47 47 47 5 47 48 48 47 6 37 34 35 36 7 47 50 47 46 8 41 40 38 40 9 48 47 49 45 10 37 35 36 35 11 32 31 31 33 12 47 42 42 42 &#39;) 数据集首先必须转换为长格式，列名显示了两个变量： shape (round/square) and color scheme (monochromatic/colored). # 转换为长格式 library(reshape2) data_long &lt;- melt(data=data, id.var=&quot;Subject&quot;, measure.vars=c(&quot;RoundMono&quot;, &quot;SquareMono&quot;, &quot;RoundColor&quot;, &quot;SquareColor&quot;), variable.name=&quot;Condition&quot;) names(data_long)[names(data_long)==&quot;value&quot;] &lt;- &quot;Time&quot; # 拆分 Condition 列为 Shape and ColorScheme data_long$Shape &lt;- NA data_long$Shape[grepl(&quot;^Round&quot;, data_long$Condition)] &lt;- &quot;Round&quot; data_long$Shape[grepl(&quot;^Square&quot;, data_long$Condition)] &lt;- &quot;Square&quot; data_long$Shape &lt;- factor(data_long$Shape) data_long$ColorScheme &lt;- NA data_long$ColorScheme[grepl(&quot;Mono$&quot;, data_long$Condition)] &lt;- &quot;Monochromatic&quot; data_long$ColorScheme[grepl(&quot;Color$&quot;, data_long$Condition)] &lt;- &quot;Colored&quot; data_long$ColorScheme &lt;- factor(data_long$ColorScheme, levels=c(&quot;Monochromatic&quot;,&quot;Colored&quot;)) # 现在移除 Condition column data_long$Condition &lt;- NULL # 检查数据 head(data_long) #&gt; Subject Time Shape ColorScheme #&gt; 1 1 41 Round Monochromatic #&gt; 2 2 57 Round Monochromatic #&gt; 3 3 52 Round Monochromatic #&gt; 4 4 49 Round Monochromatic #&gt; 5 5 47 Round Monochromatic #&gt; 6 6 37 Round Monochromatic 现在可以进行统计汇总和绘图了。 datac &lt;- summarySEwithin(data_long, measurevar=&quot;Time&quot;, withinvars=c(&quot;Shape&quot;,&quot;ColorScheme&quot;), idvar=&quot;Subject&quot;) datac #&gt; Shape ColorScheme N Time Time_norm sd se ci #&gt; 1 Round Colored 12 43.58333 43.58333 1.212311 0.3499639 0.7702654 #&gt; 2 Round Monochromatic 12 44.58333 44.58333 1.331438 0.3843531 0.8459554 #&gt; 3 Square Colored 12 42.58333 42.58333 1.461630 0.4219364 0.9286757 #&gt; 4 Square Monochromatic 12 43.58333 43.58333 1.261312 0.3641095 0.8013997 library(ggplot2) ggplot(datac, aes(x=Shape, y=Time, fill=ColorScheme)) + geom_bar(position=position_dodge(.9), colour=&quot;black&quot;, stat=&quot;identity&quot;) + geom_errorbar(position=position_dodge(.9), width=.25, aes(ymin=Time-ci, ymax=Time+ci)) + coord_cartesian(ylim=c(40,46)) + scale_fill_manual(values=c(&quot;#CCCCCC&quot;,&quot;#FFFFFF&quot;)) + scale_y_continuous(breaks=seq(1:100)) + theme_bw() + geom_hline(yintercept=38) plot of chunk unnamed-chunk-15 8.2.6 注意标准化的均值 函数 summarySEWithin 返回标准化和未标准化的均值。未标准化的均值只是简单地表示每组的均值。标准化的均值计算出来保证组间的均值是一样的。 These values can diverge when there are between-subject variables. 比如： dat &lt;- read.table(header=TRUE, text=&#39; id trial gender dv A 0 male 2 A 1 male 4 B 0 male 6 B 1 male 8 C 0 female 22 C 1 female 24 D 0 female 26 D 1 female 28 &#39;) # 标准化和未标准化的均值是不同的 summarySEwithin(dat, measurevar=&quot;dv&quot;, withinvars=&quot;trial&quot;, betweenvars=&quot;gender&quot;, idvar=&quot;id&quot;) #&gt; Automatically converting the following non-factors to factors: trial #&gt; gender trial N dv dv_norm sd se ci #&gt; 1 female 0 2 24 14 0 0 0 #&gt; 2 female 1 2 26 16 0 0 0 #&gt; 3 male 0 2 4 14 0 0 0 #&gt; 4 male 1 2 6 16 0 0 0 8.2.7 助手函数 如果你处理的仅仅是组间变量，那么summarySE是你代码中唯一需要使用的函数。如果你的数据里有组内变量，并且你想要矫正误差棒使得组间的变异被移除，就像 Loftus and Masson (1994)里的那样，那么normDataWithin 和 summarySEwithin这两个函数必须加入你的代码中，然后调用summarySEwithin 函数进行计算。 ## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%). ## data: a data frame. ## measurevar: the name of a column that contains the variable to be summariezed ## groupvars: a vector containing names of columns that contain grouping variables ## na.rm: a boolean that indicates whether to ignore NA&#39;s ## conf.interval: the percent range of the confidence interval (default is 95%) summarySE &lt;- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE) { library(plyr) # New version of length which can handle NA&#39;s: if na.rm==T, don&#39;t count them length2 &lt;- function (x, na.rm=FALSE) { if (na.rm) sum(!is.na(x)) else length(x) } # This does the summary. For each group&#39;s data frame, return a vector with # N, mean, and sd datac &lt;- ddply(data, groupvars, .drop=.drop, .fun = function(xx, col) { c(N = length2(xx[[col]], na.rm=na.rm), mean = mean (xx[[col]], na.rm=na.rm), sd = sd (xx[[col]], na.rm=na.rm) ) }, measurevar ) # Rename the &quot;mean&quot; column datac &lt;- rename(datac, c(&quot;mean&quot; = measurevar)) datac$se &lt;- datac$sd / sqrt(datac$N) # Calculate standard error of the mean # Confidence interval multiplier for standard error # Calculate t-statistic for confidence interval: # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1 ciMult &lt;- qt(conf.interval/2 + .5, datac$N-1) datac$ci &lt;- datac$se * ciMult return(datac) } ## Norms the data within specified groups in a data frame; it normalizes each ## subject (identified by idvar) so that they have the same mean, within each group ## specified by betweenvars. ## data: a data frame. ## idvar: the name of a column that identifies each subject (or matched subjects) ## measurevar: the name of a column that contains the variable to be summariezed ## betweenvars: a vector containing names of columns that are between-subjects variables ## na.rm: a boolean that indicates whether to ignore NA&#39;s normDataWithin &lt;- function(data=NULL, idvar, measurevar, betweenvars=NULL, na.rm=FALSE, .drop=TRUE) { library(plyr) # Measure var on left, idvar + between vars on right of formula. data.subjMean &lt;- ddply(data, c(idvar, betweenvars), .drop=.drop, .fun = function(xx, col, na.rm) { c(subjMean = mean(xx[,col], na.rm=na.rm)) }, measurevar, na.rm ) # Put the subject means with original data data &lt;- merge(data, data.subjMean) # Get the normalized data in a new column measureNormedVar &lt;- paste(measurevar, &quot;_norm&quot;, sep=&quot;&quot;) data[,measureNormedVar] &lt;- data[,measurevar] - data[,&quot;subjMean&quot;] + mean(data[,measurevar], na.rm=na.rm) # Remove this subject mean column data$subjMean &lt;- NULL return(data) } ## Summarizes data, handling within-subjects variables by removing inter-subject variability. ## It will still work if there are no within-S variables. ## Gives count, un-normed mean, normed mean (with same between-group mean), ## standard deviation, standard error of the mean, and confidence interval. ## If there are within-subject variables, calculate adjusted values using method from Morey (2008). ## data: a data frame. ## measurevar: the name of a column that contains the variable to be summariezed ## betweenvars: a vector containing names of columns that are between-subjects variables ## withinvars: a vector containing names of columns that are within-subjects variables ## idvar: the name of a column that identifies each subject (or matched subjects) ## na.rm: a boolean that indicates whether to ignore NA&#39;s ## conf.interval: the percent range of the confidence interval (default is 95%) summarySEwithin &lt;- function(data=NULL, measurevar, betweenvars=NULL, withinvars=NULL, idvar=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE) { # Ensure that the betweenvars and withinvars are factors factorvars &lt;- vapply(data[, c(betweenvars, withinvars), drop=FALSE], FUN=is.factor, FUN.VALUE=logical(1)) if (!all(factorvars)) { nonfactorvars &lt;- names(factorvars)[!factorvars] message(&quot;Automatically converting the following non-factors to factors: &quot;, paste(nonfactorvars, collapse = &quot;, &quot;)) data[nonfactorvars] &lt;- lapply(data[nonfactorvars], factor) } # Get the means from the un-normed data datac &lt;- summarySE(data, measurevar, groupvars=c(betweenvars, withinvars), na.rm=na.rm, conf.interval=conf.interval, .drop=.drop) # Drop all the unused columns (these will be calculated with normed data) datac$sd &lt;- NULL datac$se &lt;- NULL datac$ci &lt;- NULL # Norm each subject&#39;s data ndata &lt;- normDataWithin(data, idvar, measurevar, betweenvars, na.rm, .drop=.drop) # This is the name of the new column measurevar_n &lt;- paste(measurevar, &quot;_norm&quot;, sep=&quot;&quot;) # Collapse the normed data - now we can treat between and within vars the same ndatac &lt;- summarySE(ndata, measurevar_n, groupvars=c(betweenvars, withinvars), na.rm=na.rm, conf.interval=conf.interval, .drop=.drop) # Apply correction from Morey (2008) to the standard error and confidence interval # Get the product of the number of conditions of within-S variables nWithinGroups &lt;- prod(vapply(ndatac[,withinvars, drop=FALSE], FUN=nlevels, FUN.VALUE=numeric(1))) correctionFactor &lt;- sqrt( nWithinGroups / (nWithinGroups-1) ) # Apply the correction factor ndatac$sd &lt;- ndatac$sd * correctionFactor ndatac$se &lt;- ndatac$se * correctionFactor ndatac$ci &lt;- ndatac$ci * correctionFactor # Combine the un-normed means with the normed results merge(datac, ndatac) } 原文链接：&lt; http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/&gt; 8.2.8 其他 解决问题的方法不止作者提供的这一种，为了理解ggplot2是如何进行误差棒的计算和添加，我在stackoverflow上提交了一个关于ggplot2使用SE还是SD作为默认误差棒的问题。有人就提出了快速简易的解答。回答者的共同观点是必须先进行数据的统计计算。我之前在其他博客上看到的使用stat_boxplot(geom=&quot;errorbar&quot;, width=.3)直接计算误差棒可能就有问题（难以解释它算的是SD还是SE，我没有在帮助文档找到解释，我也不知道函数内部是如何计算的）。 8.3 ggplot | 绘制分布图 8.3.1 问题 你想要绘制一组数据的分布图。 8.3.2 方案 后面的例子中会使用以下这组简单的数据： set.seed(1234) dat &lt;- data.frame(cond = factor(rep(c(&quot;A&quot;,&quot;B&quot;), each=200)), rating = c(rnorm(200),rnorm(200, mean=.8))) # 查看数据 head(dat) #&gt; cond rating #&gt; 1 A -1.2070657 #&gt; 2 A 0.2774292 #&gt; 3 A 1.0844412 #&gt; 4 A -2.3456977 #&gt; 5 A 0.4291247 #&gt; 6 A 0.5060559 library(ggplot2) 8.3.3 直方图和概率密度图 qplot 函数能够用更简单的语法绘制出与 ggplot 相同的图像。然而，在实践过程中你会发现 ggplot是更好的选择，因为 qplot 中很多参数的选项都会让人感到困惑。 ## 以 rating 为横轴绘制直方图，组距设为 0.5 ## 两种函数都可以绘制出相同的图: ggplot(dat, aes(x=rating)) + geom_histogram(binwidth=.5) # qplot(dat$rating, binwidth=.5) # 绘制黑色边线，白色填充的图 ggplot(dat, aes(x=rating)) + geom_histogram(binwidth=.5, colour=&quot;black&quot;, fill=&quot;white&quot;) # 密度曲线 ggplot(dat, aes(x=rating)) + geom_density() # 直方图与核密度曲线重叠 ggplot(dat, aes(x=rating)) + geom_histogram(aes(y=..density..), # 这里直方图以 density (密度)为y轴 binwidth=.5, colour=&quot;black&quot;, fill=&quot;white&quot;) + geom_density(alpha=.2, fill=&quot;#FF6666&quot;) # 重合部分透明填充 添加一条均值线 ggplot(dat, aes(x=rating)) + geom_histogram(binwidth=.5, colour=&quot;black&quot;, fill=&quot;white&quot;) + geom_vline(aes(xintercept=mean(rating, na.rm=T)), # 忽略缺失值 color=&quot;red&quot;, linetype=&quot;dashed&quot;, size=1) plot of chunk unnamed-chunk-4 8.3.4 多组数据的直方图和概率密度图 # 重叠直方图 ggplot(dat, aes(x=rating, fill=cond)) + geom_histogram(binwidth=.5, alpha=.5, position=&quot;identity&quot;) # identity 表示将每个对象直接显示在图中，条形会彼此重叠。 # 间隔直方图 ggplot(dat, aes(x=rating, fill=cond)) + geom_histogram(binwidth=.5, position=&quot;dodge&quot;) # dodge 表示将每组的条形依次并列放置。 # 密度图 ggplot(dat, aes(x=rating, colour=cond)) + geom_density() # 半透明填充的密度图 ggplot(dat, aes(x=rating, fill=cond)) + geom_density(alpha=.3) 在给每组数据添加均值线前，需要将每组数据的平均值赋值到一个新的数据框。 # 求均值 library(plyr) cdat &lt;- ddply(dat, &quot;cond&quot;, summarise, rating.mean=mean(rating)) cdat #&gt; cond rating.mean #&gt; 1 A -0.05775928 #&gt; 2 B 0.87324927 # 给重叠直方图添加均值线 ggplot(dat, aes(x=rating, fill=cond)) + geom_histogram(binwidth=.5, alpha=.5, position=&quot;identity&quot;) + geom_vline(data=cdat, aes(xintercept=rating.mean, colour=cond), linetype=&quot;dashed&quot;, size=1) # 给密度图添加均值线 ggplot(dat, aes(x=rating, colour=cond)) + geom_density() + geom_vline(data=cdat, aes(xintercept=rating.mean, colour=cond), linetype=&quot;dashed&quot;, size=1) 使用分面： ggplot(dat, aes(x=rating)) + geom_histogram(binwidth=.5, colour=&quot;black&quot;, fill=&quot;white&quot;) + facet_grid(cond ~ .) # 使用之前的 cdat 添加均值线 ggplot(dat, aes(x=rating)) + geom_histogram(binwidth=.5, colour=&quot;black&quot;, fill=&quot;white&quot;) + facet_grid(cond ~ .) + geom_vline(data=cdat, aes(xintercept=rating.mean), linetype=&quot;dashed&quot;, size=1, colour=&quot;red&quot;) plot of chunk unnamed-chunk-7 plot of chunk unnamed-chunk-7 更多关于分面的细节可查看Facets (ggplot2) 8.4 箱型图 # 绘制箱型图 ggplot(dat, aes(x=cond, y=rating)) + geom_boxplot() # 对分组填充颜色 ggplot(dat, aes(x=cond, y=rating, fill=cond)) + geom_boxplot() # 将上图中冗余的图例删除掉： ggplot(dat, aes(x=cond, y=rating, fill=cond)) + geom_boxplot() + guides(fill=FALSE) # 坐标轴翻转 ggplot(dat, aes(x=cond, y=rating, fill=cond)) + geom_boxplot() + guides(fill=FALSE) + coord_flip() 同时可以通过 stat_summary 来添加平均值。 # 用菱形图标指征平均值，并调整参数使该图标变更大。 ggplot(dat, aes(x=cond, y=rating)) + geom_boxplot() + stat_summary(fun.y=mean, geom=&quot;point&quot;, shape=5, size=4) plot of chunk unnamed-chunk-9 8.5 ggplot|散点图 8.5.1 问题 你想要绘制一幅散点图。 8.5.2 方案 假设这是你的数据： set.seed(955) #创建一些噪声数据 dat &lt;- data.frame(cond = rep(c(&quot;A&quot;, &quot;B&quot;), each=10), xvar = 1:20 + rnorm(20,sd=3), yvar = 1:20 + rnorm(20,sd=3)) head(dat) #&gt; cond xvar yvar #&gt; 1 A -4.252354 3.473157275 #&gt; 2 A 1.702318 0.005939612 #&gt; 3 A 4.323054 -0.094252427 #&gt; 4 A 1.780628 2.072808278 #&gt; 5 A 11.537348 1.215440358 #&gt; 6 A 6.672130 3.608111411 library(ggplot2) 8.5.2.1 带回归线的基本散点图 ggplot(dat, aes(x=xvar, y=yvar)) + geom_point(shape=1) # 使用空心圆 ggplot(dat, aes(x=xvar, y=yvar)) + geom_point(shape=1) + # 使用空心圆 geom_smooth(method=lm) # 添加回归线 # (默认包含95%置信区间) ggplot(dat, aes(x=xvar, y=yvar)) + geom_point(shape=1) + # 使用空心圆 geom_smooth(method=lm, # 添加回归线 se=FALSE) # 不加置信区域 ggplot(dat, aes(x=xvar, y=yvar)) + geom_point(shape=1) + # 使用空心圆 geom_smooth() # 添加带置信区间的平滑拟合曲线 #&gt; `geom_smooth()` using method = &#39;loess&#39; 8.5.2.2 通过其他变量设置颜色和形状 # 根据cond设置颜色 ggplot(dat, aes(x=xvar, y=yvar, color=cond)) + geom_point(shape=1) # 同上，但这里带了回归线 ggplot(dat, aes(x=xvar, y=yvar, color=cond)) + geom_point(shape=1) + scale_colour_hue(l=50) + # 使用稍暗的调色板 geom_smooth(method=lm, se=FALSE) # 拓展回归线到数据区域之外（带预测效果） ggplot(dat, aes(x=xvar, y=yvar, color=cond)) + geom_point(shape=1) + scale_colour_hue(l=50) + geom_smooth(method=lm, se=FALSE, fullrange=TRUE) # 根据cond设置形状 ggplot(dat, aes(x=xvar, y=yvar, shape=cond)) + geom_point() # 同上，但形状不同 ggplot(dat, aes(x=xvar, y=yvar, shape=cond)) + geom_point() + scale_shape_manual(values=c(1,2)) # 使用圆和三角形 阅读 Colors (ggplot2) 和Shapes and line types](http://www.cookbook-r.com/Graphs/Shapes_and_line_types) 获取更多信息 8.5.2.3 处理图像元素叠加 如果你有很多数据点，或者你的数据是离散的，那么数据可能会覆盖到一起，这样就看不清楚同一个位置有多少数据了。 # 取近似值 dat$xrnd &lt;- round(dat$xvar/5)*5 dat$yrnd &lt;- round(dat$yvar/5)*5 # 让每个点都部分透明 # 如果情况严重，可以使用更小的值 ggplot(dat, aes(x=xrnd, y=yrnd)) + geom_point(shape=19, alpha=1/4) # 抖动点 # 抖动范围在x轴上是1，y轴上是0.5 ggplot(dat, aes(x=xrnd, y=yrnd)) + geom_point(shape=1, position=position_jitter(width=1,height=.5)) 8.6 ggplot | 标题 8.6.1 问题 你想给图形设定一个标题。 8.6.2 方案 一个不带标题的图形例子： library(ggplot2) bp &lt;- ggplot(PlantGrowth, aes(x=group, y=weight)) + geom_boxplot() bp plot of chunk unnamed-chunk-2 添加标题 bp + ggtitle(&quot;Plant growth&quot;) ## 等同于 # bp + labs(title=&quot;Plant growth&quot;) # 如果标题比较长，可以用 \\n 将它分成多行来显示 bp + ggtitle(&quot;Plant growth with\\ndifferent treatments&quot;) # 缩少行距并使用粗体 bp + ggtitle(&quot;Plant growth with\\ndifferent treatments&quot;) + theme(plot.title = element_text(lineheight=.8, face=&quot;bold&quot;)) 8.7 ggplot|坐标轴 8.7.1 问题 你想要改变轴的顺序或方向。 8.7.2 方案 注意：下面的例子中提到的scale_y_continuous、ylim等，y都可以替换为x。 下面使用内置的PlantGrowth数据集绘制一个基本的箱线图。 library(ggplot2) bp &lt;- ggplot(PlantGrowth, aes(x=group, y=weight)) + geom_boxplot() bp plot of chunk unnamed-chunk-2 8.7.2.1 交换x和y轴 交换x和y轴（让x垂直、y水平） bp + coord_flip() plot of chunk unnamed-chunk-3 8.7.2.2 离散轴 8.7.2.2.1 改变条目的顺序 # 手动设定离散轴条目的顺序 bp + scale_x_discrete(limits=c(&quot;trt1&quot;,&quot;trt2&quot;,&quot;ctrl&quot;)) ## 逆转轴条目顺序 # 获取因子水平 flevels &lt;- levels(PlantGrowth$group) flevels #&gt; [1] &quot;ctrl&quot; &quot;trt1&quot; &quot;trt2&quot; # 逆转顺序 flevels &lt;- rev(flevels) flevels #&gt; [1] &quot;trt2&quot; &quot;trt1&quot; &quot;ctrl&quot; bp + scale_x_discrete(limits=flevels) # 或者一行搞定 bp + scale_x_discrete(limits = rev(levels(PlantGrowth$group))) 8.7.2.2.2 设定标签 对于离散变量，标签来自于因子水平。然而，有时候短的因子水平名字并不适合展示。 bp + scale_x_discrete(breaks=c(&quot;ctrl&quot;, &quot;trt1&quot;, &quot;trt2&quot;), labels=c(&quot;Control&quot;, &quot;Treat 1&quot;, &quot;Treat 2&quot;)) plot of chunk unnamed-chunk-5 # 隐藏x刻度、标签和网格线 bp + scale_x_discrete(breaks=NULL) # 隐藏所有的刻度和标签（X轴），保留网格线 bp + theme(axis.ticks = element_blank(), axis.text.x = element_blank()) 8.7.2.3 连续轴 8.7.2.3.1 设定范围和反转轴方向 如果你仅想简单地让轴包含某个值，可以使用expand_limits()，它会进行拓展而不是拉伸。 # 确保y轴包含0 bp + expand_limits(y=0) # 确保y轴包含0和8 bp + expand_limits(y=c(0,8)) 当然你也可以通过y刻度显式地指定。注意如果使用任何scale_y_continuous 命令，它会覆盖任何ylim命令，而且ylim会被忽略。 ## 设定连续值轴的范围 # 下面是相等的操作 bp + ylim(0, 8) # bp + scale_y_continuous(limits=c(0, 8)) plot of chunk unnamed-chunk-8 如果使用上述方法让y轴的范围变小，任何超出范围的数据都会被忽略。有时候这会产生一些问题，读者需要注意。 为了避免产生问题，你可以使用 coord_cartesian ，相比于设定轴的范围，它设定数据可视化的区域。 ## 这两个操作一致，超出范围的数据被删除了，导致产生一个误导的箱线图 bp + ylim(5, 7.5) #&gt; Warning: Removed 13 rows containing non-finite values (stat_boxplot). # bp + scale_y_continuous(limits=c(5, 7.5)) # 使用coord_cartesian &quot;zooms&quot;区域 bp + coord_cartesian(ylim=c(5, 7.5)) # 直接指定刻度 bp + coord_cartesian(ylim=c(5, 7.5)) + scale_y_continuous(breaks=seq(0, 10, 0.25)) # Ticks from 0-10, every .25 8.7.2.3.2 反转轴方向 # 反转一个连续值轴的方向 bp + scale_y_reverse() plot of chunk unnamed-chunk-10 8.7.2.3.3 设置和隐藏刻度标记 # Setting the tick marks on an axis # This will show tick marks on every 0.25 from 1 to 10 # The scale will show only the ones that are within range (3.50-6.25 in this case) bp + scale_y_continuous(breaks=seq(1,10,1/4)) # 刻度不平等变化 bp + scale_y_continuous(breaks=c(4, 4.25, 4.5, 5, 6,8)) # 抑制标签和网格线 bp + scale_y_continuous(breaks=NULL) # Hide tick marks and labels (on Y axis), but keep the gridlines bp + theme(axis.ticks = element_blank(), axis.text.y = element_blank()) 8.7.2.3.4 轴转log、sqrt等 默认轴是线性坐标，我们也可以将它转换为log、幂、根等等。 有两种办法可以转换一个轴，一是使用scale进行转换，另外是使用coordinate进行转换。使用前者需要在先弄好刻度和轴的范围之前转换，而使用后者则相反，需要在弄好刻度和轴范围之后转换。这将产生不太一样的显示效果，如下所示。 # 创建指数分布数据 set.seed(201) n &lt;- 100 dat &lt;- data.frame( xval = (1:n+rnorm(n,sd=5))/20, yval = 2*2^((1:n+rnorm(n,sd=5))/20) ) # 创建常规的散点图 sp &lt;- ggplot(dat, aes(xval, yval)) + geom_point() sp # log2比例化（间隔相等） library(scales) # 需要scales包 sp + scale_y_continuous(trans=log2_trans()) # log2坐标转换，空间间隔不同 sp + coord_trans(y=&quot;log2&quot;) 在标度转换中，我们还可以指定刻度值，让它们显示指数。 sp + scale_y_continuous(trans = log2_trans(), breaks = trans_breaks(&quot;log2&quot;, function(x) 2^x), labels = trans_format(&quot;log2&quot;, math_format(2^.x))) plot of chunk unnamed-chunk-13 可以使用非常多的转换，参见 ?trans_new 查看所有可用转换的列表。如果你所需要的转换不在该列表上，可以自己写一个转换函数。 有一些非常便捷的函数：scale_y_log10和scale_y_sqrt （有对应的x版本）。 set.seed(205) n &lt;- 100 dat10 &lt;- data.frame( xval = (1:n+rnorm(n,sd=5))/20, yval = 10*10^((1:n+rnorm(n,sd=5))/20) ) sp10 &lt;- ggplot(dat10, aes(xval, yval)) + geom_point() # log10 sp10 + scale_y_log10() # log10 with exponents on tick labels sp10 + scale_y_log10(breaks = trans_breaks(&quot;log10&quot;, function(x) 10^x), labels = trans_format(&quot;log10&quot;, math_format(10^.x))) 8.7.2.3.5 x与y轴固定的比例 设置x与y轴比例宽度也是可以的。 # x范围0-10, y范围0-30 set.seed(202) dat &lt;- data.frame( xval = runif(40,0,10), yval = runif(40,0,30) ) sp &lt;- ggplot(dat, aes(xval, yval)) + geom_point() # 强制比例相等 sp + coord_fixed() # 相等的标度变化，让x的1个单位等同y的3个单位 sp + coord_fixed(ratio=1/3) 8.7.2.4 轴标签和文字格式化 设置和隐藏轴标签： bp + theme(axis.title.x = element_blank()) + # 移除x轴标签 ylab(&quot;Weight (Kg)&quot;) # 设置y轴标签 # 也可以通过标度设置 # 注意这里x轴标签的空间仍然保留 bp + scale_x_discrete(name=&quot;&quot;) + scale_y_continuous(name=&quot;Weight (Kg)&quot;) 改变字体、颜色、旋转刻度标签： # Change font options: # X-axis label: bold, red, and 20 points # X-axis tick marks: rotate 90 degrees CCW, move to the left a bit (using vjust, # since the labels are rotated), and 16 points bp + theme(axis.title.x = element_text(face=&quot;bold&quot;, colour=&quot;#990000&quot;, size=20), axis.text.x = element_text(angle=90, vjust=0.5, size=16)) plot of chunk unnamed-chunk-17 8.7.2.5 刻度标签 你可能想将值显示为百分比、或美元、或科学计数法。这里可以使用格式器，它是一个可以改变文本的函数。 # 标签格式器 library(scales) # 需要scales包 bp + scale_y_continuous(labels=percent) + scale_x_discrete(labels=abbreviate) # 在这个例子中它没作用 plot of chunk unnamed-chunk-18 连续标度格式器有comma、percent、dollar以及scientific。离散标度格式器有abbreviate、date_format等。 有时你需要自己创建格式化函数。下面的函数可以显示时间格式为HH:MM:SS。 # 自定义时间格式化函数 timeHMS_formatter &lt;- function(x) { h &lt;- floor(x/60) m &lt;- floor(x %% 60) s &lt;- round(60*(x %% 1)) # Round to nearest second lab &lt;- sprintf(&#39;%02d:%02d:%02d&#39;, h, m, s) # Format the strings as HH:MM:SS lab &lt;- gsub(&#39;^00:&#39;, &#39;&#39;, lab) # Remove leading 00: if present lab &lt;- gsub(&#39;^0&#39;, &#39;&#39;, lab) # Remove leading 0 if present } bp + scale_y_continuous(label=timeHMS_formatter) plot of chunk unnamed-chunk-19 8.7.2.6 隐藏网格线 隐藏网格线： # 隐藏所有网格线 bp + theme(panel.grid.minor=element_blank(), panel.grid.major=element_blank()) # 仅隐藏次级网格线 bp + theme(panel.grid.minor=element_blank()) 也可以仅隐藏水平或垂直网格线： # 隐藏所有垂直网格线 bp + theme(panel.grid.minor.x=element_blank(), panel.grid.major.x=element_blank()) # 隐藏所有水平网格线 bp + theme(panel.grid.minor.y=element_blank(), panel.grid.major.y=element_blank()) 8.8 图例 (ggplot2) 8.8.1 问题 你想用ggplot2修改图表中的图例。 8.8.2 解决方案 从带有默认选项的示例图开始： library(ggplot2) bp &lt;- ggplot(data=PlantGrowth, aes(x=group, y=weight, fill=group)) + geom_boxplot() bp plot of chunk unnamed-chunk-2 8.8.2.1 去除图例 使用 guides(fill=FALSE), 用想要的颜色替代填充色. 你也可以用theme 移除图表中所有的图例。 # 删除特定美学的图例（填充） bp + guides(fill=FALSE) # 在指定比例时也可以这样做 bp + scale_fill_discrete(guide=FALSE) # 这将移除所有的图例 bp + theme(legend.position=&quot;none&quot;) plot of chunk unnamed-chunk-4 8.8.2.2 在图例中改变变量的顺序 这会将变量的顺序更改为trt1，ctrl，trt2: bp + scale_fill_discrete(breaks=c(&quot;trt1&quot;,&quot;ctrl&quot;,&quot;trt2&quot;)) plot of chunk unnamed-chunk-5 根据指定颜色的方式，你可能必须使用不同的比例，例如 scale_fill_manual, scale_colour_hue, scale_colour_manual, scale_shape_discrete, scale_linetype_discrete 等等 8.8.2.3 反转图例中的条目顺序 反转图例顺序: # 这两种方式等同: bp + guides(fill = guide_legend(reverse=TRUE)) bp + scale_fill_discrete(guide = guide_legend(reverse=TRUE)) # 你也可以直接修改比例尺： bp + scale_fill_discrete(breaks = rev(levels(PlantGrowth$group))) plot of chunk unnamed-chunk-7 你可以使用不同的比例尺，例如 scale_fill_manual, scale_colour_hue, scale_colour_manual, scale_shape_discrete, scale_linetype_discrete等等，而不是scale_fill_discrete 8.8.2.4 隐藏图例标题 这将隐藏图例标题: # 为了填充的图例移除标题 bp + guides(fill=guide_legend(title=NULL)) # 为了所有的图例移除标题 bp + theme(legend.title=element_blank()) plot of chunk unnamed-chunk-9 8.8.2.5 修改图例标题和标签的文字 有两种方法可以更改图例标题和标签。 第一种方法是告诉* scale *使用具有不同的标题和标签。 第二种方法是更改数据框，使因子具有所需的形式。 8.8.2.5.1 使用比例尺 图例可能由 fill, colour, linetype, shape, 或其他因素所介导. 8.8.2.5.2 使用填充和颜色 因为图例中的变量group被映射到颜色fill，所以必须使用scale_fill_xxx，其中xxx是将group的每个因子级别映射到不同颜色的方法。 默认设置是在每个因子级别的色轮上使用不同的色调，但也可以手动指定每个级别的颜色。 bp + scale_fill_discrete(name=&quot;Experimental\\nCondition&quot;) bp + scale_fill_discrete(name=&quot;Experimental\\nCondition&quot;, breaks=c(&quot;ctrl&quot;, &quot;trt1&quot;, &quot;trt2&quot;), labels=c(&quot;Control&quot;, &quot;Treatment 1&quot;, &quot;Treatment 2&quot;)) # 使用手动刻度而不是色调 bp + scale_fill_manual(values=c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;), name=&quot;Experimental\\nCondition&quot;, breaks=c(&quot;ctrl&quot;, &quot;trt1&quot;, &quot;trt2&quot;), labels=c(&quot;Control&quot;, &quot;Treatment 1&quot;, &quot;Treatment 2&quot;)) 请注意，这并未更改x轴标签。 有关如何修改轴标签的信息，请参见Axes (ggplot2)。 如果使用折线图，则可能需要使用scale_colour_xxx和/或scale_shape_xxx而不是scale_fill_xxx。 颜色映射到线条和点的颜色，而填充映射到区域填充的颜色。 形状映射到点的形状。 我们将在这里为线图使用不同的数据集，因为PlantGrowth数据集不适用于折线图。 # 一个不同的数据集 df1 &lt;- data.frame( sex = factor(c(&quot;Female&quot;,&quot;Female&quot;,&quot;Male&quot;,&quot;Male&quot;)), time = factor(c(&quot;Lunch&quot;,&quot;Dinner&quot;,&quot;Lunch&quot;,&quot;Dinner&quot;), levels=c(&quot;Lunch&quot;,&quot;Dinner&quot;)), total_bill = c(13.53, 16.81, 16.24, 17.42) ) # 基本的图表 lp &lt;- ggplot(data=df1, aes(x=time, y=total_bill, group=sex, shape=sex)) + geom_line() + geom_point() lp # 更改图例 lp + scale_shape_discrete(name =&quot;Payer&quot;, breaks=c(&quot;Female&quot;, &quot;Male&quot;), labels=c(&quot;Woman&quot;, &quot;Man&quot;)) 如果你同时使用colour和shape，它们都需要给出比例规格。 否则会有两个独立的图例。 # 指定颜色和形状 lp1 &lt;- ggplot(data=df1, aes(x=time, y=total_bill, group=sex, shape=sex, colour=sex)) + geom_line() + geom_point() lp1 # 如果你仅仅指定颜色，将会发生 lp1 + scale_colour_discrete(name =&quot;Payer&quot;, breaks=c(&quot;Female&quot;, &quot;Male&quot;), labels=c(&quot;Woman&quot;, &quot;Man&quot;)) # 指定的颜色和形状 lp1 + scale_colour_discrete(name =&quot;Payer&quot;, breaks=c(&quot;Female&quot;, &quot;Male&quot;), labels=c(&quot;Woman&quot;, &quot;Man&quot;)) + scale_shape_discrete(name =&quot;Payer&quot;, breaks=c(&quot;Female&quot;, &quot;Male&quot;), labels=c(&quot;Woman&quot;, &quot;Man&quot;)) 8.8.2.5.3 比例尺的种类 比例尺有很多种。 它们采用“scale_xxx_yyy”的形式。 以下是一些常用的xxx和yyy值： xxx 描述 colour Color of lines and points fill 填充区域的颜色 (比如：柱状图) 线条类型 Solid/dashed/dotted lines 形状 Shape of points 大小 Size of points alpha 不透明度/透明度 yyy 描述 hue 色轮的颜色相同 manual 手动指定的值（例如，颜色，点形状，线型） gradient 颜色渐变 grey Shades of grey discrete 不连续的值 (比如颜色，点的形状，线条类型，点的大小 continuous 连续的值（透明度，颜色，点的大小） 8.8.2.6 更改数据框中的因子 更改图例标题和标签的另一种方法是直接修改数据框。 pg &lt;- PlantGrowth # 把数据复制到新的数据框 # 重命名列中的列和值 levels(pg$group)[levels(pg$group)==&quot;ctrl&quot;] &lt;- &quot;Control&quot; levels(pg$group)[levels(pg$group)==&quot;trt1&quot;] &lt;- &quot;Treatment 1&quot; levels(pg$group)[levels(pg$group)==&quot;trt2&quot;] &lt;- &quot;Treatment 2&quot; names(pg)[names(pg)==&quot;group&quot;] &lt;- &quot;Experimental Condition&quot; # 查看最终结果的几行 head(pg) #&gt; 衡量实验调节 #&gt; 1 4.17 Control #&gt; 2 5.58 Control #&gt; 3 5.18 Control #&gt; 4 6.11 Control #&gt; 5 4.50 Control #&gt; 6 4.61 Control # 画图 ggplot(data=pg, aes(x=`Experimental Condition`, y=weight, fill=`Experimental Condition`)) + geom_boxplot() plot of chunk unnamed-chunk-13 图例标题“实验条件”很长，如果它被分成两行可能看起来更好，但是这种方法效果不好，因为你必须在列的名称中加上一个换行符。 另一种方法，有尺度，通常是更好的方法。 另请注意使用反引号而不是引号。 由于变量名中的空格，它们是必需的。 8.8.3 修改图例标题和标签的外观 # 题目外观 bp + theme(legend.title = element_text(colour=&quot;blue&quot;, size=16, face=&quot;bold&quot;)) # 标签外观 bp + theme(legend.text = element_text(colour=&quot;blue&quot;, size = 16, face = &quot;bold&quot;)) 8.8.4 修改图例框 默认情况下，图例周围没有框。 添加框并修改其属性: bp + theme(legend.background = element_rect()) bp + theme(legend.background = element_rect(fill=&quot;gray90&quot;, size=.5, linetype=&quot;dotted&quot;)) 8.8.5 改变图例位置 将图例位置放在绘图区域外（左/右/上/下）: bp + theme(legend.position=&quot;top&quot;) plot of chunk unnamed-chunk-16 也可以将图例定位在绘图区域内。 请注意，下面的数字位置是相对于整个区域的，包括标题和标签，而不仅仅是绘图区域。 # 将图例放在图表中，其中x，y为0,0（左下角）到1,1（右上角） bp + theme(legend.position=c(.5, .5)) # 设置图例的“锚点”（左下角为0,0;右上角为1,1） # 将图例框的左下角放在图的左下角 bp + theme(legend.justification=c(0,0), legend.position=c(0,0)) # 将图例框的右下角放在图表的右下角 bp + theme(legend.justification=c(1,0), legend.position=c(1,0)) 8.8.6 隐藏在图例中的斜线 如果使用轮廓制作条形图（通过设置color =“black”），它将通过图例中的颜色绘制斜线。 没有内置的方法来删除斜杠，但可以覆盖它们。 # 没有边缘线 ggplot(data=PlantGrowth, aes(x=group, fill=group)) + geom_bar() # 添加轮廓，但图例中会出现斜线 ggplot(data=PlantGrowth, aes(x=group, fill=group)) + geom_bar(colour=&quot;black&quot;) # 隐藏斜线：首先绘制没有轮廓的条形图并添加图例, # 然后用轮廓再次绘制条形图，但带有空白图例. ggplot(data=PlantGrowth, aes(x=group, fill=group)) + geom_bar() + geom_bar(colour=&quot;black&quot;, show.legend=FALSE) 8.8.7 注意 更多信息，请看: https://github.com/hadley/ggplot2/wiki/Legend-Attributes 8.9 线条 (ggplot2) 8.9.1 问题 你想要把线条加到图上 8.9.2 解决方案 8.9.2.1 使用一个连续轴和一个分类轴 # 一些样本数据 dat &lt;- read.table(header=TRUE, text=&#39; cond result control 10 treatment 11.5 &#39;) library(ggplot2) 8.9.2.1.1 一条线段 这些使用geom_hline，因为y轴是连续的，但如果x轴是连续的，也可以使用geom_vline（带有’xintercept`）。 # 基本柱状条 bp &lt;- ggplot(dat, aes(x=cond, y=result)) + geom_bar(position=position_dodge(), stat=&quot;identity&quot;) bp # 添加水平线 bp + geom_hline(aes(yintercept=12)) # 使线条变红并变为虚线 bp + geom_hline(aes(yintercept=12), colour=&quot;#990000&quot;, linetype=&quot;dashed&quot;) 8.9.2.1.2 每个分类值的单独行 要为每个条形成单独的行，请使用geom_errorbar。 误差条没有高度 - “ymin”=“ymax”。 由于某种原因，似乎有必要指定y，即使它没有任何功能。 # 为每个条形绘制单独的线条。 首先添加另一列到目前为止 dat$hline &lt;- c(9,12) dat #&gt; cond result hline #&gt; 1 control 10.0 9 #&gt; 2 treatment 11.5 12 # 需要重新指定bp，因为数据已经改变 bp &lt;- ggplot(dat, aes(x=cond, y=result)) + geom_bar(position=position_dodge(), stat=&quot;identity&quot;) # 为每个柱状图画分开的线条 bp + geom_errorbar(aes(ymax=hline, ymin=hline), colour=&quot;#AA0000&quot;) # 让线条更细一点 bp + geom_errorbar(width=0.5, aes(ymax=hline, ymin=hline), colour=&quot;#AA0000&quot;) # 即使我们从第二个数据框获得hline值，也可以得到相同的结果 # 使用hline定义数据框 dat_hlines &lt;- data.frame(cond=c(&quot;control&quot;,&quot;treatment&quot;), hline=c(9,12)) dat_hlines #&gt; cond hline #&gt; 1 control 9 #&gt; 2 treatment 12 # 柱状图形来自dat，但是线条来自dat_hlines bp + geom_errorbar(data=dat_hlines, aes(y=NULL, ymax=hline, ymin=hline), colour=&quot;#AA0000&quot;) #&gt; 警告：忽略未知的美学 : y 8.9.2.1.3 分组栏上的线条 可以在分组条上添加线条。 在这个例子中，实际上有四行（hline的每个条目一行），但它看起来像两个，因为它们是相互重叠的。 我不认为可以避免这种情况，但它不会导致任何问题。 dat &lt;- read.table(header=TRUE, text=&#39; cond group result hline control A 10 9 treatment A 11.5 12 control B 12 9 treatment B 14 12 &#39;) dat #&gt; cond group result hline #&gt; 1 control A 10.0 9 #&gt; 2 treatment A 11.5 12 #&gt; 3 control B 12.0 9 #&gt; 4 treatment B 14.0 12 # 定义基本柱状图 bp &lt;- ggplot(dat, aes(x=cond, y=result, fill=group)) + geom_bar(position=position_dodge(), stat=&quot;identity&quot;) bp # 误差线相互绘制 - 有四个但看起来像两个 bp + geom_errorbar(aes(ymax=hline, ymin=hline), linetype=&quot;dashed&quot;) 8.9.2.2 各个组合柱状图上的线条 即使在分组时，也可以在每个单独的条上划线。 dat &lt;- read.table(header=TRUE, text=&#39; cond group result hline control A 10 11 treatment A 11.5 12 control B 12 12.5 treatment B 14 15 &#39;) # 定义基本条形图 bp &lt;- ggplot(dat, aes(x=cond, y=result, fill=group)) + geom_bar(position=position_dodge(), stat=&quot;identity&quot;) bp bp + geom_errorbar(aes(ymax=hline, ymin=hline), linetype=&quot;dashed&quot;, position=position_dodge()) 8.9.2.3 有两个连续轴 样本数据如下 dat &lt;- read.table(header=TRUE, text=&#39; cond xval yval control 11.5 10.8 control 9.3 12.9 control 8.0 9.9 control 11.5 10.1 control 8.6 8.3 control 9.9 9.5 control 8.8 8.7 control 11.7 10.1 control 9.7 9.3 control 9.8 12.0 treatment 10.4 10.6 treatment 12.1 8.6 treatment 11.2 11.0 treatment 10.0 8.8 treatment 12.9 9.5 treatment 9.1 10.0 treatment 13.4 9.6 treatment 11.6 9.8 treatment 11.5 9.8 treatment 12.0 10.6 &#39;) library(ggplot2) 8.9.2.3.1 基础线条 # 基本的散点图 sp &lt;- ggplot(dat, aes(x=xval, y=yval, colour=cond)) + geom_point() # 添加一个水平线条 sp + geom_hline(aes(yintercept=10)) # 添加红色虚线垂直线 sp + geom_hline(aes(yintercept=10)) + geom_vline(aes(xintercept=11.5), colour=&quot;#BB0000&quot;, linetype=&quot;dashed&quot;) 8.9.2.3.2 画线为平均值 还可以计算每个数据子集的平均值，按一些变量分组。 组意味着必须计算并存储在单独的数据框中，最简单的方法是使用dplyr包。 请注意，该行的y范围由数据确定。 library(dplyr) lines &lt;- dat %&gt;% group_by(cond) %&gt;% summarise( x = mean(xval), ymin = min(yval), ymax = max(yval) ) # 为每组的平均xval添加彩色线条 sp + geom_hline(aes(yintercept=10)) + geom_linerange(aes(x=x, y=NULL, ymin=ymin, ymax=ymax), data=lines) #&gt; 警告：忽略未知的美学 : y plot of chunk unnamed-chunk-10 8.9.2.3.3 在分面使用线条 一般来说，如果你加一条线，它将出现在所有的分面上. # 分面，基于cond spf &lt;- sp + facet_grid(. ~ cond) spf # 用相同的值在所有的分面上画水平线 spf + geom_hline(aes(yintercept=10)) 如果您希望不同的线条出现在不同的方面，有两个选项。 一种是创建具有所需线条值的新数据框。 另一种选择（控制更有限）是在geom_line（）中使用stat和xintercept。 dat_vlines &lt;- data.frame(cond=levels(dat$cond), xval=c(10,11.5)) dat_vlines #&gt; cond xval #&gt; 1 control 10.0 #&gt; 2 treatment 11.5 spf + geom_hline(aes(yintercept=10)) + geom_vline(aes(xintercept=xval), data=dat_vlines, colour=&quot;#990000&quot;, linetype=&quot;dashed&quot;) spf + geom_hline(aes(yintercept=10)) + geom_linerange(aes(x=x, y=NULL, ymin=ymin, ymax=ymax), data=lines) #&gt; 警告：忽略未知的美学 : y 8.10 ggplot | 分面 8.10.1 问题 你想要根据一个或多个变量对数据进行分割并且绘制出该数据所有的子图。 8.10.2 方案 8.10.2.1 样本数据 以下例子将使用 reshape2 包中的 tips数据集 library(reshape2) # 查看头几行数据 head(tips) #&gt; total_bill tip sex smoker day time size #&gt; 1 16.99 1.01 Female No Sun Dinner 2 #&gt; 2 10.34 1.66 Male No Sun Dinner 3 #&gt; 3 21.01 3.50 Male No Sun Dinner 3 #&gt; 4 23.68 3.31 Male No Sun Dinner 2 #&gt; 5 24.59 3.61 Female No Sun Dinner 4 #&gt; 6 25.29 4.71 Male No Sun Dinner 4 根据小费 (tip) 占总账单 (total_bill) 的百分比绘制散点图 library(ggplot2) sp &lt;- ggplot(tips, aes(x=total_bill, y=tip/total_bill)) + geom_point(shape=1) sp plot of chunk unnamed-chunk-3 8.10.2.2 facet_grid 根据一个或多个变量对数据进行分割，生成的子图按照水平或垂直的方向进行排列。这一功能是通过赋予 facet_grid() 函数一个 vertical ~ horizontal 公式来实现的（这里所说的“公式”是R中的一种数据结构，而不是数学意义上的公式）。 # 根据 &quot;sex&quot; 按垂直方向分割 sp + facet_grid(sex ~ .) plot of chunk unnamed-chunk-4 # 根据 &quot;sex&quot; 按水平方向分割。 sp + facet_grid(. ~ sex) plot of chunk unnamed-chunk-5 # 垂直方向以 &quot;sex&quot; 分割，水平方向以 &quot;day&quot; 分割。 sp + facet_grid(sex ~ day) plot of chunk unnamed-chunk-6 8.10.2.3 facet_wrap 除了能够根据单个变量在水平或垂直方向上对图进行分面，facet_wrap()函数可以通过设置特定的行数或列数，让子图排列到一起。此时每个图像的上方都会有标签。 # 以变量 `day`进行水平分面，分面的行数为2。 sp + facet_wrap( ~ day, ncol=2) plot of chunk unnamed-chunk-7 8.10.2.4 修改分面标签的外观 sp + facet_grid(sex ~ day) + theme(strip.text.x = element_text(size=8, angle=75), strip.text.y = element_text(size=12, face=&quot;bold&quot;), strip.background = element_rect(colour=&quot;red&quot;, fill=&quot;#CCCCFF&quot;)) plot of chunk unnamed-chunk-8 8.10.2.5 修改分面标签的文本 修改分面标签内容有两种方法。最简单的方法是为原来的名字匹配一个新的名字向量。比方说对数据中 sex 的类别进行重新定义 Female==&gt;Women, and Male==&gt;Men: labels &lt;- c(Female = &quot;Women&quot;, Male = &quot;Men&quot;) sp + facet_grid(. ~ sex, labeller=labeller(sex = labels)) 另一个方法就是直接在数据框中修改，将你想要显示的标签赋值给相应的数据: tips2 &lt;- tips levels(tips2$sex)[levels(tips2$sex)==&quot;Female&quot;] &lt;- &quot;Women&quot; levels(tips2$sex)[levels(tips2$sex)==&quot;Male&quot;] &lt;- &quot;Men&quot; head(tips2, 3) #&gt; total_bill tip sex smoker day time size #&gt; 1 16.99 1.01 Women No Sun Dinner 2 #&gt; 2 10.34 1.66 Men No Sun Dinner 3 #&gt; 3 21.01 3.50 Men No Sun Dinner 3 # Both of these will give the same output: sp2 &lt;- ggplot(tips2, aes(x=total_bill, y=tip/total_bill)) + geom_point(shape=1) sp2 + facet_grid(. ~ sex) 两种方法都能得到相同的结果： plot of chunk unnamed-chunk-11 labeller() 可以通过设定不同的 函数 来处理输入的字符向量。比方说 Hmisc 包里的 capitalize 函数可以将字符串的首字母变成大写。我们也可以这样来自定义函数，如下所示，将字符串中的字母倒序： # 对每个字符向量进行倒序： reverse &lt;- function(strings) { strings &lt;- strsplit(strings, &quot;&quot;) vapply(strings, function(x) { paste(rev(x), collapse = &quot;&quot;) }, FUN.VALUE = character(1)) } sp + facet_grid(. ~ sex, labeller=labeller(sex = reverse)) plot of chunk unnamed-chunk-12 8.10.2.6 设置标度 一般而言，每幅图的坐标轴范围都是固定不变的，也就是说每幅图都拥有相同的尺寸和范围。你可以通过将 scales 设置为 free，free_x 或 free_y 来改变坐标轴范围。 # 描绘一个 total_bill的柱状图 hp &lt;- ggplot(tips, aes(x=total_bill)) + geom_histogram(binwidth=2,colour=&quot;white&quot;) # 根据性别和是否吸烟进行分面 hp + facet_grid(sex ~ smoker) # 在同样的情况下设定 scales=&quot;free_y&quot; (y轴自由标度） hp + facet_grid(sex ~ smoker, scales=&quot;free_y&quot;) # 画布的缩放比例不变，但各分面的范围有所改变，因此每个分面的物理大小都不一致 hp + facet_grid(sex ~ smoker, scales=&quot;free&quot;, space=&quot;free&quot;) plot of chunk unnamed-chunk-13 plot of chunk unnamed-chunk-13 plot of chunk unnamed-chunk-13 8.11 ggplot |多图 8.11.1 问题 你想把多个图形放到同一个页面中。 8.11.2 方案 最简单的方法就是使用 multiplot 函数，本页末尾处附有该函数的具体定义。如果它不能满足你的需求，你可以将其复制下来然后作出适当的修改。 首先，构建并保存图像但不需要对它们进行渲染，这些图像的细节并不重要。你只需要将这些图像对象储存为变量。 # 以下例子使用的是 ggplot2 包中自带的 Chickweight 数据集 #第一幅图像 p1 &lt;- ggplot(ChickWeight, aes(x=Time, y=weight, colour=Diet, group=Chick)) + geom_line() + ggtitle(&quot;Growth curve for individual chicks&quot;) #第二幅图像 p2 &lt;- ggplot(ChickWeight, aes(x=Time, y=weight, colour=Diet)) + geom_point(alpha=.3) + geom_smooth(alpha=.2, size=1) + ggtitle(&quot;Fitted growth curve per diet&quot;) #第三幅图像 p3 &lt;- ggplot(subset(ChickWeight, Time==21), aes(x=weight, colour=Diet)) + geom_density() + ggtitle(&quot;Final weight, by diet&quot;) #第四幅图像 p4 &lt;- ggplot(subset(ChickWeight, Time==21), aes(x=weight, fill=Diet)) + geom_histogram(colour=&quot;black&quot;, binwidth=50) + facet_grid(Diet ~ .) + ggtitle(&quot;Final weight, by diet&quot;) + theme(legend.position=&quot;none&quot;) #为了避免冗余，这里不添加图例 这些图像都构建好了后，我们可以用 multiplot 对它们进行渲染。下面将这些图形分成两列进行展示： multiplot(p1, p2, p3, p4, cols=2) #&gt; `geom_smooth()` 函数设置成 method = &#39;loess&#39; plot of chunk unnamed-chunk-3 8.11.3 multiplot 函数 定义：multiplot 函数可以将任意数量的图像对象作为参数，或者可以构建一个图像对象列表传递到该函数的 plotlist 参数中。 # 多图功能 # # ggplot 对象可以直接放入 `…` 中，也可以传递到 `plotlist` 里（这里的 ggplot 对象以列表形式存在） # - cols: 图像的列数 # - layout: 用来指定布局的一组矩阵。当其存在时，可以忽略 `cols` 参数。 # # 假设 layout 参数是 matrix(c(1,2,3,3), nrow=2, byrow = TRUE), # 那么第一幅图像会位于左上方，第二幅图会在右上方，而 # 第三幅图会占据整个下方。 # multiplot &lt;- function(..., plotlist=NULL, file, cols=1, layout=NULL) { library(grid) # 从参数 `…`中建立一个列表然后 plotlist plots &lt;- c(list(...), plotlist) numPlots = length(plots) # 假如 layout 是 NULL, 那么可以用 `cols` 来定义布局 if (is.null(layout)) { # 创建面板 # ncol: 图像的列数 # nrow: 根据上述给定的列数，计算所需要的行数 layout &lt;- matrix(seq(1, cols * ceiling(numPlots/cols)), ncol = cols, nrow = ceiling(numPlots/cols)) } if (numPlots==1) { print(plots[[1]]) } else { # 创建页面 grid.newpage() pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout)))) # 让每一幅图像排列在正确的位置 for (i in 1:numPlots) { # 获取包含这一子图所在区域的坐标 matrix i,j matchidx &lt;- as.data.frame(which(layout == i, arr.ind = TRUE)) print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row, layout.pos.col = matchidx$col)) } } } 8.12 颜色（ggplot2) 8.12.1 问题 你想在图表中用ggplot2添加颜色 8.12.2 解决方案 在ggplot2中设置颜色，对相互区分不同变量会有些困难，因为这些颜色有一样的亮度，且对色盲者不太友好。一个比较好的通用解决方案是使用对色盲友好的调色。 8.12.2.1 样本数据 这两个数据集将用来产生下面的图表 # 两个变量 df &lt;- read.table(header=TRUE, text=&#39; cond yval A 2 B 2.5 C 1.6 &#39;) # 三个变量 df2 &lt;- read.table(header=TRUE, text=&#39; cond1 cond2 yval A I 2 A J 2.5 A K 1.6 B I 2.2 B J 2.4 B K 1.2 C I 1.7 C J 2.3 C K 1.9 &#39;) 8.12.2.2 简单的颜色设置 有颜色的线条和点可以直接用’colour = “red” ’, 用颜色名称代替”red“。填充的对象的颜色，例如柱状条，可以用 ’fill=”red&quot; 来进行设置。 如果你想用任何其他非常规颜色，用十六进位码来设置颜色更容易，比如“#FF6699”。（看下面的十六进位码颜色图） library(ggplot2) # 设置：黑色柱状条 ggplot(df, aes(x=cond, y=yval)) + geom_bar(stat=&quot;identity&quot;) # 柱状条外用红色边线 ggplot(df, aes(x=cond, y=yval)) + geom_bar(stat=&quot;identity&quot;, colour=&quot;#FF9999&quot;) # 红色填充，黑色边线 ggplot(df, aes(x=cond, y=yval)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;#FF9999&quot;, colour=&quot;black&quot;) # 标准黑色线条和点 ggplot(df, aes(x=cond, y=yval)) + geom_line(aes(group=1)) + geom_point(size=3) # 蓝黑色线条，红色点 ggplot(df, aes(x=cond, y=yval)) + geom_line(aes(group=1), colour=&quot;#000099&quot;) + # 蓝线 geom_point(size=3, colour=&quot;#CC0000&quot;) # 红点 8.12.2.3 将变量值映射到颜色 不用全局改变颜色，你可以将变量映射到颜色——换言之，通过把颜色放到aes()说明中，可以设置条件性变量。 # 柱状条: x 和填充都依赖于cond2 ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) # 其他数据集的柱状条；填充依赖于cond2 ggplot(df2, aes(x=cond1, y=yval)) + geom_bar(aes(fill=cond2), # 填充依赖于cond2 stat=&quot;identity&quot;, colour=&quot;black&quot;, # 所有都是黑色轮廓线 position=position_dodge()) # 把线条并排放置而非堆叠 # 线和点；颜色依赖于cond2 ggplot(df2, aes(x=cond1, y=yval)) + geom_line(aes(colour=cond2, group=cond2)) + # 颜色分组都依赖于cond2 geom_point(aes(colour=cond2), # 颜色依赖于cond2 size=3) # 更大的点，不同的形状 ## 以上操作等价; 但把 &quot;colour=cond2&quot; 移到全局的映射用aes() # ggplot(df2, aes(x=cond1, y=yval, colour=cond2)) + # geom_line(aes(group=cond2)) + # geom_point(size=3) 8.12.2.4 对色盲友好的颜色 这些是对色盲友好的颜色色板，一个用灰色，一个用黑色 为了用ggplot2, 我们在一个变量里储存颜色色板，然后之后调用。 # 灰色的颜色色板: cbPalette &lt;- c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;) # 黑色的颜色色板k: cbbPalette &lt;- c(&quot;#000000&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;) # 为了填充颜色，加 scale_fill_manual(values=cbPalette) # 为了在点线中使用颜色，加 scale_colour_manual(values=cbPalette) 这个颜色集来源于网站： http://jfly.iam.u-tokyo.ac.jp/color/: Colorblind palette 8.12.2.5 颜色选择 默认情况下，离散比例的颜色围绕HSL色环均匀分布。 例如，如果有两种颜色，那么它们将从圆圈上的相对点中选择; 如果有三种颜色，它们在色环上将相隔120°; 等等。 用于不同级别的颜色如下所示： plot of chunk unnamed-chunk-7 默认颜色选择使用scale_fill_hue（）和scale_colour_hue（）。 例如，在这些情况下添加这些命令是多余的： # 这两个是等价的; 默认使用scale_fill_hue（） ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) # ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) + scale_fill_hue() # 这两个是等价的; 默认使用scale_colour_hue（） ggplot(df, aes(x=cond, y=yval, colour=cond)) + geom_point(size=2) # ggplot(df, aes(x=cond, y=yval, colour=cond)) + geom_point(size=2) + scale_colour_hue() 8.12.2.6 设置亮度和饱和度（色度） 虽然scale_fill_hue（）和scale_colour_hue（）在上面是多余的，但是当你想要改变默认值时，可以使用它们，比如改变亮度或色度。 # 使用 luminance=45, 而不是默认 65 ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) + scale_fill_hue(l=40) # 从100到50减少饱和度（亮度）, 增加亮度 ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) + scale_fill_hue(c=45, l=80) # 注意：使用scale_colour_hue() 设置线和点 This is a chart of colors with luminance=45: plot of chunk unnamed-chunk-10 8.12.2.7 调色板：Color Brewer 您还可以使用其他色标，例如从RColorBrewer包中获取的色标。 请参阅下面的RColorBrewer调色板图表。 ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer() ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette=&quot;Set1&quot;) ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) + scale_fill_brewer(palette=&quot;Spectral&quot;) # 注意: 使用 scale_colour_brewer() 设置点和线条 8.12.2.8 调色板：手动定义 最后，您可以使用scale_fill_manual（）定义自己的颜色集。 有关选择特定颜色的帮助，请参阅下面的十六进制代码表。 ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) + scale_fill_manual(values=c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) ggplot(df, aes(x=cond, y=yval, fill=cond)) + geom_bar(stat=&quot;identity&quot;) + scale_fill_manual(values=c(&quot;#CC6666&quot;, &quot;#9999CC&quot;, &quot;#66CC99&quot;)) # 注意：使用 scale_colour_manual() 设置线条和点 8.12.2.9 连续的颜色 # 产生一些数据 set.seed(133) df &lt;- data.frame(xval=rnorm(50), yval=rnorm(50)) # 依赖 yval设置颜色 ggplot(df, aes(x=xval, y=yval, colour=yval)) + geom_point() # 使用不同的渐变 ggplot(df, aes(x=xval, y=yval, colour=yval)) + geom_point() + scale_colour_gradientn(colours=rainbow(4)) 8.12.2.10 比色图表 8.12.2.11 十六进制色码图 颜色可以指定为十六进制RGB三元组合，例如“＃0066CC”。 前两位数字是红色，接下来的两位是绿色，最后两位是蓝色。 每个值的范围从00到FF，以十六进制（base-16）表示，在base-10中等于0和255。 例如，在下表中，“＃FFFFFF”为白色，“＃990000”为深红色。 img (色码图来源于 http://www.visibone.com) 8.12.2.12 RColorBrewer调色板图表 plot of chunk unnamed-chunk-14 8.13 图形混杂-输出到文件-PDF-PNG-TIFF-SVG 8.13.1 问题 你想将图形保存到文件。 8.13.2 方案 R 中有好几种命令可以直接将图形导出为文件而不是打印到屏幕上。另外，你必须通过 dev.off() 命令告诉 R 你已经完成作图了，否则你的图形是不会显示出来的。 8.13.2.1 PDF格式 PDF 是一种矢量文件格式。一般我们都更倾向于将图形输出为矢量图文件，因为这样的图无论怎样缩放都不会出现像素点。矢量图文件的大小通常要比位图文件要小，除非该文件里包含了过多的内容。（比如说一张散点图内包含了上千个点，这时候就会造成矢量图大而位图小。） pdf(&quot;plots.pdf&quot;) plot(...) plot(...) dev.off() PDF 默认是 7x7 英寸，并且每个图形都单独占一页。这个尺寸是可以更改的： # 6x3 inches pdf(&quot;plots.pdf&quot;, width=6, height=3) # 10x6 cm pdf(&quot;plots.pdf&quot;, width=10/2.54, height=6/2.54) 如果你想在 Inkscape 或者 Illustrator 这样的矢量图编辑器中修改你的文件，图形中的一些绘制点有可能看上去更像是字母而并非原来的圆形或方形等。为了防止这种情况的发生可以输入： pdf(&quot;plots.pdf&quot;, useDingbats=FALSE) 8.13.2.2 SVG格式 SVG是另一种矢量图。默认的 svg() 命令无法将多页图形输出到一个文件中，因为大部分的 SVG 浏览软件无法处理多页的 SVG 文件。后面的 PNG 内容中将涉及如何输出到多个文件。 svg(&quot;plots.svg&quot;) plot(...) dev.off() SVG 文件比 PDF 文件更适合矢量图编辑器。 8.13.2.3 PNG/TIFF格式 PNG 和 TIFF 是位图（栅格图像），对它们进行缩放时可能会出现像素点。 png(&quot;plot.png&quot;) # 或者 tiff(&quot;plot.tiff&quot;) plot(...) dev.off() 输出的图像默认尺寸为 480X480 像素，分辨率为 72dpi （即 6.66x6.66 英寸） 当分辨率增加时文本与图像元素的大小也会（以像素为单位）增加。这是因为这些元素的大小只与图像的物理大小有关（比如 4x4英寸），而与图像的像素大小无关。例如，一个 12 磅的字符高度为 12/72 = 1/6 英寸，在分辨率为 72dpi 的情况下，它共包含 12 个像素点；而在分辨率放大到 120dpi 时，它就含有 20 个像素点了。 以下创建一个大小为 480x240 像素，分辨率为 120dpi 的图像,其实际大小相当于 4x2 英寸。 png(&quot;plot.png&quot;, width=480, height=240, res=120) plot(...) dev.off() 如果你要创建不止一张图像，必须对每张图像执行一个新的 png() 命令，或者将 %d 放置到文件名中: png(&quot;plot-%d.png&quot;) plot(...) dev.off() 上述代码会生成 plot-1.png, plot-2.png 等系列文件。 8.13.2.4 对于不支持PDF格式的程序 （MS Office） 有些不支持 PDF文件导入的程序一般都需要高分辨率的PNG或TIFF文件。比如说微软 Office 无法导入 PDF 格式文件。而对于印刷出版物，则需要使用 300dpi 的图像。 # 绘制一幅 6x6英寸，300dpi 的图像 ppi &lt;- 300 png(&quot;plot.png&quot;, width=6*ppi, height=6*ppi, res=ppi) plot(...) dev.off() 8.13.2.5 ggplot2 如果你在脚本或函数中使用 ggplot2 进行绘图，必须使用 print() 命令确保图像得到渲染。 # 无效命令 pdf(&quot;plots.pdf&quot;) qplot(...) dev.off() # 正确的做法 pdf(&quot;plots.pdf&quot;) print(qplot(...)) dev.off() 从屏幕中保存一个 ggplot2 图像为文件，你可以使用 ggsave()。 ggsave(&quot;plot.pdf&quot;) ggsave(&quot;plot.pdf&quot;, width=4, height=4) # 将图形保存为 400x400，100 ppi的文件 ggsave(&quot;plot.png&quot;, width=4, height=4, dpi=100) 8.13.2.6 保存屏幕中的图像 如果你的屏幕中已经有一张图像了，可以将其保存为位图。 这是一种将屏幕中的对象作出从像素到像素的拷贝，不过这种操作很大概率只能在 Linux 和 Mac 的 X11 系统下得以实现： # 在屏幕中绘制一张图形 plot(...) savePlot(&quot;myplot.png&quot;) 这一步是保存屏幕当前图像，并且根据不同的设备对图像进行重新渲染，图像大小可能会因此发生变化。如果你需要图形大小固定，则需要以像素为单位对尺寸进行指定。 # 在屏幕中绘制图像 plot(...) dev.copy(pdf,&quot;myplot.pdf&quot;, width=4, height=4) dev.off() # 等同于： # pdf(&quot;myplot.pdf&quot;, width=4, height=4) # plot(...) # dev.off() dev.copy(png,&quot;myplot.png&quot;, width=400, height=400) dev.off() 8.14 图形混杂-形状和线形 8.14.1 问题 你想在图形中使用不同的形状和线条。 8.14.2 方案 unnamed-chunk-2 plot of chunk line_types 在输出位图时，对符号15-18的渲染可能不具抗锯齿性，即无论这些图形的绘制是否来自同一个平台，这些符号都有可能会被拉伸变形，出现像素点，或者无法居中。符号19和21-25在填充部分外周会有边框线，在大部分情况下这种边线在渲染时其边缘都是平滑的。另外，要使符号21-25显示实心填充，需要指定与边线颜色(col)一致的填充(bg)颜色，否则这些符号将会是空心的。 8.14.2.1 标准图形 通过 pch 选项来设置符号形状, 并且通过 lty 和 lwd 来设定线条的类型和粗细。线条的类型可以通过名字或数字来指定。 set.seed(331) # 绘制一些点线 # 设定绘画范围 par(mar=c(3,3,2,2)) plot(NA, xlim=c(1,4), ylim=c(0,1)) # 绘制实心圆和实线 points(1:4, runif(4), type=&quot;b&quot;, pch=19) # 添加空心方框和粗虚线 points(1:4, runif(4), type=&quot;b&quot;, pch=0, lty=2, lwd=3) points(1:4, runif(4), type=&quot;b&quot;, pch=23, # 菱形符号 lty=&quot;dotted&quot;, cex=2, # 点状线, 符号形状放大一倍 col=&quot;#000099&quot;, bg=&quot;#FF6666&quot;) # 线条蓝色，符号形状红色填充 plot of chunk unnamed-chunk-3 8.14.2.2 ggplot2 在调用 ggplot2 的情况下，可以对图中的符号形状和线条类型进行全局的部署（比方说你想让所有数据点都是方形，所有的线条都为虚线），或者通过一个变量来调整它们。 # 示例数据 df &lt;- read.table(header=T, text=&#39; cond xval yval A 1 2.0 A 2 2.5 B 1 3.0 B 2 2.0 &#39;) library(ggplot2) # 使用标准的线条和符号形状作图 # 用 group = cond 表示点线之间的对应关系 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line() + geom_point() # 设置全局的符号形状和线条类型 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line(linetype=&quot;dashed&quot;, # 虚线 size = 1.5) + # 加粗 geom_point(shape = 0, # 空心方块 size = 4) # 放大形状 # 通过变量 cond 调整符号图形和线类型 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line(aes(linetype=cond), # cond 决定线条类型 size = 1.5) + # 线条加粗 geom_point(aes(shape=cond), # cond 决定形状 size = 4) # 放大形状 # 在上述的基础上同时改变所使用的线条和形状 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line(aes(linetype=cond), # cond 决定线条类型 size = 1.5) + # 线条加粗 geom_point(aes(shape=cond), # cond 决定形状 size = 4) + # 放大形状 scale_shape_manual(values=c(6,5)) + # 更改形状 scale_linetype_manual(values=c(&quot;dotdash&quot;, &quot;dotted&quot;)) # 更改线条类型 一般来说 ggplot2 使用的是实心形状。如果你想要空心的形状又不想手动地对每个形状进行定义，可以使用scale_shape(solid=FALSE)。注意，这个时候形状空心部分中的线条是可见的。为了避免这种情况，你可以使用符号形状21-25并且指定白色填充。 # 空心形状 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line(aes(linetype=cond), # cond 决定线条类型 size = 1.5) + # 线条加粗 geom_point(aes(shape=cond), # cond 决定符号形状 size = 4) + # 放大形状 scale_shape(solid=FALSE) # 白色填充形状 ggplot(df, aes(x=xval, y=yval, group = cond)) + geom_line(aes(linetype=cond), # cond 决定线条类型 size = 1.5) + # 线条加粗 geom_point(aes(shape=cond), # cond 决定符号形状 fill = &quot;white&quot;, # 白色填充 size = 4) + # 放大形状 scale_shape_manual(values=c(21,24)) # 形状：实心圆和三角形 8.14.2.3 附录 以下代码会生成本章节开头所示的图表。 par(mar=c(0,0,0,0)) # 设定绘图区域 plot(NA, xlim=c(0,1), ylim=c(6.5, -0.5), xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, xlab=NA, ylab=NA ) # 画线条 for (i in 0:6) { points(c(0.25,1), c(i,i), lty=i, lwd=2, type=&quot;l&quot;) } # 添加标签 text(0, 0, &quot;0. &#39;blank&#39;&quot; , adj=c(0,.5)) text(0, 1, &quot;1. &#39;solid&#39;&quot; , adj=c(0,.5)) text(0, 2, &quot;2. &#39;dashed&#39;&quot; , adj=c(0,.5)) text(0, 3, &quot;3. &#39;dotted&#39;&quot; , adj=c(0,.5)) text(0, 4, &quot;4. &#39;dotdash&#39;&quot; , adj=c(0,.5)) text(0, 5, &quot;5. &#39;longdash&#39;&quot;, adj=c(0,.5)) text(0, 6, &quot;6. &#39;twodash&#39;&quot; , adj=c(0,.5)) 8.15 图形混杂-字体 8.15.1 问题 你想在图像中使用不同的字体。 8.15.2 方案 更新: 查看 extrafont 包相关内容，该包能更好地支持 PDF 和 Windows 位图中的字体设定。 R 在一般情况下都不能很好地支持字体的显示。在不同的操作系统和不同的输出格式中都会出现不一样的结果。 8.15.2.1 geom_text 通过 ggplot2 中的 geom_text or annotate , 你可以对图形文本中的一系列属性进行设置。 geom_text 用于将数据框中的文本加入到图表中，而 annotate 则用于往图表中添加单个文本元素。 Name Default value size 5 family &quot;&quot; (sans) fontface plain lineheight 1.2 angle 0 hjust 0.5 vjust 0.5 注意这里 size 的单位是毫米, 而非磅。 dat &lt;- data.frame( y = 1:3, text = c(&quot;This is text&quot;, &quot;Text with\\nmultiple lines&quot;, &quot;Some more text&quot;) ) library(ggplot2) p &lt;- ggplot(dat, aes(x=1, y=y)) + scale_y_continuous(limits=c(0.5, 3.5), breaks=NULL) + scale_x_continuous(breaks=NULL) p + geom_text(aes(label=text)) p + geom_text(aes(label=text), family=&quot;Times&quot;, fontface=&quot;italic&quot;, lineheight=.8) + annotate(geom=&quot;text&quot;, x=1, y=1.5, label=&quot;Annotation text&quot;, colour=&quot;red&quot;, size=7, family=&quot;Courier&quot;, fontface=&quot;bold&quot;, angle=30) 8.15.2.2 themes and element_text 在管理类似标题，图注，坐标轴标签等元素时，可以使用 element_text, 其参数设置跟geom_text基本一致, 除了 size 的单位是 points (而非 mm), 还有就是它用的是 face 而不是 fontface 。默认情况下，size 取决于元素，比如图形标题的字体总是比刻度标签的大。 p + geom_point() + ggtitle(&quot;This is a Title&quot;) + theme(plot.title=element_text(family=&quot;Times&quot;, face=&quot;bold&quot;, size=20)) plot of chunk unnamed-chunk-3 8.15.2.3 字体表格 你可以运行下列代码来生成一张不同字体的图形表。 每种字体都有简称和字体标准家族名称，定义字体时使用其中一种即可。 fonttable &lt;- read.table(header=TRUE, sep=&quot;,&quot;, stringsAsFactors=FALSE, text=&#39; Short,Canonical mono,Courier sans,Helvetica serif,Times ,AvantGarde ,Bookman ,Helvetica-Narrow ,NewCenturySchoolbook ,Palatino ,URWGothic ,URWBookman ,NimbusMon URWHelvetica,NimbusSan ,NimbusSanCond ,CenturySch ,URWPalladio URWTimes,NimbusRom &#39;) fonttable$pos &lt;- 1:nrow(fonttable) library(reshape2) fonttable &lt;- melt(fonttable, id.vars=&quot;pos&quot;, measure.vars=c(&quot;Short&quot;,&quot;Canonical&quot;), variable.name=&quot;NameType&quot;, value.name=&quot;Font&quot;) # 创建一个分面形式的图表。确保因子的顺序是正确的 facetable &lt;- data.frame(Face = factor(c(&quot;plain&quot;,&quot;bold&quot;,&quot;italic&quot;,&quot;bold.italic&quot;), levels = c(&quot;plain&quot;,&quot;bold&quot;,&quot;italic&quot;,&quot;bold.italic&quot;))) fullfonts &lt;- merge(fonttable, facetable) library(ggplot2) pf &lt;- ggplot(fullfonts, aes(x=NameType, y=pos)) + geom_text(aes(label=Font, family=Font, fontface=Face)) + facet_wrap(~ Face, ncol=2) 在屏幕中查看: pf 你在屏幕中所看见的不一定跟你输出为 PNG 或 PDF 格式后的结果完全一样。查看 PNG 格式的输出结果： png(&#39;fonttable.png&#39;, width=720, height=720, res=72) print(pf) dev.off() 需要注意的是，对于生成这张图片的操作系统来说，大部分的字体（位于顶部）是不兼容的，只有一些基础字体（位于底部）是可以使用的。 unnamed-chunk-7 PDF 格式输出结果(以下示例图已从 PDF 格式转化为 PNG 格式）: pdf(&#39;fonttable.pdf&#39;, width=10, height=10) print(pf) dev.off() # 用 GraphicsMagick 将 PDF 转化为PNG格式: # system(&quot;gm convert -resize 720x720 -background white fonttable.pdf fonttable-pdf.png&quot;) PDF 设备对于不同字体的支持比 PNG 设备更好。基本所有的字体都能兼容。(虽然这些字体并不一定很好看): PDF font table, converted to PNG 8.16 图形混杂-抗混淆位图输出 8.16.1 问题 你想要在windows操作环境下保存抗锯齿的位图结果（anti-aliasing bitmap）。 8.16.2 方案 类似于png和jpeg的标准图形设备可以将图形保存成cairo、Xlib、 quartz三种不同的文件格式。当使用cairo，我们便可以获得抗锯齿化的图形结果。在MacOS和linux系统下，自动将图片保存为cairo格式，但是在windows系统下的相应参数是NULL。 绘图示例（如下）： # 设置伪随机数种子 set.seed(1) #生成符合正态分布的100个随机数 x = rnorm(100) png(&quot;antialiasing_1.png&quot;, type=&quot;cairo&quot;) plot(x) dev.off() 在windows系统环境下不可强行使用type=“cairo”，需要借助Cairo工具包获取抗锯齿化结果。 # 安装Cairo包 # install.packages(&quot;Cairo&quot;) library(&quot;Cairo&quot;) # 设置伪随机数种子 set.seed(1) #生成符合正态分布的100个随机数 x = rnorm(100) Cairo(width = 540, height = 380, file=&quot;antialiasing_2.png&quot;, type=&quot;png&quot;, bg=&quot;white&quot;) plot(x) dev.off() 8.16.2.1 提示 有关该部分的更多相关信息，参看Efficient R programming。 8.17 标准绘图 | 散点图 8.17.1 问题 你想要创建一个散点图 8.17.2 方案 假设下面是你的数据： set.seed(955) # 给数据添加一些随机噪声 dat &lt;- data.frame(xvar = 1:20 + rnorm(20,sd=3), yvar = 1:20 + rnorm(20,sd=3), zvar = 1:20 + rnorm(20,sd=3)) head(dat) #&gt; xvar yvar zvar #&gt; 1 -4.252354 3.473157275 -2.97806724 #&gt; 2 1.702318 0.005939612 -1.16183118 #&gt; 3 4.323054 -0.094252427 4.85516658 #&gt; 4 1.780628 2.072808278 4.65078709 #&gt; 5 11.537348 1.215440358 -0.06613962 #&gt; 6 6.672130 3.608111411 6.24349897 8.17.2.1 基本的散点图 # 使用向量xvar和yvar绘制点图 plot(dat$xvar, dat$yvar) # 跟上一句代码一致，但这里是用公式实现 plot(yvar ~ xvar, dat) # 添加一条回归线 fitline &lt;- lm(dat$yvar ~ dat$xvar) abline(fitline) 8.17.2.2 散点图矩阵 如果你想要比较多个变量，可以创建一个散点图矩阵 # 一个散点图矩阵 plot(dat[,1:3]) # 添加回归线 # 在对角添加histogram/boxplot/density/qqplot library(car) scatterplotMatrix(dat[,1:3], diagonal=&quot;histogram&quot;, smooth=FALSE) 想要查看对应的相关矩阵，查看 ../../Statistical analysis/Regression and correlation。 想要可视化相关矩阵，查看 ../Correlation matrix。 8.18 标准绘图|箱线图 8.18.1 问题 你想要绘制一个箱线图。 8.18.2 方案 该方案教你如何快速地使用标准绘图方法绘制简单的箱线图。 8.18.2.1 样例数据 这里的例子使用ToothGrowth数据集，它有两个独立变量以及一个依赖变量。 head(ToothGrowth) #&gt; len supp dose #&gt; 1 4.2 VC 0.5 #&gt; 2 11.5 VC 0.5 #&gt; 3 7.3 VC 0.5 #&gt; 4 5.8 VC 0.5 #&gt; 5 6.4 VC 0.5 #&gt; 6 10.0 VC 0.5 在不同 supp 和dose条件下，变量len的箱线图: boxplot(len ~ supp, data=ToothGrowth) # 即使`dose`是一个数值型变量，`boxplot`也会将其转换为因子 boxplot(len ~ dose, data=ToothGrowth) 组合 supp 和 dose 不同水平（即交互项）下len的箱线图（） boxplot(len ~ interaction(dose,supp), data=ToothGrowth) plot of chunk unnamed-chunk-4 注意plot除了添加了横轴标签和不会自动将数值变量转换为因子变量，它与boxplot有非常相似的输出。 plot(len ~ interaction(dose,supp), data=ToothGrowth) plot of chunk unnamed-chunk-5 8.19 标准绘图|QQ图 8.19.1 问题 你想要对你自己的数据分布与其他的分布进行比较。这常用语检查是否一个样本是否服从正态分布，以及两个样本是抽取自同一分布。 8.19.2 方案 假设这是你的数据： set.seed(183) # 正态分布的数值 x &lt;- rnorm(80, mean=50, sd=5) # 均匀分布的数值 z &lt;- runif(80) # 比较用rnorm()抽样的数据分布与正态分布的差异 qqnorm(x) qqline(x) # 比较数据的4次幂分布与正态分布的差异 qqnorm(x^4) qqline(x^4) # 比较均匀分布抽取的数据与正态分布的差异 qqnorm(z) qqline(z) 8.20 其他有趣图形-相关矩阵 8.20.1 问题 你想要可视化多元变量间的相关性强度。 8.20.2 方案 假设所要分析的数据（如下）： # 设置伪随机数种子 set.seed(955) #生成符合正态分布的20个随机数 vvar &lt;- 1:20 + rnorm(20,sd=3) wvar &lt;- 1:20 + rnorm(20,sd=5) xvar &lt;- 20:1 + rnorm(20,sd=3) yvar &lt;- (1:20)/2 + rnorm(20, sd=10) zvar &lt;- rnorm(20, sd=6) # 使用向量生成数据框（向量名为列名） data &lt;- data.frame(vvar, wvar, xvar, yvar, zvar) head(data) #&gt; vvar wvar xvar yvar zvar #&gt; 1 -4.252354 5.1219288 16.02193 -15.156368 -4.086904 #&gt; 2 1.702318 -1.3234340 15.83817 -24.063902 3.468423 #&gt; 3 4.323054 -2.1570874 19.85517 2.306770 -3.044931 #&gt; 4 1.780628 0.7880138 17.65079 2.564663 1.449081 #&gt; 5 11.537348 -1.3075994 10.93386 9.600835 2.761963 #&gt; 6 6.672130 2.0135190 15.24350 -3.465695 5.749642 可视化上述数据： # 导入以椭圆表征相关性强度的分析包 library(ellipse) # 生成相关矩阵表 ctab &lt;- cor(data) # 表中数据保留两位小数 round(ctab, 2) #&gt; vvar wvar xvar yvar zvar #&gt; vvar 1.00 0.61 -0.85 0.75 -0.21 #&gt; wvar 0.61 1.00 -0.81 0.54 -0.31 #&gt; xvar -0.85 -0.81 1.00 -0.63 0.24 #&gt; yvar 0.75 0.54 -0.63 1.00 -0.30 #&gt; zvar -0.21 -0.31 0.24 -0.30 1.00 # 设置简化边幅并绘制相关性图 plotcorr(ctab, mar = c(0.1, 0.1, 0.1, 0.1)) # 使用颜色表征相关性强度 colorfun &lt;- colorRamp(c(&quot;#CC0000&quot;,&quot;white&quot;,&quot;#3366CC&quot;), space=&quot;Lab&quot;) plotcorr(ctab, col=rgb(colorfun((ctab+1)/2), maxColorValue=255), mar = c(0.1, 0.1, 0.1, 0.1)) plot of chunk unnamed-chunk-3-1 plot of chunk unnamed-chunk-3-2 8.20.3 提示 有关生成关联表（数字）的更多信息，参看../../Statistical analysis/Regression and correlation。 "],
["section-9.html", "第 9 章 脚本与函数 9.1 创建和运行一个脚本 9.2 调试脚本或函数 9.3 测量经过的时间 9.4 获取包中的函数和对象列表", " 第 9 章 脚本与函数 9.1 创建和运行一个脚本 计算细菌基因组核心蛋白相似性 应用场景： 细菌分类学研究中，需要借助基因组水平的相似度来界定是否属于新物种，是否是一个未发现的新属水平或者新科水平，乃至更高的分类学单元（界门纲目科属种）。 在基因组的核酸水平研究中，有诸如dDDH（数字化DNA分子杂交）、核苷酸平均相似度（Average Nucleotide Identity，ANI）等指标来界定是否属于新物种；而在基因组蛋白质水平相类似的指标较少，比如氨基酸平均相似度（Average Amino acid Identity，AAI）和保守蛋白比率（percentage of conserved proteins，POCP）等。 简要过程： 两两比对细菌基因组的蛋白序列，互为参考数据库进行 blastp 比对（A作数据库，B查询；B作数据库，A查询），数据筛选的标准是：一致度大于40%，查询片段的长度大于原片段长度的50%，e值小于1e-5。 9.1.1 参考文献： A Proposed Genus Boundary for the Prokaryotes Based on Genomic Insights Qi-Long Qin et al. # 下载所分析的基因组数据（蛋白序列） # 存放于 Rawdata 文件夹中 if (!dir.exists(&#39;Rawdata&#39;)) { dir.create(&#39;Rawdata&#39;) } # 示例-1: Pseudomonas aeruginosa # ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/006/765/GCF_000006765.1_ASM676v1/GCF_000006765.1_ASM676v1_protein.faa.gz # 示例-2: Acinetobacter baumannii # ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/746/645/GCF_000746645.1_ASM74664v1/GCF_000746645.1_ASM74664v1_protein.faa.gz # 使用 R.utils 中的 gunzip 解压缩 library(R.utils) download.file(&quot;ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/006/765/GCF_000006765.1_ASM676v1/GCF_000006765.1_ASM676v1_protein.faa.gz&quot;, destfile = &quot;Rawdata/Pseudomonas_aeruginosa.faa.gz&quot;) gunzip(&quot;Rawdata/Pseudomonas_aeruginosa.faa.gz&quot;) download.file(&quot;ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/746/645/GCF_000746645.1_ASM74664v1/GCF_000746645.1_ASM74664v1_protein.faa.gz&quot;, destfile = &quot;Rawdata/Acinetobacter_baumannii.faa.gz&quot;) gunzip(&quot;Rawdata/Acinetobacter_baumannii.faa.gz&quot;) # 使用 dbplyr 对数据框中的某列去重复 library(dbplyr) # 使用 seqinr 格式化fasta格式的序列 library(seqinr) # 检查存放中间过程文件的文件夹是否存在 if (!dir.exists(&#39;Database&#39;)) { dir.create(&#39;Database&#39;) } if (!dir.exists(&#39;Result&#39;)) { dir.create(&#39;Result&#39;) } # 获取所有待分析基因组文件名 genome.files &lt;- list.files(&#39;Rawdata&#39;) # 对所有的待分析基因组建库 for (gn in genome.files) { header.file &lt;- strsplit(gn,&#39;.&#39;,fixed = T)[[1]][1] commond.makedb &lt;- paste0(&#39;diamond.exe makedb --in Rawdata/&#39;, gn, &#39; --db Database/&#39;, header.file) system(commond.makedb) } # 获取多基因组的两两比对的组合数据集 genome.comn &lt;- combn(genome.files,2) # 计算核心蛋白相似性的骨架命令 blast.comm1 &lt;- &#39;diamond.exe blastp -q Rawdata/&#39; blast.comm2 &lt;- &#39; -d Database/&#39; blast.comm3 &lt;- &#39; -e 1e-5 --id 40 -o Result/&#39; # 建立新变量，保存运算结果 pocp.vector &lt;- c() for (i in (1:dim(genome.comn)[2]) ) { a.genome &lt;- genome.comn[,i][1] b.genome &lt;- genome.comn[,i][2] a.header &lt;- strsplit(a.genome,&#39;.&#39;,fixed = T)[[1]][1] b.header &lt;- strsplit(b.genome,&#39;.&#39;,fixed = T)[[1]][1] a.genome.seq &lt;- read.fasta(paste0(&#39;Rawdata/&#39;, a.genome),&#39;AA&#39;) b.genome.seq &lt;- read.fasta(paste0(&#39;Rawdata/&#39;, b.genome),&#39;AA&#39;) a.total &lt;- length(a.genome.seq) b.total &lt;- length(b.genome.seq) str(a.genome.seq) str(b.genome.seq) a.seq.list &lt;- names(a.genome.seq) b.seq.list &lt;- names(b.genome.seq) a.seq.length &lt;- c() for (nm in a.seq.list) { tmp.len &lt;- length(a.genome.seq[[which(a.seq.list == nm)]]) a.seq.length &lt;- append(a.seq.length, tmp.len) } b.seq.length &lt;- c() for (nm in b.seq.list) { tmp.len &lt;- length(b.genome.seq[[which(b.seq.list == nm)]]) b.seq.length &lt;- append(b.seq.length, tmp.len) } a.seq.df &lt;- data.frame(a.seq.list, a.seq.length) colnames(a.seq.df) &lt;- c(&#39;V1&#39;,&#39;length&#39;) b.seq.df &lt;- data.frame(b.seq.list, b.seq.length) colnames(b.seq.df) &lt;- c(&#39;V1&#39;,&#39;length&#39;) print(paste0(&#39;-- Blasting: &#39;,a.header,&#39; - VS - &#39;,b.header)) # “正向”--A为查询，B为参考数据库 result.forward &lt;- paste0(a.header,&#39;_VS_&#39;,b.header,&#39;.tab&#39;) system(paste0(blast.comm1, a.genome, blast.comm2, b.header, blast.comm3, result.forward)) df.forward &lt;- read.table(paste0(&#39;Result/&#39;,result.forward), header = F,sep = &#39;\\t&#39;, stringsAsFactors = F) df.forward &lt;- df.forward %&gt;% distinct(V1,.keep_all = T) df.forward &lt;- merge(df.forward, a.seq.df, by = &#39;V1&#39;, all.x = T) df.forward$align &lt;- df.forward$V4 / df.forward$length df.forward &lt;- df.forward[which(df.forward$V3 &gt; 40 &amp; df.forward$align &gt; 0.5 &amp; df.forward$V11 &lt; 1e-5),] C1 &lt;- dim(df.forward)[1] # “反向”--B为查询，A为参考数据库 result.backward &lt;- paste0(b.header,&#39;_VS_&#39;,a.header,&#39;.tab&#39;) system(paste0(blast.comm1, b.genome, blast.comm2, a.header, blast.comm3, result.backward)) df.backward &lt;- read.table(paste0(&#39;Result/&#39;,result.backward), header = F,sep = &#39;\\t&#39;, stringsAsFactors = F) df.backward &lt;- df.backward %&gt;% distinct(V1,.keep_all = T) df.backward &lt;- merge(df.backward, b.seq.df, by = &#39;V1&#39;, all.x = T) df.backward$align &lt;- df.backward$V4 / df.backward$length df.backward &lt;- df.backward[which(df.backward$V3 &gt; 40 &amp; df.backward$align &gt; 0.5 &amp; df.backward$V11 &lt; 1e-5),] C2 &lt;- dim(df.backward)[1] pocp &lt;- (C1 + C2)/(a.total + b.total) pocp.vector &lt;- append(pocp.vector, paste0(a.header,&#39;\\t&#39;,b.header,&#39;\\t&#39;,pocp)) print(paste0(&#39;-- Pair blast done: &#39;,a.header,&#39; - VS - &#39;,b.header)) print(paste0(&#39;-- The POCP : &#39;, pocp)) print(&#39;----------------------------------&#39;) } write(pocp.vector, &#39;resultPOCP.txt&#39;) # 删除分析过程中的冗余文件 unlink(&quot;Database&quot;, recursive = TRUE) unlink(&quot;Result&quot;, recursive = TRUE) # 重新创建新文件夹 dir.create(&#39;Database&#39;) dir.create(&#39;Result&#39;) 9.1.1.1 提示： 更多关于POCP计算的相关tips，请点击这里-跳转 9.2 调试脚本或函数 9.2.1 问题 您想要调试脚本或函数。 9.2.2 方案 将其插入您要开始调试的位置的代码中： browser() 当R解释器到达该行时，它将暂停您的代码，您将能够查看和更改变量。 在浏览器中，键入这些字母将执行以下操作 c 继续 n (or Return) 下一步 Q 放弃 Ctrl-C 回到顶级 在浏览器中，您可以看到当前范围中的变量。 ls() 要为函数中的每一行暂停和启动浏览器 debug(myfunction) myfunction(x) 9.2.3 有用的选择 默认情况下，每次在浏览器提示符下按Enter键，它都会运行下一步。这相当于按n，然后按Enter键。这可能很烦人。要禁用它，请使用： options(browserNLdisabled=TRUE) 要在抛出错误时开始调试，请在抛出错误的函数之前运行此命令 options(error=recover) 如果您希望每次启动R时都设置这些选项，则可以将它们放在~/.Rprofile文件中。 9.3 测量经过的时间 9.3.1 问题 您想要测量运行特定代码块所需的时间。 ### 方案 该system.time()函数将测量在R中运行某些东西所需的时间。 system.time({ # Do something that takes time x &lt;- 1:100000 for (i in seq_along(x)) x[i] &lt;- x[i]+1 }) #&gt; user system elapsed #&gt; 0.144 0.002 0.153 输出意味着运行代码块需要0.153秒。 9.4 获取包中的函数和对象列表 9.4.1 问题 你想知道包里有什么。 9.4.2 方案 此代码段将列出包中的函数和对象。 # Using search() in a new R session says that these packages are # loaded by default: # &quot;package:stats&quot; &quot;package:graphics&quot; # &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; # &quot;package:methods&quot; &quot;package:base&quot; # Others that are useful: # gplots # ggplot2, reshape, plyr showPackageContents &lt;- function (packageName) { # Get a list of things contained in a particular package funlist &lt;- objects(packageName) # Remove things that don&#39;t start with a letter idx &lt;- grep(&#39;^[a-zA-Z][a-zA-Z0-9._]*&#39;, funlist) funlist &lt;- funlist[idx] # Remove things that contain arrow &lt;- idx &lt;- grep(&#39;&lt;-&#39;, funlist) if (length(idx)!=0) funlist &lt;- funlist[-idx] # Make a data frame to keep track of status objectlist &lt;- data.frame(name=funlist, primitive=FALSE, func=FALSE, object=FALSE, constant=FALSE, stringsAsFactors=F) for (i in 1:nrow(objectlist)) { fname &lt;- objectlist$name[i] if (exists(fname)) { obj &lt;- get(fname) if (is.primitive(obj)) { objectlist$primitive[i] &lt;- TRUE } if (is.function(obj)) { objectlist$func[i] &lt;- TRUE } if (is.object(obj)) { objectlist$object[i] &lt;- TRUE } # I think these are generally constants if (is.vector(obj)) { objectlist$constant[i] &lt;- TRUE } } } cat(packageName) cat(&quot;\\n================================================\\n&quot;) cat(&quot;Primitive functions: \\n&quot;) cat(objectlist$name[objectlist$primitive]) cat(&quot;\\n&quot;) cat(&quot;\\n================================================\\n&quot;) cat(&quot;Non-primitive functions: \\n&quot;) cat(objectlist$name[objectlist$func &amp; !objectlist$primitive]) cat(&quot;\\n&quot;) cat(&quot;\\n================================================\\n&quot;) cat(&quot;Constants: \\n&quot;) cat(objectlist$name[objectlist$constant]) cat(&quot;\\n&quot;) cat(&quot;\\n================================================\\n&quot;) cat(&quot;Objects: \\n&quot;) cat(objectlist$name[objectlist$object]) cat(&quot;\\n&quot;) } # Run the function using base package showPackageContents(&quot;package:base&quot;) "],
["section-10.html", "第 10 章 工具 10.1 生成拉丁方", " 第 10 章 工具 10.1 生成拉丁方 10.1.1 问题 你想要生成平衡序列用于实验。 10.1.2 方案 函数 latinsquare() (在下方定义) 可以被用来生成拉丁方。 latinsquare(4) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 4 3 #&gt; [2,] 2 1 3 4 #&gt; [3,] 3 4 1 2 #&gt; [4,] 4 3 2 1 # To generate 2 Latin squares of size 4 (in sequence) latinsquare(4, reps=2) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 3 4 1 2 #&gt; [2,] 4 3 2 1 #&gt; [3,] 1 2 4 3 #&gt; [4,] 2 1 3 4 #&gt; [5,] 4 2 1 3 #&gt; [6,] 2 3 4 1 #&gt; [7,] 1 4 3 2 #&gt; [8,] 3 1 2 4 # It is better to put the random seed in the function call, to make it repeatable # This will return the same sequence of two Latin squares every time latinsquare(4, reps=2, seed=5873) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 2 3 #&gt; [2,] 4 1 3 2 #&gt; [3,] 2 3 4 1 #&gt; [4,] 3 2 1 4 #&gt; [5,] 3 2 4 1 #&gt; [6,] 1 4 2 3 #&gt; [7,] 4 3 1 2 #&gt; [8,] 2 1 3 4 存在大小为4的576个拉丁方。函数latinsquare会随机选择其中n个并以序列形式返回它们。这被称为重复拉丁方设计 。 一旦你生成了自己的拉丁方，你需要确保不存在许多重复的序列。这在小型拉丁方中非常普遍 (3x3 or 4x4)。 10.1.2.1 生成拉丁方的函数 这个函数用来生成拉丁方。它使用了略微暴力的算法来生成每个拉丁方，有时候在给定位置的数字用完了它可能会失败。这种情况下，它会尝试再试一试。可能存在一种更好的办法吧，但我并不清楚。 ## - len is the size of the latin square ## - reps is the number of repetitions - how many Latin squares to generate ## - seed is a random seed that can be used to generate repeatable sequences ## - returnstrings tells it to return a vector of char strings for each square, ## instead of a big matrix. This option is only really used for checking the ## randomness of the squares. latinsquare &lt;- function(len, reps=1, seed=NA, returnstrings=FALSE) { # Save the old random seed and use the new one, if present if (!is.na(seed)) { if (exists(&quot;.Random.seed&quot;)) { saved.seed &lt;- .Random.seed } else { saved.seed &lt;- NA } set.seed(seed) } # This matrix will contain all the individual squares allsq &lt;- matrix(nrow=reps*len, ncol=len) # Store a string id of each square if requested if (returnstrings) { squareid &lt;- vector(mode = &quot;character&quot;, length = reps) } # Get a random element from a vector (the built-in sample function annoyingly # has different behavior if there&#39;s only one element in x) sample1 &lt;- function(x) { if (length(x)==1) { return(x) } else { return(sample(x,1)) } } # Generate each of n individual squares for (n in 1:reps) { # Generate an empty square sq &lt;- matrix(nrow=len, ncol=len) # If we fill the square sequentially from top left, some latin squares # are more probable than others. So we have to do it random order, # all over the square. # The rough procedure is: # - randomly select a cell that is currently NA (call it the target cell) # - find all the NA cells sharing the same row or column as the target # - fill the target cell # - fill the other cells sharing the row/col # - If it ever is impossible to fill a cell because all the numbers # are already used, then quit and start over with a new square. # In short, it picks a random empty cell, fills it, then fills in the # other empty cells in the &quot;cross&quot; in random order. If we went totally randomly # (without the cross), the failure rate is much higher. while (any(is.na(sq))) { # Pick a random cell which is currently NA k &lt;- sample1(which(is.na(sq))) i &lt;- (k-1) %% len +1 # Get the row num j &lt;- floor((k-1) / len) +1 # Get the col num # Find the other NA cells in the &quot;cross&quot; centered at i,j sqrow &lt;- sq[i,] sqcol &lt;- sq[,j] # A matrix of coordinates of all the NA cells in the cross openCell &lt;-rbind( cbind(which(is.na(sqcol)), j), cbind(i, which(is.na(sqrow)))) # Randomize fill order openCell &lt;- openCell[sample(nrow(openCell)),] # Put center cell at top of list, so that it gets filled first openCell &lt;- rbind(c(i,j), openCell) # There will now be three entries for the center cell, so remove duplicated entries # Need to make sure it&#39;s a matrix -- otherwise, if there&#39;s just # one row, it turns into a vector, which causes problems openCell &lt;- matrix(openCell[!duplicated(openCell),], ncol=2) # Fill in the center of the cross, then the other open spaces in the cross for (c in 1:nrow(openCell)) { # The current cell to fill ci &lt;- openCell[c,1] cj &lt;- openCell[c,2] # Get the numbers that are unused in the &quot;cross&quot; centered on i,j freeNum &lt;- which(!(1:len %in% c(sq[ci,], sq[,cj]))) # Fill in this location on the square if (length(freeNum)&gt;0) { sq[ci,cj] &lt;- sample1(freeNum) } else { # Failed attempt - no available numbers # Re-generate empty square sq &lt;- matrix(nrow=len, ncol=len) # Break out of loop break; } } } # Store the individual square into the matrix containing all squares allsqrows &lt;- ((n-1)*len) + 1:len allsq[allsqrows,] &lt;- sq # Store a string representation of the square if requested. Each unique # square has a unique string. if (returnstrings) { squareid[n] &lt;- paste(sq, collapse=&quot;&quot;) } } # Restore the old random seed, if present if (!is.na(seed) &amp;&amp; !is.na(saved.seed)) { .Random.seed &lt;- saved.seed } if (returnstrings) { return(squareid) } else { return(allsq) } } 10.1.2.2 检查函数的随机性 一些生成拉丁方的算法并不是非常的随机。4x4的拉丁方有576种，它们每一种都应该有相等的概率被生成，但一些算法没有做到。可能我们没有必要检查上面的函数，但这里确实有办法可以做到这一点。前面我使用的算法并没有好的随机分布，我们运行下面的代码可以发现这一点。 这个代码创建10,000个4x4的拉丁方，然后计算这576个唯一拉丁方出现的频数。计数结果应该形成一个不是特别宽的正态分布；否则这个分布就不是很随机了。我相信期望的标准差是根号(10000/576)（假设随机生成拉丁方）。 # Set up the size and number of squares to generate squaresize &lt;- 4 numsquares &lt;- 10000 # Get number of unique squares of a given size. # There is not a general solution to finding the number of unique nxn squares # so we just hard-code the values here. (From http://oeis.org/A002860) uniquesquares &lt;- c(1, 2, 12, 576, 161280, 812851200)[squaresize] # Generate the squares s &lt;- latinsquare(squaresize, numsquares, seed=122, returnstrings=TRUE) # Get the list of all squares and counts for each slist &lt;- rle(sort(s)) scounts &lt;- slist[[1]] hist(scounts, breaks=(min(scounts):(max(scounts)+1)-.5)) cat(sprintf(&quot;Expected and actual standard deviation: %.4f, %.4f\\n&quot;, sqrt(numsquares/uniquesquares), sd(scounts) )) #&gt; Expected and actual standard deviation: 4.1667, 4.0883 img "],
["materials.html", "A 资料推荐 A.1 书籍 A.2 网站 A.3 列表", " A 资料推荐 A.1 书籍 《R for Data Science》 A.2 网站 A.3 列表 "],
["references.html", "参考文献", " 参考文献 "]
]
